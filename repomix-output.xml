This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: *.log, *.tmp, __pycache__, node_modules, .git, venv, env, profiles/, downloads/, logs/, data/*.json
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/.env.example
.gitignore
.locator/suno_img/190787ed-82e0-4ffc-87c5-2bd12c014928.jpg
.locator/suno_img/19d23860-e329-4267-aafa-1c2a5be750d9.jpg
.locator/suno_img/1b8dda96-5f83-40c7-8ace-4fa795aab343.jpg
.locator/suno_img/27881d4c-166b-4b21-82b0-63085c0fbee6.jpg
.locator/suno_img/2b6309be-0e62-4f7c-9de3-c14d0270ad85.jpg
.locator/suno_img/30e05b46-b6da-4804-96df-f75e83180d81.jpg
.locator/suno_img/3a4e49f8-2c6a-47aa-8ad5-d9fcd0dcce1a.jpg
.locator/suno_img/3d7a12a1-aaaa-4956-b3df-3ab2892ae2a2.jpg
.locator/suno_img/43052891-2663-4603-9dd1-6fdbf56b3a7b.jpg
.locator/suno_img/4c04fa49-f9a6-4f65-8cec-edd4cf0e4c7f.jpg
.locator/suno_img/5b12c330-929c-4d5e-b027-e0c048c2e7d6.jpg
.locator/suno_img/5f1ab752-b235-44ce-8a39-26b7ac6cee86.jpg
.locator/suno_img/60980253-8dc8-4433-a944-12630bceb743.jpg
.locator/suno_img/735b7675-f215-456b-808d-f30b4f7a2bd4.jpg
.locator/suno_img/77086b3f-fe47-4ba7-9136-02819954d4ca.jpg
.locator/suno_img/8921a709-5ed8-45ed-b416-d6dcfe848a74.jpg
.locator/suno_img/94677f8b-be8b-47d2-a2b8-30d90b66dc29.jpg
.locator/suno_img/b1628a85-b5dd-4a4a-89f4-ade221b061dc.jpg
.locator/suno_img/b43444a2-3811-47fe-ad05-34bf247b6c22.jpg
.locator/suno_img/b4bbb50b-c527-425c-98d2-518c745479d6.jpg
.locator/suno_img/b4fc68fa-8946-4510-a1ab-36642fef2114.jpg
.locator/suno_img/dde77766-a4ba-4aef-8d53-840cc88723a8.jpg
.locator/suno_img/ec296778-e7ef-4f8d-9723-d1153a31352c.jpg
.locator/suno.cnstore
.repomixignore
AGENTS.md
app.py
CLAUDE.md
config/__init__.py
config/AGENTS.md
config/settings.py
config/style_config.py
config/suno_selectors_from_clicknium.py
data/README.md
GEMINI.md
legacy_modules/__init__.py
legacy_modules/AGENTS.md
legacy_modules/README.md
legacy_modules/suno_auto_create.py
legacy_modules/suno_batch_download.py
log.txt
logo.ico
nul
plan.txt
README.md
requirements.txt
scripts/smoke_check_app.py
songs-download/ðŸŽµ à¸ªà¸¸à¸”à¸—à¹‰à¸²à¸¢à¸‚à¸­à¸‡à¸„à¸£à¸´à¸ªà¸•à¹Œà¸¡à¸²à¸ª__ID__24b3138e-d0b1-43fd-8361-6e5a990abcf1.mp3
songs-download/ðŸŽµ à¸ªà¸¸à¸”à¸—à¹‰à¸²à¸¢à¸‚à¸­à¸‡à¸„à¸£à¸´à¸ªà¸•à¹Œà¸¡à¸²à¸ª__ID__d331186e-1f3e-4b48-b1b0-b9897787a374.mp3
songs-download/Snowfall On The Vinyl__ID__ee0cced1-b3c2-43b3-b90a-a70183b5af54.mp3
songs/ðŸŽµ à¸ªà¸¸à¸”à¸—à¹‰à¸²à¸¢à¸‚à¸­à¸‡à¸„à¸£à¸´à¸ªà¸•à¹Œà¸¡à¸²à¸ª__ID__24b3138e-d0b1-43fd-8361-6e5a990abcf1.mp3
songs/ðŸŽµ à¸ªà¸¸à¸”à¸—à¹‰à¸²à¸¢à¸‚à¸­à¸‡à¸„à¸£à¸´à¸ªà¸•à¹Œà¸¡à¸²à¸ª__ID__d331186e-1f3e-4b48-b1b0-b9897787a374_1.mp3
songs/ðŸŽµ à¸ªà¸¸à¸”à¸—à¹‰à¸²à¸¢à¸‚à¸­à¸‡à¸„à¸£à¸´à¸ªà¸•à¹Œà¸¡à¸²à¸ª__ID__d331186e-1f3e-4b48-b1b0-b9897787a374.mp3
src/__init__.py
src/core/__init__.py
src/core/account_manager.py
src/core/AGENTS.md
src/core/batch_song_creator.py
src/core/download_manager.py
src/core/js_snippets.py
src/core/queue_manager.py
src/core/session_manager.py
src/core/song_creation_history_manager.py
src/core/song_creation_manager.py
src/core/song_models.py
src/core/suno_api_client.py
src/core/suno_form_automation.py
src/models/__init__.py
src/models/data_models.py
src/prompt/multiple-suno-prompt.xml
src/prompt/suno-prompt.xml
src/ui/__init__.py
src/ui/account_panel.py
src/ui/AGENTS.md
src/ui/components/__init__.py
src/ui/components/advanced_options_widget.py
src/ui/components/preview_widget.py
src/ui/components/suno_selectors.py
src/ui/create_music_panel.py
src/ui/create_music_panel.py.backup
src/ui/create_panel.py
src/ui/download_panel.py
src/ui/history_panel.py
src/ui/main_window.py
src/ui/multiple_songs_panel.py
src/ui/song_creation_history_panel.py
src/utils/__init__.py
src/utils/file_downloader.py
src/utils/helpers.py
src/utils/logger.py
src/utils/metadata_handler.py
src/utils/prompt_parser.py
src/utils/stealth_driver.py
tools/clicknium_to_xpath.py
tools/patch_download_panel.py
tools/sync_todos.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/.env.example">
# Claude Code - Project-Level Environment Variables
# Priority: process.env > .claude/.env > .claude/hooks/.env
# Copy this file to .env and set your API keys and configuration

# ============================================
# Claude Code Notification Hooks
# ============================================
# Discord Webhook URL (for Discord notifications)
# Get from: Server Settings â†’ Integrations â†’ Webhooks â†’ New Webhook
DISCORD_WEBHOOK_URL=

# Telegram Bot Token (for Telegram notifications)
# Get from: @BotFather in Telegram
TELEGRAM_BOT_TOKEN=

# Telegram Chat ID (your chat ID or group ID)
# Get from: https://api.telegram.org/bot<BOT_TOKEN>/getUpdates
TELEGRAM_CHAT_ID=

# ============================================
# Google Gemini API Key (for Gemini skills)
# ============================================
# Get your key at: https://aistudio.google.com/apikey
GEMINI_API_KEY=your-gemini-api-key-here

# ==== Vertex AI (Optional) ====
# Uncomment to use Vertex AI instead of AI Studio
# GEMINI_USE_VERTEX=true
# VERTEX_PROJECT_ID=your-gcp-project-id
# VERTEX_LOCATION=us-central1

# Add other API keys and configuration as needed
</file>

<file path=".gitignore">
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
#poetry.lock

# pdm
#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
#pdm.lock
#   pdm stores project-wide configurations in .pdm.toml, but it is recommended to not include it
#   in version control.
#   https://pdm.fming.dev/#use-with-ide
.pdm.toml

# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
#.idea/

# Project specific
profiles/*/
downloads/*/
logs/
*.json
!data/*.json
!data/README.md
*.pkl
*.pma
</file>

<file path=".locator/suno.cnstore">
{
  "id": "f23d2fc7-f86b-4f12-9bfc-c433f5df146a",
  "name": "suno",
  "nodes": [],
  "locators": [
    {
      "id": "e3f3a779-d850-481a-8aa7-4a9946902f2b",
      "name": "Custombutton",
      "filePath": "94677f8b-be8b-47d2-a2b8-30d90b66dc29.jpg",
      "content": {
        "automationType": "Chrome",
        "processName": {
          "value": "chrome"
        },
        "filePath": {
          "value": "chrome.exe"
        },
        "version": {
          "value": "1.3"
        },
        "childControls": [
          {
            "identifier": {
              "role": {
                "value": "window"
              },
              "title": {
                "value": "Suno | AI Music"
              },
              "url": {
                "value": "https://suno.com/create",
                "excluded": true
              },
              "className": {
                "value": "Chrome_WidgetWin_1"
              },
              "controlMetaType": "Tab"
            },
            "childControls": [
              {
                "identifier": {
                  "tag": {
                    "value": "DIV"
                  },
                  "class": {
                    "value": "css-1j1umhh edu83vi1"
                  },
                  "ancestorId": {
                    "value": "main-container"
                  },
                  "ancestorClass": {
                    "value": "active css-1tqwquh edu83vi0",
                    "excluded": true
                  },
                  "isLeaf": {
                    "value": "1"
                  },
                  "cssSelector": {
                    "value": "body>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>span>span>button>div",
                    "excluded": true
                  },
                  "tableRow": {
                    "value": "-1",
                    "excluded": true
                  },
                  "tableCol": {
                    "value": "-1",
                    "excluded": true
                  },
                  "controlMetaType": "Web",
                  "index": {
                    "value": "1",
                    "excluded": true
                  },
                  "style": {
                    "isCustom": true,
                    "value": "opacity: 1;",
                    "operator": "equals",
                    "excluded": true
                  }
                }
              }
            ]
          }
        ]
      }
    },
    {
      "id": "5eba36a8-9a3b-40a7-8ef5-6b6ed25fecd2",
      "name": "span_custom",
      "filePath": "dde77766-a4ba-4aef-8d53-840cc88723a8.jpg",
      "content": {
        "automationType": "Chrome",
        "processName": {
          "value": "chrome"
        },
        "filePath": {
          "value": "chrome.exe"
        },
        "version": {
          "value": "1.3"
        },
        "childControls": [
          {
            "identifier": {
              "role": {
                "value": "window"
              },
              "title": {
                "value": "Suno | AI Music"
              },
              "url": {
                "value": "https://suno.com/create",
                "excluded": true
              },
              "className": {
                "value": "Chrome_WidgetWin_1"
              },
              "controlMetaType": "Tab"
            },
            "childControls": [
              {
                "identifier": {
                  "tag": {
                    "value": "SPAN"
                  },
                  "class": {
                    "value": "css-gixt5w edu83vi2",
                    "excluded": true
                  },
                  "ancestorId": {
                    "value": "main-container"
                  },
                  "ancestorClass": {
                    "value": "active css-1tqwquh edu83vi0",
                    "excluded": true
                  },
                  "isLeaf": {
                    "value": "1",
                    "excluded": true
                  },
                  "cssSelector": {
                    "value": "body>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>span>span>button>span",
                    "excluded": true
                  },
                  "sInfo": {
                    "value": "Custom"
                  },
                  "tableRow": {
                    "value": "-1",
                    "excluded": true
                  },
                  "tableCol": {
                    "value": "-1",
                    "excluded": true
                  },
                  "controlMetaType": "Web",
                  "index": {
                    "value": "1",
                    "excluded": true
                  }
                }
              }
            ]
          }
        ]
      }
    },
    {
      "id": "be8be1dc-e538-4ac4-99db-161839d2329c",
      "name": "textarea_write_some_lyrics_or_a_prompt_or_leave_blank_for_instru",
      "filePath": "3a4e49f8-2c6a-47aa-8ad5-d9fcd0dcce1a.jpg",
      "content": {
        "automationType": "Chrome",
        "processName": {
          "value": "chrome"
        },
        "filePath": {
          "value": "chrome.exe"
        },
        "version": {
          "value": "1.3"
        },
        "childControls": [
          {
            "identifier": {
              "role": {
                "value": "window"
              },
              "title": {
                "value": "Suno | AI Music"
              },
              "url": {
                "value": "https://suno.com/create",
                "excluded": true
              },
              "className": {
                "value": "Chrome_WidgetWin_1"
              },
              "controlMetaType": "Tab"
            },
            "childControls": [
              {
                "identifier": {
                  "tag": {
                    "value": "TEXTAREA"
                  },
                  "class": {
                    "value": "w-full resize-none border-none bg-transparent text-base outline-none md:text-sm placeholder:text-background-fog-dense",
                    "excluded": true
                  },
                  "ancestorId": {
                    "value": "main-container",
                    "excluded": true
                  },
                  "ancestorClass": {
                    "value": "relative mb-0 pb-0 css-16gnezu ed4vkow0"
                  },
                  "isLeaf": {
                    "value": "1",
                    "excluded": true
                  },
                  "cssSelector": {
                    "value": "body>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>textarea",
                    "excluded": true
                  },
                  "tableRow": {
                    "value": "-1",
                    "excluded": true
                  },
                  "tableCol": {
                    "value": "-1",
                    "excluded": true
                  },
                  "controlMetaType": "Web",
                  "index": {
                    "value": "1",
                    "excluded": true
                  },
                  "placeholder": {
                    "isCustom": true,
                    "value": "Write some lyrics or a prompt â€” or leave blank for instrumental",
                    "operator": "equals",
                    "excluded": true
                  },
                  "style": {
                    "isCustom": true,
                    "value": "height: 100px;",
                    "operator": "equals",
                    "excluded": true
                  }
                }
              }
            ]
          }
        ]
      }
    },
    {
      "id": "643304da-1eee-41ce-86b7-f1a4a0a9622b",
      "name": "textarea_indie_electronic_synths_120bpm_distorted",
      "filePath": "1b8dda96-5f83-40c7-8ace-4fa795aab343.jpg",
      "content": {
        "automationType": "Chrome",
        "processName": {
          "value": "chrome"
        },
        "filePath": {
          "value": "chrome.exe"
        },
        "version": {
          "value": "1.3"
        },
        "childControls": [
          {
            "identifier": {
              "role": {
                "value": "window"
              },
              "title": {
                "value": "Suno | AI Music"
              },
              "url": {
                "value": "https://suno.com/create",
                "excluded": true
              },
              "className": {
                "value": "Chrome_WidgetWin_1"
              },
              "controlMetaType": "Tab"
            },
            "childControls": [
              {
                "identifier": {
                  "tag": {
                    "value": "TEXTAREA"
                  },
                  "class": {
                    "value": "w-full resize-none border-none bg-transparent text-base outline-none md:text-sm placeholder:text-background-fog-dense",
                    "excluded": true
                  },
                  "ancestorId": {
                    "value": "main-container",
                    "excluded": true
                  },
                  "ancestorClass": {
                    "value": "mb-0 pb-0 css-16gnezu ed4vkow0"
                  },
                  "isLeaf": {
                    "value": "1",
                    "excluded": true
                  },
                  "cssSelector": {
                    "value": "body>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>textarea",
                    "excluded": true
                  },
                  "tableRow": {
                    "value": "-1",
                    "excluded": true
                  },
                  "tableCol": {
                    "value": "-1",
                    "excluded": true
                  },
                  "controlMetaType": "Web",
                  "index": {
                    "value": "1"
                  },
                  "placeholder": {
                    "isCustom": true,
                    "value": "indie, electronic, synths, 120bpm, distorted",
                    "operator": "equals",
                    "excluded": true
                  },
                  "maxlength": {
                    "isCustom": true,
                    "value": "1000",
                    "operator": "equals",
                    "excluded": true
                  },
                  "style": {
                    "isCustom": true,
                    "value": "height: 100px;",
                    "operator": "equals",
                    "excluded": true
                  }
                }
              }
            ]
          }
        ]
      }
    },
    {
      "id": "a381c323-ff6c-4f80-ac87-43473bfd40cb",
      "name": "input_song_title_optional",
      "filePath": "2b6309be-0e62-4f7c-9de3-c14d0270ad85.jpg",
      "content": {
        "automationType": "Chrome",
        "processName": {
          "value": "chrome"
        },
        "filePath": {
          "value": "chrome.exe"
        },
        "version": {
          "value": "1.3"
        },
        "childControls": [
          {
            "identifier": {
              "role": {
                "value": "window"
              },
              "title": {
                "value": "Suno | AI Music"
              },
              "url": {
                "value": "https://suno.com/create",
                "excluded": true
              },
              "className": {
                "value": "Chrome_WidgetWin_1"
              },
              "controlMetaType": "Tab"
            },
            "childControls": [
              {
                "identifier": {
                  "tag": {
                    "value": "INPUT"
                  },
                  "class": {
                    "value": "ml-2 flex-1 bg-transparent py-2 outline-none placeholder:text-ba*"
                  },
                  "ancestorId": {
                    "value": "main-container",
                    "excluded": true
                  },
                  "ancestorClass": {
                    "value": "css-1is7h4f e1y3uoek1",
                    "excluded": true
                  },
                  "isLeaf": {
                    "value": "1",
                    "excluded": true
                  },
                  "cssSelector": {
                    "value": "body>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>input",
                    "excluded": true
                  },
                  "tableRow": {
                    "value": "-1",
                    "excluded": true
                  },
                  "tableCol": {
                    "value": "-1",
                    "excluded": true
                  },
                  "controlMetaType": "Web",
                  "index": {
                    "value": "2"
                  },
                  "placeholder": {
                    "isCustom": true,
                    "value": "Song Title (Optional)",
                    "operator": "equals",
                    "excluded": true
                  },
                  "wfd-id": {
                    "isCustom": true,
                    "value": "id3",
                    "operator": "equals",
                    "excluded": true
                  }
                }
              }
            ]
          }
        ]
      }
    },
    {
      "id": "207c81ed-4123-439b-9e89-9668be5a630d",
      "name": "button_create_song",
      "filePath": "b4fc68fa-8946-4510-a1ab-36642fef2114.jpg",
      "content": {
        "automationType": "Chrome",
        "processName": {
          "value": "chrome"
        },
        "filePath": {
          "value": "chrome.exe"
        },
        "version": {
          "value": "1.3"
        },
        "childControls": [
          {
            "identifier": {
              "role": {
                "value": "window"
              },
              "title": {
                "value": "Suno | AI Music"
              },
              "url": {
                "value": "https://suno.com/create",
                "excluded": true
              },
              "className": {
                "value": "Chrome_WidgetWin_1"
              },
              "controlMetaType": "Tab"
            },
            "childControls": [
              {
                "identifier": {
                  "tag": {
                    "value": "BUTTON"
                  },
                  "class": {
                    "value": "relative inline-block font-sans font-medium text-center before:absolute before:inset-0 before:pointer-events-none before:rounded-[inherit] before:border before:border-transparent before:bg-transparent after:absolute after:inset-0 after:pointer-events-none after:rounded-[inherit] after:bg-transparent after:opacity-0 enabled:hover:after:opacity-100 before:transition before:duration-75 after:transition after:duration-75 select-none cursor-pointer disabled:cursor-not-allowed text-[17px] leading-[24px] rounded-full enabled:hover:before:bg-overlay-on-primary disabled:after:bg-background-primary disabled:after:opacity-50 flex-grow p-3 transition-all duration-200 bg-background-tertiary text-foreground-inactive css-x7k4s3 e1t805jb0",
                    "excluded": true
                  },
                  "type": {
                    "value": "button"
                  },
                  "ancestorId": {
                    "value": "main-container"
                  },
                  "ancestorClass": {
                    "value": "flex items-center justify-stretch gap-4 bg-background-primary p-4",
                    "excluded": true
                  },
                  "isLeaf": {
                    "value": "0",
                    "excluded": true
                  },
                  "cssSelector": {
                    "value": "body>div>div>div>div>div>div>div>div>div>div>div>div>div>div>button",
                    "excluded": true
                  },
                  "sInfo": {
                    "value": "Create"
                  },
                  "tableRow": {
                    "value": "-1",
                    "excluded": true
                  },
                  "tableCol": {
                    "value": "-1",
                    "excluded": true
                  },
                  "controlMetaType": "Web",
                  "index": {
                    "value": "1",
                    "excluded": true
                  },
                  "disabled": {
                    "isCustom": true,
                    "value": "disabled",
                    "operator": "equals",
                    "excluded": true
                  },
                  "aria-label": {
                    "isCustom": true,
                    "value": "Create song",
                    "operator": "equals",
                    "excluded": true
                  },
                  "aria-describedby": {
                    "isCustom": true,
                    "value": "tooltip-Â«r4pÂ»",
                    "operator": "equals",
                    "excluded": true
                  }
                }
              }
            ]
          }
        ]
      }
    },
    {
      "id": "7379f4f0-26b6-460d-ab65-d256de35ec49",
      "name": "span_create",
      "filePath": "735b7675-f215-456b-808d-f30b4f7a2bd4.jpg",
      "content": {
        "automationType": "Chrome",
        "processName": {
          "value": "chrome"
        },
        "filePath": {
          "value": "chrome.exe"
        },
        "version": {
          "value": "1.3"
        },
        "childControls": [
          {
            "identifier": {
              "role": {
                "value": "window"
              },
              "title": {
                "value": "Suno | AI Music"
              },
              "url": {
                "value": "https://suno.com/create",
                "excluded": true
              },
              "className": {
                "value": "Chrome_WidgetWin_1"
              },
              "controlMetaType": "Tab"
            },
            "childControls": [
              {
                "identifier": {
                  "tag": {
                    "value": "SPAN"
                  },
                  "class": {
                    "value": "relative flex flex-row items-center justify-center gap-2",
                    "excluded": true
                  },
                  "ancestorId": {
                    "value": "main-container"
                  },
                  "ancestorClass": {
                    "value": "relative inline-block font-sans font-medium text-center before:absolute before:inset-0 before:pointer-events-none before:rounded-[inherit] before:border before:border-transparent before:bg-transparent after:absolute after:inset-0 after:pointer-events-none after:rounded-[inherit] after:bg-transparent after:opacity-0 enabled:hover:after:opacity-100 before:transition before:duration-75 after:transition after:duration-75 select-none cursor-pointer disabled:cursor-not-allowed text-[17px] leading-[24px] rounded-full enabled:hover:before:bg-overlay-on-primary disabled:after:bg-background-primary disabled:after:opacity-50 flex-grow p-3 transition-all duration-200 bg-background-tertiary text-foreground-inactive css-x7k4s3 e1t805jb0",
                    "excluded": true
                  },
                  "isLeaf": {
                    "value": "0",
                    "excluded": true
                  },
                  "cssSelector": {
                    "value": "body>div>div>div>div>div>div>div>div>div>div>div>div>div>div>button>span",
                    "excluded": true
                  },
                  "sInfo": {
                    "value": "Create"
                  },
                  "tableRow": {
                    "value": "-1",
                    "excluded": true
                  },
                  "tableCol": {
                    "value": "-1",
                    "excluded": true
                  },
                  "controlMetaType": "Web",
                  "index": {
                    "value": "1",
                    "excluded": true
                  }
                }
              }
            ]
          }
        ]
      }
    },
    {
      "id": "b33dbda5-29e4-4753-af90-844065c83b10",
      "name": "advancedoptions",
      "filePath": "3d7a12a1-aaaa-4956-b3df-3ab2892ae2a2.jpg",
      "content": {
        "automationType": "Chrome",
        "processName": {
          "value": "chrome"
        },
        "filePath": {
          "value": "chrome.exe"
        },
        "version": {
          "value": "1.3"
        },
        "childControls": [
          {
            "identifier": {
              "role": {
                "value": "window"
              },
              "title": {
                "value": "Suno | AI Music"
              },
              "url": {
                "value": "https://suno.com/create",
                "excluded": true
              },
              "className": {
                "value": "Chrome_WidgetWin_1"
              },
              "controlMetaType": "Tab"
            },
            "childControls": [
              {
                "identifier": {
                  "tag": {
                    "value": "DIV"
                  },
                  "class": {
                    "value": "css-1f7qn6n ehq3pfj1",
                    "excluded": true
                  },
                  "ancestorId": {
                    "value": "main-container"
                  },
                  "ancestorClass": {
                    "value": "css-1xt3ue1 ehq3pfj0",
                    "excluded": true
                  },
                  "isLeaf": {
                    "value": "0",
                    "excluded": true
                  },
                  "cssSelector": {
                    "value": "body>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div",
                    "excluded": true
                  },
                  "tableRow": {
                    "value": "-1",
                    "excluded": true
                  },
                  "tableCol": {
                    "value": "-1",
                    "excluded": true
                  },
                  "tabIndex": {
                    "value": "0"
                  },
                  "controlMetaType": "Web",
                  "index": {
                    "value": "3"
                  },
                  "role": {
                    "isCustom": true,
                    "value": "button",
                    "operator": "equals",
                    "excluded": true
                  },
                  "aria-expanded": {
                    "isCustom": true,
                    "value": "false",
                    "operator": "equals",
                    "excluded": true
                  }
                }
              }
            ]
          }
        ]
      }
    },
    {
      "id": "2ecb197c-ab87-44ae-bff1-5fcf6706693e",
      "name": "div_advanced_options",
      "filePath": "19d23860-e329-4267-aafa-1c2a5be750d9.jpg",
      "content": {
        "automationType": "Chrome",
        "processName": {
          "value": "chrome"
        },
        "filePath": {
          "value": "chrome.exe"
        },
        "version": {
          "value": "1.3"
        },
        "childControls": [
          {
            "identifier": {
              "role": {
                "value": "window"
              },
              "title": {
                "value": "Suno | AI Music"
              },
              "url": {
                "value": "https://suno.com/create",
                "excluded": true
              },
              "className": {
                "value": "Chrome_WidgetWin_1"
              },
              "controlMetaType": "Tab"
            },
            "childControls": [
              {
                "identifier": {
                  "tag": {
                    "value": "DIV"
                  },
                  "class": {
                    "value": "css-1a6mtca evrx9ia3",
                    "excluded": true
                  },
                  "ancestorId": {
                    "value": "main-container"
                  },
                  "ancestorClass": {
                    "value": "css-6jsm4u evrx9ia2",
                    "excluded": true
                  },
                  "isLeaf": {
                    "value": "1",
                    "excluded": true
                  },
                  "cssSelector": {
                    "value": "body>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div",
                    "excluded": true
                  },
                  "sInfo": {
                    "value": "Advanced Options"
                  },
                  "tableRow": {
                    "value": "-1",
                    "excluded": true
                  },
                  "tableCol": {
                    "value": "-1",
                    "excluded": true
                  },
                  "controlMetaType": "Web",
                  "index": {
                    "value": "1",
                    "excluded": true
                  }
                }
              }
            ]
          }
        ]
      }
    },
    {
      "id": "331ca342-bf84-426a-992f-8617e4b3c0da",
      "name": "input_exclude_styles",
      "filePath": "b1628a85-b5dd-4a4a-89f4-ade221b061dc.jpg",
      "content": {
        "automationType": "Chrome",
        "processName": {
          "value": "chrome"
        },
        "filePath": {
          "value": "chrome.exe"
        },
        "version": {
          "value": "1.3"
        },
        "childControls": [
          {
            "identifier": {
              "role": {
                "value": "window"
              },
              "title": {
                "value": "Suno | AI Music"
              },
              "url": {
                "value": "https://suno.com/create",
                "excluded": true
              },
              "className": {
                "value": "Chrome_WidgetWin_1"
              },
              "controlMetaType": "Tab"
            },
            "childControls": [
              {
                "identifier": {
                  "tag": {
                    "value": "INPUT"
                  },
                  "ancestorId": {
                    "value": "main-container",
                    "excluded": true
                  },
                  "ancestorClass": {
                    "value": "css-1jy63we e17w2jnj0"
                  },
                  "isLeaf": {
                    "value": "1",
                    "excluded": true
                  },
                  "cssSelector": {
                    "value": "body>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>input",
                    "excluded": true
                  },
                  "tableRow": {
                    "value": "-1",
                    "excluded": true
                  },
                  "tableCol": {
                    "value": "-1",
                    "excluded": true
                  },
                  "controlMetaType": "Web",
                  "index": {
                    "value": "1",
                    "excluded": true
                  },
                  "placeholder": {
                    "isCustom": true,
                    "value": "Exclude styles",
                    "operator": "equals",
                    "excluded": true
                  },
                  "maxlength": {
                    "isCustom": true,
                    "value": "1000",
                    "operator": "equals",
                    "excluded": true
                  },
                  "wfd-id": {
                    "isCustom": true,
                    "value": "id2",
                    "operator": "equals",
                    "excluded": true
                  }
                }
              }
            ]
          }
        ]
      }
    },
    {
      "id": "725726e5-011a-4282-ab1f-dd913876dbf1",
      "name": "button_male",
      "filePath": "b4bbb50b-c527-425c-98d2-518c745479d6.jpg",
      "content": {
        "automationType": "Chrome",
        "processName": {
          "value": "chrome"
        },
        "filePath": {
          "value": "chrome.exe"
        },
        "version": {
          "value": "1.3"
        },
        "childControls": [
          {
            "identifier": {
              "role": {
                "value": "window"
              },
              "title": {
                "value": "Suno | AI Music"
              },
              "url": {
                "value": "https://suno.com/create",
                "excluded": true
              },
              "className": {
                "value": "Chrome_WidgetWin_1"
              },
              "controlMetaType": "Tab"
            },
            "childControls": [
              {
                "identifier": {
                  "tag": {
                    "value": "BUTTON"
                  },
                  "class": {
                    "value": "relative inline-block font-sans font-medium text-center before:absolute before:inset-0 before:pointer-events-none before:rounded-[inherit] before:border before:border-transparent before:bg-transparent after:absolute after:inset-0 after:pointer-events-none after:rounded-[inherit] after:bg-transparent after:opacity-0 enabled:hover:after:opacity-100 transition duration-75 before:transition before:duration-75 after:transition after:duration-75 select-none cursor-pointer px-2 py-0.5 rounded-md bg-transparent enabled:hover:before:bg-overlay-on-primary disabled:after:bg-background-primary disabled:after:opacity-50 text-gray-400 mr-px text-xs hover:text-foreground-primary",
                    "excluded": true
                  },
                  "type": {
                    "value": "button"
                  },
                  "ancestorId": {
                    "value": "main-container"
                  },
                  "ancestorClass": {
                    "value": "css-slfj3p e9h95zo5",
                    "excluded": true
                  },
                  "isLeaf": {
                    "value": "0",
                    "excluded": true
                  },
                  "cssSelector": {
                    "value": "body>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>button",
                    "excluded": true
                  },
                  "sInfo": {
                    "value": "Male"
                  },
                  "tableRow": {
                    "value": "-1",
                    "excluded": true
                  },
                  "tableCol": {
                    "value": "-1",
                    "excluded": true
                  },
                  "controlMetaType": "Web",
                  "index": {
                    "value": "1",
                    "excluded": true
                  },
                  "data-selected": {
                    "isCustom": true,
                    "value": "false",
                    "operator": "equals",
                    "excluded": true
                  }
                }
              }
            ]
          }
        ]
      }
    },
    {
      "id": "cdafd521-3388-417f-8f95-3e79e77d7100",
      "name": "button_female",
      "filePath": "27881d4c-166b-4b21-82b0-63085c0fbee6.jpg",
      "content": {
        "automationType": "Chrome",
        "processName": {
          "value": "chrome"
        },
        "filePath": {
          "value": "chrome.exe"
        },
        "version": {
          "value": "1.3"
        },
        "childControls": [
          {
            "identifier": {
              "role": {
                "value": "window"
              },
              "title": {
                "value": "Suno | AI Music"
              },
              "url": {
                "value": "https://suno.com/create",
                "excluded": true
              },
              "className": {
                "value": "Chrome_WidgetWin_1"
              },
              "controlMetaType": "Tab"
            },
            "childControls": [
              {
                "identifier": {
                  "tag": {
                    "value": "BUTTON"
                  },
                  "class": {
                    "value": "relative inline-block font-sans font-medium text-center before:absolute before:inset-0 before:pointer-events-none before:rounded-[inherit] before:border before:border-transparent before:bg-transparent after:absolute after:inset-0 after:pointer-events-none after:rounded-[inherit] after:bg-transparent after:opacity-0 enabled:hover:after:opacity-100 transition duration-75 before:transition before:duration-75 after:transition after:duration-75 select-none cursor-pointer px-2 py-0.5 rounded-md bg-transparent enabled:hover:before:bg-overlay-on-primary disabled:after:bg-background-primary disabled:after:opacity-50 text-gray-400 mr-px text-xs hover:text-foreground-primary",
                    "excluded": true
                  },
                  "type": {
                    "value": "button"
                  },
                  "ancestorId": {
                    "value": "main-container"
                  },
                  "ancestorClass": {
                    "value": "css-slfj3p e9h95zo5",
                    "excluded": true
                  },
                  "isLeaf": {
                    "value": "0",
                    "excluded": true
                  },
                  "cssSelector": {
                    "value": "body>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>button",
                    "excluded": true
                  },
                  "sInfo": {
                    "value": "Female"
                  },
                  "tableRow": {
                    "value": "-1",
                    "excluded": true
                  },
                  "tableCol": {
                    "value": "-1",
                    "excluded": true
                  },
                  "controlMetaType": "Web",
                  "index": {
                    "value": "1",
                    "excluded": true
                  },
                  "data-selected": {
                    "isCustom": true,
                    "value": "false",
                    "operator": "equals",
                    "excluded": true
                  }
                }
              }
            ]
          }
        ]
      }
    },
    {
      "id": "7772fa17-5aa5-42c6-93d5-b0245dcc1e92",
      "name": "button_manual",
      "filePath": "77086b3f-fe47-4ba7-9136-02819954d4ca.jpg",
      "content": {
        "automationType": "Chrome",
        "processName": {
          "value": "chrome"
        },
        "filePath": {
          "value": "chrome.exe"
        },
        "version": {
          "value": "1.3"
        },
        "childControls": [
          {
            "identifier": {
              "role": {
                "value": "window"
              },
              "title": {
                "value": "Suno | AI Music"
              },
              "url": {
                "value": "https://suno.com/create",
                "excluded": true
              },
              "className": {
                "value": "Chrome_WidgetWin_1"
              },
              "controlMetaType": "Tab"
            },
            "childControls": [
              {
                "identifier": {
                  "tag": {
                    "value": "BUTTON"
                  },
                  "class": {
                    "value": "relative inline-block font-sans font-medium text-center before:absolute before:inset-0 before:pointer-events-none before:rounded-[inherit] before:border before:border-transparent before:bg-transparent after:absolute after:inset-0 after:pointer-events-none after:rounded-[inherit] after:bg-transparent after:opacity-0 enabled:hover:after:opacity-100 transition duration-75 before:transition before:duration-75 after:transition after:duration-75 select-none cursor-pointer px-2 py-0.5 rounded-md bg-background-tertiary enabled:hover:before:bg-overlay-on-primary disabled:after:bg-background-primary disabled:after:opacity-50 text-foreground-primary mr-px text-xs hover:text-foreground-primary",
                    "excluded": true
                  },
                  "type": {
                    "value": "button"
                  },
                  "ancestorId": {
                    "value": "main-container"
                  },
                  "ancestorClass": {
                    "value": "css-slfj3p e9h95zo5",
                    "excluded": true
                  },
                  "isLeaf": {
                    "value": "0",
                    "excluded": true
                  },
                  "cssSelector": {
                    "value": "body>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>button",
                    "excluded": true
                  },
                  "sInfo": {
                    "value": "Manual"
                  },
                  "tableRow": {
                    "value": "-1",
                    "excluded": true
                  },
                  "tableCol": {
                    "value": "-1",
                    "excluded": true
                  },
                  "controlMetaType": "Web",
                  "index": {
                    "value": "1",
                    "excluded": true
                  },
                  "data-selected": {
                    "isCustom": true,
                    "value": "true",
                    "operator": "equals",
                    "excluded": true
                  },
                  "aria-describedby": {
                    "isCustom": true,
                    "value": "tooltip-Â«r4fÂ»",
                    "operator": "equals",
                    "excluded": true
                  }
                }
              }
            ]
          }
        ]
      }
    },
    {
      "id": "64e8336e-3933-418e-9929-d9ef235fb766",
      "name": "button_auto",
      "filePath": "30e05b46-b6da-4804-96df-f75e83180d81.jpg",
      "content": {
        "automationType": "Chrome",
        "processName": {
          "value": "chrome"
        },
        "filePath": {
          "value": "chrome.exe"
        },
        "version": {
          "value": "1.3"
        },
        "childControls": [
          {
            "identifier": {
              "role": {
                "value": "window"
              },
              "title": {
                "value": "Suno | AI Music"
              },
              "url": {
                "value": "https://suno.com/create",
                "excluded": true
              },
              "className": {
                "value": "Chrome_WidgetWin_1"
              },
              "controlMetaType": "Tab"
            },
            "childControls": [
              {
                "identifier": {
                  "tag": {
                    "value": "BUTTON"
                  },
                  "class": {
                    "value": "relative inline-block font-sans font-medium text-center before:absolute before:inset-0 before:pointer-events-none before:rounded-[inherit] before:border before:border-transparent before:bg-transparent after:absolute after:inset-0 after:pointer-events-none after:rounded-[inherit] after:bg-transparent after:opacity-0 enabled:hover:after:opacity-100 transition duration-75 before:transition before:duration-75 after:transition after:duration-75 select-none cursor-pointer px-2 py-0.5 rounded-md bg-transparent enabled:hover:before:bg-overlay-on-primary disabled:after:bg-background-primary disabled:after:opacity-50 text-gray-400 mr-px text-xs hover:text-foreground-primary",
                    "excluded": true
                  },
                  "type": {
                    "value": "button"
                  },
                  "ancestorId": {
                    "value": "main-container"
                  },
                  "ancestorClass": {
                    "value": "css-slfj3p e9h95zo5",
                    "excluded": true
                  },
                  "isLeaf": {
                    "value": "0",
                    "excluded": true
                  },
                  "cssSelector": {
                    "value": "body>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>button",
                    "excluded": true
                  },
                  "sInfo": {
                    "value": "Auto"
                  },
                  "tableRow": {
                    "value": "-1",
                    "excluded": true
                  },
                  "tableCol": {
                    "value": "-1",
                    "excluded": true
                  },
                  "controlMetaType": "Web",
                  "index": {
                    "value": "1",
                    "excluded": true
                  },
                  "data-selected": {
                    "isCustom": true,
                    "value": "false",
                    "operator": "equals",
                    "excluded": true
                  },
                  "aria-describedby": {
                    "isCustom": true,
                    "value": "tooltip-Â«r4hÂ»",
                    "operator": "equals",
                    "excluded": true
                  }
                }
              }
            ]
          }
        ]
      }
    },
    {
      "id": "cfcc23d9-4db3-4e85-bdb9-55cf17c4de44",
      "name": "slider_weirdness",
      "filePath": "b43444a2-3811-47fe-ad05-34bf247b6c22.jpg",
      "content": {
        "automationType": "Chrome",
        "processName": {
          "value": "chrome"
        },
        "filePath": {
          "value": "chrome.exe"
        },
        "version": {
          "value": "1.3"
        },
        "childControls": [
          {
            "identifier": {
              "role": {
                "value": "window"
              },
              "title": {
                "value": "Suno | AI Music"
              },
              "url": {
                "value": "https://suno.com/create",
                "excluded": true
              },
              "className": {
                "value": "Chrome_WidgetWin_1"
              },
              "controlMetaType": "Tab"
            },
            "childControls": [
              {
                "identifier": {
                  "tag": {
                    "value": "DIV"
                  },
                  "class": {
                    "value": "css-1d8szr1 elvusfj0"
                  },
                  "ancestorId": {
                    "value": "main-container"
                  },
                  "ancestorClass": {
                    "value": "css-j9om40 e9h95zo3",
                    "excluded": true
                  },
                  "isLeaf": {
                    "value": "0",
                    "excluded": true
                  },
                  "cssSelector": {
                    "value": "body>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div",
                    "excluded": true
                  },
                  "tableRow": {
                    "value": "-1",
                    "excluded": true
                  },
                  "tableCol": {
                    "value": "-1",
                    "excluded": true
                  },
                  "tabIndex": {
                    "value": "0"
                  },
                  "controlMetaType": "Web",
                  "index": {
                    "value": "1"
                  },
                  "role": {
                    "isCustom": true,
                    "value": "slider",
                    "operator": "equals",
                    "excluded": true
                  },
                  "aria-label": {
                    "isCustom": true,
                    "value": "Weirdness",
                    "operator": "equals",
                    "excluded": true
                  },
                  "aria-valuenow": {
                    "isCustom": true,
                    "value": "50",
                    "operator": "equals",
                    "excluded": true
                  },
                  "aria-valuemin": {
                    "isCustom": true,
                    "value": "0",
                    "operator": "equals",
                    "excluded": true
                  },
                  "aria-valuemax": {
                    "isCustom": true,
                    "value": "100",
                    "operator": "equals",
                    "excluded": true
                  },
                  "aria-disabled": {
                    "isCustom": true,
                    "value": "false",
                    "operator": "equals",
                    "excluded": true
                  }
                }
              }
            ]
          }
        ]
      }
    },
    {
      "id": "6224b742-57e1-457f-8e91-a0503324d047",
      "name": "slider_style_influence",
      "filePath": "5f1ab752-b235-44ce-8a39-26b7ac6cee86.jpg",
      "content": {
        "automationType": "Chrome",
        "processName": {
          "value": "chrome"
        },
        "filePath": {
          "value": "chrome.exe"
        },
        "version": {
          "value": "1.3"
        },
        "childControls": [
          {
            "identifier": {
              "role": {
                "value": "window"
              },
              "title": {
                "value": "Suno | AI Music"
              },
              "url": {
                "value": "https://suno.com/create",
                "excluded": true
              },
              "className": {
                "value": "Chrome_WidgetWin_1"
              },
              "controlMetaType": "Tab"
            },
            "childControls": [
              {
                "identifier": {
                  "tag": {
                    "value": "DIV"
                  },
                  "class": {
                    "value": "css-1d8szr1 elvusfj0"
                  },
                  "ancestorId": {
                    "value": "main-container"
                  },
                  "ancestorClass": {
                    "value": "css-j9om40 e9h95zo3",
                    "excluded": true
                  },
                  "isLeaf": {
                    "value": "0",
                    "excluded": true
                  },
                  "cssSelector": {
                    "value": "body>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div",
                    "excluded": true
                  },
                  "tableRow": {
                    "value": "-1",
                    "excluded": true
                  },
                  "tableCol": {
                    "value": "-1",
                    "excluded": true
                  },
                  "tabIndex": {
                    "value": "0"
                  },
                  "controlMetaType": "Web",
                  "index": {
                    "value": "2"
                  },
                  "role": {
                    "isCustom": true,
                    "value": "slider",
                    "operator": "equals",
                    "excluded": true
                  },
                  "aria-label": {
                    "isCustom": true,
                    "value": "Style Influence",
                    "operator": "equals",
                    "excluded": true
                  },
                  "aria-valuenow": {
                    "isCustom": true,
                    "value": "50",
                    "operator": "equals",
                    "excluded": true
                  },
                  "aria-valuemin": {
                    "isCustom": true,
                    "value": "0",
                    "operator": "equals",
                    "excluded": true
                  },
                  "aria-valuemax": {
                    "isCustom": true,
                    "value": "100",
                    "operator": "equals",
                    "excluded": true
                  },
                  "aria-disabled": {
                    "isCustom": true,
                    "value": "false",
                    "operator": "equals",
                    "excluded": true
                  }
                }
              }
            ]
          }
        ]
      }
    },
    {
      "id": "07de4601-9045-4bf5-b91c-7f4f5394f871",
      "name": "span_persona",
      "filePath": "ec296778-e7ef-4f8d-9723-d1153a31352c.jpg",
      "content": {
        "automationType": "Chrome",
        "processName": {
          "value": "chrome"
        },
        "filePath": {
          "value": "chrome.exe"
        },
        "version": {
          "value": "1.3"
        },
        "childControls": [
          {
            "identifier": {
              "role": {
                "value": "window"
              },
              "title": {
                "value": "Suno | AI Music"
              },
              "url": {
                "value": "https://suno.com/create",
                "excluded": true
              },
              "className": {
                "value": "Chrome_WidgetWin_1"
              },
              "controlMetaType": "Tab"
            },
            "childControls": [
              {
                "identifier": {
                  "tag": {
                    "value": "SPAN"
                  },
                  "class": {
                    "value": "relative flex flex-row items-center justify-center gap-2",
                    "excluded": true
                  },
                  "ancestorId": {
                    "value": "main-container"
                  },
                  "ancestorClass": {
                    "value": "relative inline-block font-sans font-medium text-center before:absolute before:inset-0 before:pointer-events-none before:rounded-[inherit] before:border before:border-transparent before:bg-transparent after:absolute after:inset-0 after:pointer-events-none after:rounded-[inherit] after:bg-transparent after:opacity-0 enabled:hover:after:opacity-100 transition duration-75 before:transition before:duration-75 after:transition after:duration-75 select-none cursor-pointer rounded-0 text-foreground-primary enabled:hover:before:bg-overlay-on-primary disabled:after:bg-background-primary disabled:after:opacity-50 h-full bg-background-fog-thin p-3 text-[14px] rounded-none",
                    "excluded": true
                  },
                  "isLeaf": {
                    "value": "0",
                    "excluded": true
                  },
                  "cssSelector": {
                    "value": "body>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>button>span",
                    "excluded": true
                  },
                  "sInfo": {
                    "value": "Persona"
                  },
                  "tableRow": {
                    "value": "-1",
                    "excluded": true
                  },
                  "tableCol": {
                    "value": "-1",
                    "excluded": true
                  },
                  "controlMetaType": "Web",
                  "index": {
                    "value": "1",
                    "excluded": true
                  }
                }
              }
            ]
          }
        ]
      }
    },
    {
      "id": "6bf74b65-5984-4cf7-8bec-938e1406a805",
      "name": "button_add_persona",
      "filePath": "190787ed-82e0-4ffc-87c5-2bd12c014928.jpg",
      "content": {
        "automationType": "Chrome",
        "processName": {
          "value": "chrome"
        },
        "filePath": {
          "value": "chrome.exe"
        },
        "version": {
          "value": "1.3"
        },
        "childControls": [
          {
            "identifier": {
              "role": {
                "value": "window"
              },
              "title": {
                "value": "Suno | AI Music"
              },
              "url": {
                "value": "https://suno.com/create",
                "excluded": true
              },
              "className": {
                "value": "Chrome_WidgetWin_1"
              },
              "controlMetaType": "Tab"
            },
            "childControls": [
              {
                "identifier": {
                  "tag": {
                    "value": "BUTTON"
                  },
                  "class": {
                    "value": "relative inline-block font-sans font-medium text-center before:absolute before:inset-0 before:pointer-events-none before:rounded-[inherit] before:border before:border-transparent before:bg-transparent after:absolute after:inset-0 after:pointer-events-none after:rounded-[inherit] after:bg-transparent after:opacity-0 enabled:hover:after:opacity-100 transition duration-75 before:transition before:duration-75 after:transition after:duration-75 select-none cursor-pointer rounded-0 text-foreground-primary enabled:hover:before:bg-overlay-on-primary disabled:after:bg-background-primary disabled:after:opacity-50 h-full bg-background-fog-thin p-3 text-[14px] rounded-none",
                    "excluded": true
                  },
                  "type": {
                    "value": "button"
                  },
                  "ancestorId": {
                    "value": "main-container"
                  },
                  "ancestorClass": {
                    "value": "css-bxskch eh3it1a0",
                    "excluded": true
                  },
                  "isLeaf": {
                    "value": "0",
                    "excluded": true
                  },
                  "cssSelector": {
                    "value": "body>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>button",
                    "excluded": true
                  },
                  "sInfo": {
                    "value": "Persona"
                  },
                  "tableRow": {
                    "value": "-1",
                    "excluded": true
                  },
                  "tableCol": {
                    "value": "-1",
                    "excluded": true
                  },
                  "controlMetaType": "Web",
                  "index": {
                    "value": "1",
                    "excluded": true
                  },
                  "aria-label": {
                    "isCustom": true,
                    "value": "Add Persona",
                    "operator": "equals",
                    "excluded": true
                  },
                  "aria-describedby": {
                    "isCustom": true,
                    "value": "tooltip-Â«r44Â»",
                    "operator": "equals",
                    "excluded": true
                  }
                }
              }
            ]
          }
        ]
      }
    },
    {
      "id": "6e813c02-fb5a-4573-b8d4-ddcc4d97b80c",
      "name": "input_search_in_persona_modal",
      "filePath": "43052891-2663-4603-9dd1-6fdbf56b3a7b.jpg",
      "content": {
        "automationType": "Chrome",
        "processName": {
          "value": "chrome"
        },
        "filePath": {
          "value": "chrome.exe"
        },
        "version": {
          "value": "1.3"
        },
        "childControls": [
          {
            "identifier": {
              "role": {
                "value": "window"
              },
              "title": {
                "value": "Suno | AI Music"
              },
              "url": {
                "value": "https://suno.com/create",
                "excluded": true
              },
              "className": {
                "value": "Chrome_WidgetWin_1"
              },
              "controlMetaType": "Tab"
            },
            "childControls": [
              {
                "identifier": {
                  "tag": {
                    "value": "INPUT"
                  },
                  "class": {
                    "value": "px-4 outline-none h-12 w-full rounded-full border-0 bg-background-tertiary pr-4 pl-12",
                    "excluded": true
                  },
                  "ancestorId": {
                    "value": "chakra-modal--body-Â«rb4Â»"
                  },
                  "ancestorClass": {
                    "value": "relative flex w-full items-center overflow-x-hidden! outline-none",
                    "excluded": true
                  },
                  "isLeaf": {
                    "value": "1",
                    "excluded": true
                  },
                  "cssSelector": {
                    "value": "body>div>div>div>section>div>div>div>div>div>div>input",
                    "excluded": true
                  },
                  "tableRow": {
                    "value": "-1",
                    "excluded": true
                  },
                  "tableCol": {
                    "value": "-1",
                    "excluded": true
                  },
                  "controlMetaType": "Web",
                  "index": {
                    "value": "1",
                    "excluded": true
                  },
                  "data-slot": {
                    "isCustom": true,
                    "value": "input",
                    "operator": "equals",
                    "excluded": true
                  },
                  "placeholder": {
                    "isCustom": true,
                    "value": "Search",
                    "operator": "equals",
                    "excluded": true
                  }
                }
              }
            ]
          }
        ]
      }
    },
    {
      "id": "e26588bc-2f7d-4719-a9d5-cf4c7aec6568",
      "name": "persona_fist_in_the_list",
      "filePath": "5b12c330-929c-4d5e-b027-e0c048c2e7d6.jpg",
      "content": {
        "automationType": "Chrome",
        "processName": {
          "value": "chrome"
        },
        "filePath": {
          "value": "chrome.exe"
        },
        "version": {
          "value": "1.3"
        },
        "childControls": [
          {
            "identifier": {
              "role": {
                "value": "window"
              },
              "title": {
                "value": "Suno | AI Music"
              },
              "url": {
                "value": "https://suno.com/create",
                "excluded": true
              },
              "className": {
                "value": "Chrome_WidgetWin_1"
              },
              "controlMetaType": "Tab"
            },
            "childControls": [
              {
                "identifier": {
                  "tag": {
                    "value": "DIV"
                  },
                  "class": {
                    "value": "group flex w-full cursor-pointer items-center gap-4 rounded-lg p*"
                  },
                  "ancestorId": {
                    "value": "chakra-modal--body-Â«rb4Â»"
                  },
                  "ancestorClass": {
                    "value": "pb-2",
                    "excluded": true
                  },
                  "isLeaf": {
                    "value": "0",
                    "excluded": true
                  },
                  "cssSelector": {
                    "value": "body>div>div>div>section>div>div>div>div>div>div>div",
                    "excluded": true
                  },
                  "tableRow": {
                    "value": "-1",
                    "excluded": true
                  },
                  "tableCol": {
                    "value": "-1",
                    "excluded": true
                  },
                  "controlMetaType": "Web",
                  "index": {
                    "value": "2"
                  }
                }
              }
            ]
          }
        ]
      }
    },
    {
      "id": "ee4a62d4-014c-4b22-aaa7-eff20b930512",
      "name": "button_close_persona_modal",
      "filePath": "8921a709-5ed8-45ed-b416-d6dcfe848a74.jpg",
      "content": {
        "automationType": "Chrome",
        "processName": {
          "value": "chrome"
        },
        "filePath": {
          "value": "chrome.exe"
        },
        "version": {
          "value": "1.3"
        },
        "childControls": [
          {
            "identifier": {
              "role": {
                "value": "window"
              },
              "title": {
                "value": "Suno | AI Music"
              },
              "url": {
                "value": "https://suno.com/create",
                "excluded": true
              },
              "className": {
                "value": "Chrome_WidgetWin_1"
              },
              "controlMetaType": "Tab"
            },
            "childControls": [
              {
                "identifier": {
                  "tag": {
                    "value": "BUTTON"
                  },
                  "class": {
                    "value": "relative inline-block font-sans font-medium text-center before:absolute before:inset-0 before:pointer-events-none before:rounded-[inherit] before:border before:border-transparent before:bg-transparent after:absolute after:inset-0 after:pointer-events-none after:rounded-[inherit] after:bg-transparent after:opacity-0 enabled:hover:after:opacity-100 transition duration-75 before:transition before:duration-75 after:transition after:duration-75 select-none cursor-pointer text-[17px] leading-[24px] aspect-square p-2.5 text-foreground-primary bg-background-tertiary enabled:hover:before:bg-overlay-on-primary disabled:after:bg-background-primary disabled:after:opacity-50 rounded-full",
                    "excluded": true
                  },
                  "type": {
                    "value": "button"
                  },
                  "ancestorId": {
                    "value": "chakra-modal-Â«rb4Â»"
                  },
                  "ancestorClass": {
                    "value": "absolute top-4 right-4 z-[9999]",
                    "excluded": true
                  },
                  "isLeaf": {
                    "value": "0",
                    "excluded": true
                  },
                  "cssSelector": {
                    "value": "body>div>div>div>section>div>button",
                    "excluded": true
                  },
                  "tableRow": {
                    "value": "-1",
                    "excluded": true
                  },
                  "tableCol": {
                    "value": "-1",
                    "excluded": true
                  },
                  "controlMetaType": "Web",
                  "index": {
                    "value": "1",
                    "excluded": true
                  },
                  "aria-label": {
                    "isCustom": true,
                    "value": "Close",
                    "operator": "equals",
                    "excluded": true
                  }
                }
              }
            ]
          }
        ]
      }
    },
    {
      "id": "a160e55b-92e8-4e3d-81b0-9149ca3415c7",
      "name": "button_simple",
      "filePath": "60980253-8dc8-4433-a944-12630bceb743.jpg",
      "content": {
        "automationType": "Chrome",
        "processName": {
          "value": "chrome"
        },
        "filePath": {
          "value": "chrome.exe"
        },
        "version": {
          "value": "1.3"
        },
        "childControls": [
          {
            "identifier": {
              "role": {
                "value": "window"
              },
              "title": {
                "value": "Suno | AI Music"
              },
              "url": {
                "value": "https://suno.com/create",
                "excluded": true
              },
              "className": {
                "value": "Chrome_WidgetWin_1"
              },
              "controlMetaType": "Tab"
            },
            "childControls": [
              {
                "identifier": {
                  "tag": {
                    "value": "BUTTON"
                  },
                  "class": {
                    "value": "css-1tqwquh edu83vi0",
                    "excluded": true
                  },
                  "ancestorId": {
                    "value": "main-container"
                  },
                  "ancestorClass": {
                    "value": "flex flex-1 items-center justify-stretch gap-0",
                    "excluded": true
                  },
                  "isLeaf": {
                    "value": "0",
                    "excluded": true
                  },
                  "cssSelector": {
                    "value": "body>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>span>span>button",
                    "excluded": true
                  },
                  "sInfo": {
                    "value": "Simple"
                  },
                  "tableRow": {
                    "value": "-1",
                    "excluded": true
                  },
                  "tableCol": {
                    "value": "-1",
                    "excluded": true
                  },
                  "controlMetaType": "Web",
                  "index": {
                    "value": "1",
                    "excluded": true
                  }
                }
              }
            ]
          }
        ]
      }
    },
    {
      "id": "2dfad246-e9f1-4490-9032-72a975b75c97",
      "name": "span_simple",
      "filePath": "4c04fa49-f9a6-4f65-8cec-edd4cf0e4c7f.jpg",
      "content": {
        "automationType": "Chrome",
        "processName": {
          "value": "chrome"
        },
        "filePath": {
          "value": "chrome.exe"
        },
        "version": {
          "value": "1.3"
        },
        "childControls": [
          {
            "identifier": {
              "role": {
                "value": "window"
              },
              "title": {
                "value": "Suno | AI Music"
              },
              "url": {
                "value": "https://suno.com/create",
                "excluded": true
              },
              "className": {
                "value": "Chrome_WidgetWin_1"
              },
              "controlMetaType": "Tab"
            },
            "childControls": [
              {
                "identifier": {
                  "tag": {
                    "value": "SPAN"
                  },
                  "class": {
                    "value": "css-gixt5w edu83vi2",
                    "excluded": true
                  },
                  "ancestorId": {
                    "value": "main-container"
                  },
                  "ancestorClass": {
                    "value": "active css-1tqwquh edu83vi0",
                    "excluded": true
                  },
                  "isLeaf": {
                    "value": "1",
                    "excluded": true
                  },
                  "cssSelector": {
                    "value": "body>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>div>span>span>button>span",
                    "excluded": true
                  },
                  "sInfo": {
                    "value": "Simple"
                  },
                  "tableRow": {
                    "value": "-1",
                    "excluded": true
                  },
                  "tableCol": {
                    "value": "-1",
                    "excluded": true
                  },
                  "controlMetaType": "Web",
                  "index": {
                    "value": "1",
                    "excluded": true
                  }
                }
              }
            ]
          }
        ]
      }
    }
  ],
  "originalName": "suno"
}
</file>

<file path=".repomixignore">
docs/*
plans/*
assets/*
dist/*
coverage/*
build/*
ios/*
android/*
tests/*
__tests__/*
__pycache__/*
node_modules/*

.opencode/*
.claude/*
.serena/*
.pnpm-store/*
.github/*
.dart_tool/*
.idea/*
.husky/*
.venv/*
</file>

<file path="AGENTS.md">
# AGENTS.md

**Audience:** All developers, AI coding agents  
**Applies to:** Entire repository  
**Scope:** General guidelines, project conventions, cross-cutting concerns  
**Last reviewed:** 2025-11-10  
**Owners:** Core team

---

## ðŸ“‚ Module-Specific Guidelines

For detailed guidance on specific parts of the codebase, see module-specific `AGENTS.md` files:

| Module | File | Key Topics |
|--------|------|-----------|
| **Core Layer** | [`src/core/AGENTS.md`](src/core/AGENTS.md) | Manager lifecycle, session patterns, queue workflows, API integration, browser automation |
| **UI Layer** | [`src/ui/AGENTS.md`](src/ui/AGENTS.md) | Panel patterns, component structure, threading model, CustomTkinter conventions |
| **Configuration** | [`config/AGENTS.md`](config/AGENTS.md) | Path constants, JSON persistence, settings precedence, style config |
| **Legacy CLI** | [`legacy_modules/AGENTS.md`](legacy_modules/AGENTS.md) | CLI interface, standalone usage, migration guide |
| **Testing** | [`tests/AGENTS.md`](tests/AGENTS.md) | Test structure, mocking patterns, fixture conventions, integration testing |

**Start here for general guidelines. Dive into module files for specific patterns.**

---

## Project Structure & Module Organization
Main entry `app.py` boots the CustomTkinter UI layered through `src/ui -> core -> models -> utils`; keep imports moving only downward through that stack. `config/settings.py` centralizes paths such as `PROFILES_DIR`, `DOWNLOADS_DIR`, and JSON file handles reused by every manager. Runtime data persists under `data/` (accounts/history), user Chrome profiles under `profiles/`, and diagnostic logs under `logs/`. Legacy CLI flows remain in `legacy_modules/` and must stay functional. Project briefs, system context, and task histories live in `memory-bank/`; update them whenever behavior or scope shifts.

## Build, Test, and Development Commands
Create an isolated environment and install dependencies:
```
python -m venv .venv
.\.venv\Scripts\activate
pip install -r requirements.txt
```
Launch the GUI with `python app.py`; use `python legacy_modules/suno_batch_download.py --help` when validating the standalone downloader. Lint or sanity-check modules as needed (for example, `python -m compileall src`) and always run `pytest` (or `python -m pytest tests`) before committing. Log output is written to `logs/app_*.log`, so tail those files while diagnosing automation issues.

## Coding Style & Naming Conventions
Target Python >=3.10, PEP 8 indentation (4 spaces), exhaustive type hints, and module docstrings. Keep UI classes `PascalCase`, helper functions `snake_case`, and avoid `print()` in favor of the shared `Logger` from `src/utils/logger.py`. Never import across layers out of order, and do not duplicate path constants - import them from `config.settings`. XML prompt templates live in `src/prompt/`; keep filenames lowercase with hyphens.

## Testing Guidelines
Use `pytest` with files named `tests/test_<module>.py`. Stub Selenium, file I/O, and network calls via `unittest.mock` so tests stay deterministic. Prioritize coverage for account persistence, session token retrieval, and download orchestration. When a panel or manager gains a new branch, introduce at least one regression test exercising it and document fixtures under `tests/fixtures/` if they grow complex.

## Commit & Pull Request Guidelines
Follow `type(scope): summary` commits (example: `feat(core): add batch retry caps`). Every functional change should update `CHANGELOG.md` and bump the relevant entry inside `versions.json`, mirroring the module touched. PRs must describe motivation, testing evidence (`pytest`, `python app.py` smoke), linked issue or task IDs, and include screenshots or logs for UI-visible work. Keep branches focused and reference any Memory Bank files you amend.

## Agent & Documentation Workflow
Before editing, review `.github/copilot-instructions.md`, `.github/instructions/*.md`, and the latest context stored in `memory-bank/` (especially `activeContext.md` and `tasks/_index.md`). Document significant discoveries back into the Memory Bank so future agents start informed. When touching automation selectors or prompts, sync notes under `docs/` or `.github/prompts/` so downstream tools stay consistent.
</file>

<file path="app.py">
"""
Suno Account Manager - Main Entry Point
Modern UI application for managing Suno accounts and downloading songs
"""
import sys
from pathlib import Path

# Add parent directory to path
sys.path.insert(0, str(Path(__file__).parent))

from src.ui import run_app

if __name__ == "__main__":
    run_app()
</file>

<file path="CLAUDE.md">
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Role & Responsibilities

Your role is to analyze user requirements, delegate tasks to appropriate sub-agents, and ensure cohesive delivery of features that meet specifications and architectural standards.

# Guidelines

## Top-Level Rules
- **Think exclusively in English** but **respond in Vietnamese**
- Execute multiple independent processes **concurrently, not sequentially**
- Always use **Context7 MCP** to retrieve latest library information

## Programming Rules
- Avoid hard-coding values unless absolutely necessary
- Do not use `any` or `unknown` types in TypeScript
- You must not use TypeScript `class` unless absolutely necessary

## Workflows

- Primary workflow: `./.claude/workflows/primary-workflow.md`
- Development rules: `./.claude/workflows/development-rules.md`
- Orchestration protocols: `./.claude/workflows/orchestration-protocol.md`
- Documentation management: `./.claude/workflows/documentation-management.md`
- And other workflows: `./.claude/workflows/*`

**IMPORTANT:** Analyze the skills catalog and activate the skills that are needed for the task during the process.
**IMPORTANT:** You must follow strictly the development rules in `./.claude/workflows/development-rules.md` file.
**IMPORTANT:** Before you plan or proceed any implementation, always read the `./README.md` file first to get context.
**IMPORTANT:** Sacrifice grammar for the sake of concision when writing reports.
**IMPORTANT:** In reports, list any unresolved questions at the end, if any.
**IMPORTANT**: For `YYMMDD` dates, use `bash -c 'date +%y%m%d'` instead of model knowledge. Else, if using PowerShell (Windows), replace command with `Get-Date -UFormat "%y%m%d"`.

## Documentation Management

We keep all important docs in `./docs` folder and keep updating them, structure like below:

```
./docs
â”œâ”€â”€ project-overview-pdr.md
â”œâ”€â”€ code-standards.md
â”œâ”€â”€ codebase-summary.md
â”œâ”€â”€ design-guidelines.md
â”œâ”€â”€ deployment-guide.md
â”œâ”€â”€ system-architecture.md
â””â”€â”€ project-roadmap.md
```

**IMPORTANT:** *MUST READ* and *MUST COMPLY* all *INSTRUCTIONS* in project `./CLAUDE.md`, especially *WORKFLOWS* section is *CRITICALLY IMPORTANT*, this rule is *MANDATORY. NON-NEGOTIABLE. NO EXCEPTIONS. MUST REMEMBER AT ALL TIMES!!!*
</file>

<file path="config/__init__.py">
"""
Configuration package
"""
</file>

<file path="config/AGENTS.md">
# AGENTS.md

**Audience:** AI coding agents, all developers  
**Applies to:** `config/**/*.py`  
**Scope:** Configuration hierarchy, path constants, settings precedence  
**Last reviewed:** 2025-11-10  
**Owners:** Core team

---

## Configuration Hierarchy

### File Structure

```
config/
â”œâ”€â”€ __init__.py              # Empty (package marker)
â”œâ”€â”€ settings.py              # Central constants (paths, URLs, app settings)
â”œâ”€â”€ style_config.py          # UI theme, colors, fonts
â””â”€â”€ suno_selectors_from_clicknium.py  # CSS selectors for automation
```

**Rule**: Never duplicate constants. Import from `config.settings` or `config.style_config`.

---

## Path Constants

### Directory Paths

**Source of truth**: `config/settings.py`

```python
from pathlib import Path

# Base directories
BASE_DIR = Path(__file__).parent.parent  # Project root
PROFILES_DIR = BASE_DIR / "profiles"
DOWNLOADS_DIR = BASE_DIR / "downloads"
DATA_DIR = BASE_DIR / "data"

# Data files
ACCOUNTS_FILE = DATA_DIR / "suno_accounts.json"
HISTORY_FILE = DATA_DIR / "download_history.json"
QUEUE_STATE_FILE = DATA_DIR / "queue_state.json"
SONG_CREATION_HISTORY_FILE = DATA_DIR / "song_creation_history.json"
```

**Usage everywhere**:
```python
# âœ… CORRECT: Import from config
from config.settings import PROFILES_DIR, ACCOUNTS_FILE

def load_profile(account_name: str):
    profile_path = PROFILES_DIR / account_name
    # ...

# âŒ WRONG: Hardcode paths
def load_profile(account_name: str):
    profile_path = Path("profiles") / account_name  # NO!
```

**Why?**
- Single source of truth
- Easy to change (edit one file)
- Testable (mock `settings.PROFILES_DIR`)

---

## JSON Persistence

### Name-as-Key Pattern

**Critical**: Account name is JSON KEY, not in value.

```python
# suno_accounts.json structure
{
  "account_name": {  # â† Name is KEY
    "email": "user@example.com",
    "created_at": "2025-11-09T10:00:00",
    "last_used": "2025-11-09T15:30:00",
    "status": "active"
    # NO "name" field here!
  }
}
```

**Loading pattern** (inject key into model):
```python
from config.settings import ACCOUNTS_FILE
from src.utils.helpers import load_json

data = load_json(ACCOUNTS_FILE, {})
accounts = {}
for name, info in data.items():
    info['name'] = name  # ADD name from key
    accounts[name] = Account.from_dict(info)
```

**Saving pattern** (remove key from value):
```python
data = {}
for name, account in accounts.items():
    account_dict = account.to_dict()
    account_dict.pop('name', None)  # REMOVE name (it's the key)
    data[name] = account_dict

save_json(ACCOUNTS_FILE, data)
```

**Why this pattern?**
- Prevents duplication (name stored once)
- Natural indexing (fast lookup by name)
- Consistency across all JSON files

**Used in**:
- `suno_accounts.json` (account name as key)
- `download_history.json` (account name as key)
- `queue_state.json` (queues array, not keyed)
- `song_creation_history.json` (array, not keyed)

---

## Settings Precedence

### Application Settings

```python
# config/settings.py

# Application metadata
APP_NAME = "Suno Account Manager"
APP_VERSION = "2.0.0"
APP_WIDTH = 1400
APP_HEIGHT = 850

# UI Theme
THEME = "dark-blue"
APPEARANCE_MODE = "dark"  # "dark" | "light" | "system"
```

**Runtime override** (not recommended):
```python
# Only in tests or special cases
import config.settings as settings
settings.APP_WIDTH = 1600  # Overrides default
```

### Suno API Settings

```python
# URLs (never change without verification)
SUNO_URL = "https://suno.com"
SUNO_API_URL = "https://studio-api.prod.suno.com/api"

# Chrome options (anti-detection)
CHROME_OPTIONS = [
    '--disable-blink-features=AutomationControlled',
    '--no-sandbox',
    '--disable-gpu',
    '--disable-dev-shm-usage'
]

# Download settings
DEFAULT_DOWNLOAD_LIMIT = 10
MAX_CONCURRENT_DOWNLOADS = 3
DOWNLOAD_TIMEOUT = 300  # seconds
RETRY_ATTEMPTS = 3
DELAY_BETWEEN_DOWNLOADS = 2  # seconds
```

**Usage in managers**:
```python
from config.settings import SUNO_API_URL, RETRY_ATTEMPTS, DOWNLOAD_TIMEOUT

class DownloadManager:
    def fetch_clips(self, token: str):
        url = f"{SUNO_API_URL}/feed/v2"
        for attempt in range(RETRY_ATTEMPTS):
            response = requests.get(url, timeout=DOWNLOAD_TIMEOUT)
            # ...
```

---

## Style Configuration

### UI Theme & Colors

**Source**: `config/style_config.py`

```python
# Colors
COLORS = {
    "primary": "#1f538d",
    "primary_hover": "#164270",
    "success": "#2ecc71",
    "warning": "#f39c12",
    "danger": "#e74c3c",
    "info": "#3498db",
    "dark": "#2c3e50",
    "light": "#ecf0f1"
}

# Fonts
FONTS = {
    "title": ("Arial", 20, "bold"),
    "heading": ("Arial", 16, "bold"),
    "body": ("Arial", 12),
    "button": ("Arial", 12, "bold"),
    "code": ("Courier New", 10)
}

# Responsive design
WINDOW_SIZES = {
    "small": (1200, 700),
    "medium": (1400, 850),  # Default
    "large": (1600, 1000)
}
```

**Usage in UI**:
```python
from config.style_config import COLORS, FONTS

class YourPanel(ctk.CTkFrame):
    def _create_widgets(self):
        self.title_label = ctk.CTkLabel(
            self,
            text="Panel Title",
            font=FONTS["title"],
            text_color=COLORS["primary"]
        )
        
        self.submit_button = ctk.CTkButton(
            self,
            text="Submit",
            fg_color=COLORS["primary"],
            hover_color=COLORS["primary_hover"],
            font=FONTS["button"]
        )
```

---

## Suno Selectors

### CSS Selectors for Automation

**Source**: `config/suno_selectors_from_clicknium.py`

Contains CSS selectors extracted from Suno.com for browser automation.

```python
class SunoSelectors:
    # Form inputs
    LYRICS_TEXTAREA = "textarea[placeholder*='lyrics']"
    STYLES_INPUT = "input[placeholder*='style']"
    TITLE_INPUT = "input[placeholder*='title']"
    
    # Buttons
    CREATE_BUTTON = "button:has-text('Create')"
    CUSTOM_MODE_BUTTON = "button[data-mode='custom']"
    
    # Results
    SONG_CARD = "div[data-testid='song-card']"
    SONG_URL_LINK = "a[href^='/song/']"
```

**Usage in core layer**:
```python
from config.suno_selectors_from_clicknium import SunoSelectors
from selenium.webdriver.common.by import By

# Find elements
lyrics_input = driver.find_element(By.CSS_SELECTOR, SunoSelectors.LYRICS_TEXTAREA)
create_button = driver.find_element(By.CSS_SELECTOR, SunoSelectors.CREATE_BUTTON)
```

**Why centralized?**
- Suno.com updates selectors â†’ change one file
- Avoid selector duplication across modules
- Easy to maintain/test

---

## Directory Initialization

### Auto-Create Directories

`config/settings.py` ensures directories exist on import:

```python
# Ensure directories exist
PROFILES_DIR.mkdir(exist_ok=True)
DOWNLOADS_DIR.mkdir(exist_ok=True)
DATA_DIR.mkdir(exist_ok=True)
```

**Effect**: First import of `config.settings` creates directories if missing.

**Why?**
- Clean project structure on first run
- No manual setup required
- Safe (idempotent with `exist_ok=True`)

---

## Environment Variables

### Not Used (Yet)

Current design: All config in Python files.

**Future consideration** (v3.0+):
```python
# config/settings.py (hypothetical)
import os
from pathlib import Path

# Allow override via env vars
BASE_DIR = Path(os.getenv("SUNO_BASE_DIR", Path(__file__).parent.parent))
SUNO_API_URL = os.getenv("SUNO_API_URL", "https://studio-api.prod.suno.com/api")
```

**Why not now?**
- Simple Python config sufficient for single-machine desktop app
- No deployment environments (dev/staging/prod)
- User can edit `settings.py` directly

**When to add**:
- Multi-user deployments
- Docker containerization
- CI/CD pipelines

---

## Configuration Testing

### Mock Config in Tests

```python
from unittest.mock import patch
import pytest

@patch('config.settings.PROFILES_DIR', '/tmp/test_profiles')
@patch('config.settings.ACCOUNTS_FILE', '/tmp/test_accounts.json')
def test_account_manager():
    """
    Tests use temp directories to avoid touching real data.
    """
    manager = AccountManager()
    # Test with mocked paths...
```

### Fixture for Temp Paths

```python
# tests/fixtures/temp_config.py
import pytest
from pathlib import Path
import tempfile

@pytest.fixture
def temp_config(monkeypatch):
    """Provides temporary paths for testing"""
    with tempfile.TemporaryDirectory() as tmpdir:
        tmp_path = Path(tmpdir)
        
        monkeypatch.setattr('config.settings.BASE_DIR', tmp_path)
        monkeypatch.setattr('config.settings.PROFILES_DIR', tmp_path / 'profiles')
        monkeypatch.setattr('config.settings.DATA_DIR', tmp_path / 'data')
        monkeypatch.setattr('config.settings.ACCOUNTS_FILE', tmp_path / 'data' / 'accounts.json')
        
        yield tmp_path
```

---

## Common Pitfalls

### âŒ Hardcoded Paths

```python
# WRONG: Hardcoded path
def load_accounts():
    with open("data/suno_accounts.json") as f:
        return json.load(f)
```

```python
# CORRECT: Import from config
from config.settings import ACCOUNTS_FILE
from src.utils.helpers import load_json

def load_accounts():
    return load_json(ACCOUNTS_FILE, {})
```

### âŒ Duplicate Constants

```python
# WRONG: Defining in multiple files
# download_manager.py
SUNO_API_URL = "https://studio-api.prod.suno.com/api"

# account_manager.py
SUNO_API_URL = "https://studio-api.prod.suno.com/api"  # Duplication!
```

```python
# CORRECT: Import from config
from config.settings import SUNO_API_URL
```

### âŒ Relative Path Assumptions

```python
# WRONG: Assumes current directory
profile_path = Path("profiles") / account_name  # Breaks if run from subdirectory
```

```python
# CORRECT: Use BASE_DIR
from config.settings import PROFILES_DIR
profile_path = PROFILES_DIR / account_name  # Always correct
```

---

## Entry Points

| File | Purpose | Key Exports |
|------|---------|-------------|
| `settings.py` | App config, paths, API URLs | `BASE_DIR`, `PROFILES_DIR`, `DOWNLOADS_DIR`, `DATA_DIR`, `ACCOUNTS_FILE`, `SUNO_URL`, `SUNO_API_URL`, `CHROME_OPTIONS`, download settings |
| `style_config.py` | UI theme, colors, fonts | `COLORS`, `FONTS`, `WINDOW_SIZES` |
| `suno_selectors_from_clicknium.py` | CSS selectors | `SunoSelectors` class |

---

## Cross-References

- **Usage in Core**: See `src/core/AGENTS.md#session-patterns` for profile path usage
- **Usage in UI**: See `src/ui/AGENTS.md#customtkinter-conventions` for style config usage
- **JSON patterns**: See `src/core/AGENTS.md#data-models` for name-as-key pattern
- **Testing**: See `tests/AGENTS.md#fixture-conventions` for config mocking

---

**Questions?** Check root `AGENTS.md` for general project conventions.
</file>

<file path="config/settings.py">
"""
Application Settings and Configuration
"""
import os
from pathlib import Path

# Base directories
BASE_DIR = Path(__file__).parent.parent
PROFILES_DIR = BASE_DIR / "profiles"
DOWNLOADS_DIR = BASE_DIR / "downloads"
DATA_DIR = BASE_DIR / "data"

# Data files
ACCOUNTS_FILE = DATA_DIR / "suno_accounts.json"
HISTORY_FILE = DATA_DIR / "download_history.json"
SETTINGS_FILE = DATA_DIR / "settings.json"
QUEUE_STATE_FILE = DATA_DIR / "queue_state.json"
SONG_CREATION_HISTORY_FILE = DATA_DIR / "song_creation_history.json"

# Ensure directories exist
PROFILES_DIR.mkdir(exist_ok=True)
DOWNLOADS_DIR.mkdir(exist_ok=True)
DATA_DIR.mkdir(exist_ok=True)

# Application settings
APP_NAME = "Suno Account Manager"
APP_VERSION = "2.0.0"
APP_WIDTH = 1400
APP_HEIGHT = 850

# UI Theme
THEME = "dark-blue"
APPEARANCE_MODE = "dark"  # "dark", "light", "system"

# Colors
COLORS = {
    "primary": "#1f538d",
    "success": "#2ecc71",
    "warning": "#f39c12",
    "danger": "#e74c3c",
    "info": "#3498db",
    "dark": "#2c3e50",
    "light": "#ecf0f1"
}

# Suno API
SUNO_URL = "https://suno.com"
SUNO_API_URL = "https://studio-api.prod.suno.com/api"

# Chrome options
CHROME_OPTIONS = [
    '--disable-blink-features=AutomationControlled',
    '--no-sandbox',
    '--disable-gpu',
    '--disable-dev-shm-usage'
]

# Download settings
DEFAULT_DOWNLOAD_LIMIT = 10
MAX_CONCURRENT_DOWNLOADS = 3
DOWNLOAD_TIMEOUT = 300  # seconds
RETRY_ATTEMPTS = 3
DELAY_BETWEEN_DOWNLOADS = 2  # seconds

# Session settings
SESSION_TOKEN_EXPIRY = 3600 * 24  # 24 hours
AUTO_REFRESH_SESSION = True
</file>

<file path="config/style_config.py">
"""
Global Style Configuration for CustomTkinter UI
Supports:
- Responsive compact mode for small screens (<1400px)
- Theme presets: dark / contrast-high
"""

import customtkinter as ctk

# ===============================
# ðŸ”¹ COLOR PRESETS
# ===============================

THEMES = {
    "dark": {
        "BG": "#1E1E1E",
        "FRAME": "#2A2A2A",
        "PRIMARY": "#0078D7",
        "ACCENT": "#00BFFF",
        "DANGER": "#E81123",
        "TEXT": "white",
        "TEXT_MUTED": "gray70"
    },
    "contrast-high": {
        "BG": "#000000",
        "FRAME": "#0D0D0D",
        "PRIMARY": "#00FFFF",
        "ACCENT": "#FFFF00",
        "DANGER": "#FF3333",
        "TEXT": "#FFFFFF",
        "TEXT_MUTED": "#CCCCCC"
    }
}

# ===============================
# ðŸ”¹ FONT PRESETS
# ===============================
FONT_TITLE = ("Arial", 24, "bold")
FONT_SUBTITLE = ("Arial", 18, "bold")
FONT_LABEL = ("Arial", 13)
FONT_SMALL = ("Arial", 11)

# ===============================
# ðŸ”¹ SPACING
# ===============================
PADDING_SMALL = 5
PADDING_MEDIUM = 10
PADDING_LARGE = 15

# ===============================
# ðŸ”¹ GLOBAL STYLE FUNCTIONS
# ===============================
def apply_global_style(root: ctk.CTk, theme: str = "dark") -> dict:
    """
    Apply theme and base styling to the root window.
    
    Args:
        root: The root CTk window
        theme: Theme name ("dark" or "contrast-high")
    
    Returns:
        dict: Color palette for the selected theme
    """
    if theme not in THEMES:
        theme = "dark"

    ctk.set_appearance_mode("dark")
    ctk.set_default_color_theme("dark-blue")

    palette = THEMES[theme]
    root.configure(fg_color=palette["BG"])
    return palette


def detect_compact_mode(screen_width: int) -> bool:
    """
    Determine if compact layout should be activated based on screen width.
    
    Args:
        screen_width: Width of the screen in pixels
    
    Returns:
        bool: True if compact mode should be used (screen < 1400px)
    """
    return screen_width < 1400


def get_style_config(root: ctk.CTk, theme: str = "dark") -> dict:
    """
    Detect screen resolution and return comprehensive style parameters.
    
    Args:
        root: The root CTk window
        theme: Theme name ("dark" or "contrast-high")
    
    Returns:
        dict: Style configuration containing:
            - compact: bool - whether to use compact layout
            - palette: dict - color definitions
            - fonts: dict - font presets
            - padding: dict - spacing values
    """
    screen_width = root.winfo_screenwidth()
    compact = detect_compact_mode(screen_width)
    palette = apply_global_style(root, theme)

    fonts = {
        "title": FONT_SUBTITLE if compact else FONT_TITLE,
        "label": FONT_SMALL if compact else FONT_LABEL
    }

    padding = {
        "small": PADDING_SMALL if compact else PADDING_MEDIUM,
        "medium": PADDING_MEDIUM if compact else PADDING_LARGE
    }

    return {
        "compact": compact,
        "palette": palette,
        "fonts": fonts,
        "padding": padding
    }
</file>

<file path="config/suno_selectors_from_clicknium.py">
"""
Auto-generated XPath selectors from Clicknium locators
Source: .locator/suno.cnstore
Generated: 2025-11-09
"""

class SunoSelectors:
    """XPath selectors cho Suno.com táº¡o nháº¡c"""
    
    CUSTOMBUTTON = "//div[ancestor::div[contains(@class, 'active')]]"
    SPAN_CUSTOM = "//span[normalize-space(.)='Custom' and ancestor::div[contains(@class, 'active')]]"
    TEXTAREA_WRITE_SOME_LYRICS_OR_A_PROMPT_OR_LEAVE_BLANK_FOR_INSTRU = "//textarea[contains(@placeholder, 'Write some lyrics or a prompt â€” or leave blank for instrumental') and ancestor::div[contains(@class, 'relative')]]"
    TEXTAREA_INDIE_ELECTRONIC_SYNTHS_120BPM_DISTORTED = "//textarea[contains(@placeholder, 'indie, electronic, synths, 120bpm, distorted') and ancestor::div[contains(@class, 'mb-0')]]"
    INPUT_SONG_TITLE_OPTIONAL = "//input[contains(@placeholder, 'Song Title (Optional)') and ancestor::div[contains(@class, 'css-1is7h4f')]]"
    BUTTON_CREATE_SONG = "//button[@aria-label='Create song' and normalize-space(.)='Create' and @type='button' and ancestor::div[contains(@class, 'flex')]]"
    SPAN_CREATE = "//span[normalize-space(.)='Create' and ancestor::div[contains(@class, 'relative')]]"
    ADVANCEDOPTIONS = "//div[@role='button' and ancestor::div[contains(@class, 'css-1xt3ue1')]]"
    DIV_ADVANCED_OPTIONS = "//div[normalize-space(.)='Advanced Options' and ancestor::div[contains(@class, 'css-6jsm4u')]]"
    INPUT_EXCLUDE_STYLES = "//input[contains(@placeholder, 'Exclude styles') and ancestor::div[contains(@class, 'css-1jy63we')]]"
    BUTTON_MALE = "//button[normalize-space(.)='Male' and @type='button' and @data-selected='false' and ancestor::div[contains(@class, 'css-slfj3p')]]"
    BUTTON_FEMALE = "//button[normalize-space(.)='Female' and @type='button' and @data-selected='false' and ancestor::div[contains(@class, 'css-slfj3p')]]"
    BUTTON_MANUAL = "//button[normalize-space(.)='Manual' and @type='button' and @data-selected='true' and ancestor::div[contains(@class, 'css-slfj3p')]]"
    BUTTON_AUTO = "//button[normalize-space(.)='Auto' and @type='button' and @data-selected='false' and ancestor::div[contains(@class, 'css-slfj3p')]]"
    SLIDER_WEIRDNESS = "//div[@aria-label='Weirdness' and @role='slider' and ancestor::div[contains(@class, 'css-j9om40')]]"
    SLIDER_STYLE_INFLUENCE = "//div[@aria-label='Style Influence' and @role='slider' and ancestor::div[contains(@class, 'css-j9om40')]]"
    SPAN_PERSONA = "//span[normalize-space(.)='Persona' and ancestor::div[contains(@class, 'relative')]]"
    BUTTON_ADD_PERSONA = "//button[@aria-label='Add Persona' and normalize-space(.)='Persona' and @type='button' and ancestor::div[contains(@class, 'css-bxskch')]]"
    INPUT_SEARCH_IN_PERSONA_MODAL = "//input[contains(@placeholder, 'Search') and ancestor::div[contains(@class, 'relative')]]"
    PERSONA_FIST_IN_THE_LIST = "//div[ancestor::div[contains(@class, 'pb-2')]]"
    BUTTON_CLOSE_PERSONA_MODAL = "//button[@aria-label='Close' and @type='button' and ancestor::div[contains(@class, 'absolute')]]"
    BUTTON_SIMPLE = "//button[normalize-space(.)='Simple' and ancestor::div[contains(@class, 'flex')]]"
    SPAN_SIMPLE = "//span[normalize-space(.)='Simple' and ancestor::div[contains(@class, 'active')]]"


# Dictionary for dynamic access
SELECTORS = {
    "Custombutton": SunoSelectors.CUSTOMBUTTON,
    "span_custom": SunoSelectors.SPAN_CUSTOM,
    "textarea_write_some_lyrics_or_a_prompt_or_leave_blank_for_instru": SunoSelectors.TEXTAREA_WRITE_SOME_LYRICS_OR_A_PROMPT_OR_LEAVE_BLANK_FOR_INSTRU,
    "textarea_indie_electronic_synths_120bpm_distorted": SunoSelectors.TEXTAREA_INDIE_ELECTRONIC_SYNTHS_120BPM_DISTORTED,
    "input_song_title_optional": SunoSelectors.INPUT_SONG_TITLE_OPTIONAL,
    "button_create_song": SunoSelectors.BUTTON_CREATE_SONG,
    "span_create": SunoSelectors.SPAN_CREATE,
    "advancedoptions": SunoSelectors.ADVANCEDOPTIONS,
    "div_advanced_options": SunoSelectors.DIV_ADVANCED_OPTIONS,
    "input_exclude_styles": SunoSelectors.INPUT_EXCLUDE_STYLES,
    "button_male": SunoSelectors.BUTTON_MALE,
    "button_female": SunoSelectors.BUTTON_FEMALE,
    "button_manual": SunoSelectors.BUTTON_MANUAL,
    "button_auto": SunoSelectors.BUTTON_AUTO,
    "slider_weirdness": SunoSelectors.SLIDER_WEIRDNESS,
    "slider_style_influence": SunoSelectors.SLIDER_STYLE_INFLUENCE,
    "span_persona": SunoSelectors.SPAN_PERSONA,
    "button_add_persona": SunoSelectors.BUTTON_ADD_PERSONA,
    "input_search_in_persona_modal": SunoSelectors.INPUT_SEARCH_IN_PERSONA_MODAL,
    "persona_fist_in_the_list": SunoSelectors.PERSONA_FIST_IN_THE_LIST,
    "button_close_persona_modal": SunoSelectors.BUTTON_CLOSE_PERSONA_MODAL,
    "button_simple": SunoSelectors.BUTTON_SIMPLE,
    "span_simple": SunoSelectors.SPAN_SIMPLE,
}
</file>

<file path="data/README.md">
# Data Directory

ThÆ° má»¥c chá»©a cÃ¡c file dá»¯ liá»‡u runtime cá»§a á»©ng dá»¥ng.

## Files

### `suno_accounts.json` - Database tÃ i khoáº£n
**Format:**
```json
{
    "account_name": {
        "email": "user@example.com",
        "created_at": "2025-11-09 01:26:44",
        "last_used": "2025-11-09 03:56:27",
        "status": "active"
    }
}
```

**Má»¥c Ä‘Ã­ch:**
- LÆ°u danh sÃ¡ch tÃ i khoáº£n Suno
- Mapping account name â†’ metadata
- LiÃªn káº¿t vá»›i Chrome profiles trong `profiles/`

**ÄÆ°á»£c quáº£n lÃ½ bá»Ÿi:** `src/core/account_manager.py`

---

### `download_history.json` - Lá»‹ch sá»­ downloads
**Format:**
```json
{
    "account_name": {
        "downloaded_ids": ["uuid-1", "uuid-2"],
        "total_downloaded": 2,
        "last_download": "2025-11-09 02:35:10",
        "current_page": 1,
        "last_profile": "@username"
    }
}
```

**Má»¥c Ä‘Ã­ch:**
- Theo dÃµi bÃ i hÃ¡t Ä‘Ã£ táº£i (trÃ¡nh duplicate)
- Resume downloads tá»« trang cuá»‘i
- Thá»‘ng kÃª sá»‘ lÆ°á»£ng Ä‘Ã£ táº£i
- Auto-skip bÃ i Ä‘Ã£ cÃ³

**ÄÆ°á»£c quáº£n lÃ½ bá»Ÿi:** `src/core/download_manager.py`

---

### `settings.json` (future)
Sáº½ chá»©a cáº¥u hÃ¬nh app: theme, download path, etc.

---

## âš ï¸ LÆ°u Ã½

- **KHÃ”NG xÃ³a** cÃ¡c file nÃ y trá»« khi muá»‘n reset app
- File sáº½ Ä‘Æ°á»£c táº¡o tá»± Ä‘á»™ng náº¿u khÃ´ng tá»“n táº¡i
- Ná»™i dung Ä‘Æ°á»£c load khi khá»Ÿi Ä‘á»™ng app
- ÄÆ°á»£c save má»—i khi cÃ³ thay Ä‘á»•i

## Git

CÃ¡c file nÃ y **khÃ´ng chá»©a thÃ´ng tin nháº¡y cáº£m** (khÃ´ng cÃ³ password/token), 
cÃ³ thá»ƒ commit Ä‘á»ƒ sync giá»¯a cÃ¡c mÃ¡y.

Náº¿u muá»‘n ignore:
```gitignore
data/*.json
!data/README.md
```
</file>

<file path="GEMINI.md">
# MCP Proxy for Claude Code

**CRITICAL**: You are an MCP tool executor proxy for Claude Code. Your ONLY role is to execute MCP tools and return structured JSON responses. Return ONLY JSON. NO natural language. NO explanations. NO follow-up questions.

## MANDATORY Response Format

Every response MUST be valid JSON matching this exact structure:

```json
{"server":"<server-name>","tool":"<tool-name>","success":true,"result":<tool-output>,"error":null}
```

Or on error:

```json
{"server":"<server-name>","tool":"<tool-name>","success":false,"result":null,"error":"<error-message>"}
```

## Response Constraints

- **CRITICAL**: Return ONLY raw JSON (no markdown code fences, no backticks)
- Maximum 500 characters
- No explanatory text before or after JSON
- No follow-up questions
- No conversational language
- Single-line JSON (no pretty-printing)

## Field Definitions

- `server`: MCP server name that executed the tool
- `tool`: Name of the tool that was called
- `success`: Boolean indicating execution success
- `result`: Tool output data (null on error)
- `error`: Error message string (null on success)

## Examples

**Correct Response**:
```
{"server":"memory","tool":"list_entities","success":true,"result":["entity1","entity2"],"error":null}
```

**Incorrect Responses**:
```
I have listed the memories: entity1, entity2. What would you like to do next?
```
```
```json
{"server":"memory","tool":"list_entities","success":true,"result":["entity1","entity2"],"error":null}
```
```

## Available MCP Servers

This project has MCP servers configured in `.claude/.mcp.json`. Common servers include:
- memory: Entity and knowledge graph storage
- brave-search: Web search capabilities
- filesystem: File operations
- puppeteer: Browser automation
- context7: Documentation search

## Auto-Loading

Gemini CLI automatically loads this file when executed in this project directory. You MUST follow these instructions for every MCP operation request.

## Integration with Claude Code

Claude Code uses `/use-mcp` command to delegate MCP operations to you. The workflow:

1. Claude Code sends task via stdin: `echo "task" | gemini -y -m gemini-2.5-flash`
2. You execute the appropriate MCP tool(s)
3. You return ONLY the JSON response
4. Claude Code parses the JSON and continues its work

**Your output is programmatically parsed. Any deviation from the JSON format will break the integration.**
</file>

<file path="legacy_modules/__init__.py">
"""
Legacy Modules - Core modules tá»« v1.0 váº«n Ä‘ang Ä‘Æ°á»£c sá»­ dá»¥ng
"""
from .suno_auto_create import SunoMusicCreator, SunoCreateConfig
from .suno_batch_download import SunoBatchDownloader

__all__ = [
    'SunoMusicCreator',
    'SunoCreateConfig', 
    'SunoBatchDownloader'
]
</file>

<file path="legacy_modules/AGENTS.md">
# AGENTS.md

**Audience:** AI coding agents, developers maintaining CLI tools  
**Applies to:** `legacy_modules/**/*.py`  
**Scope:** CLI interface, migration path, standalone usage  
**Last reviewed:** 2025-11-10  
**Owners:** Core team

---

## CLI Interface

### Purpose

Legacy modules provide **standalone CLI tools** for batch operations without GUI:

1. `suno_batch_download.py` - Download songs from Suno profiles
2. `suno_auto_create.py` - Automated song creation from XML prompts

**Status**: âœ… Maintained for backward compatibility. Must remain functional.

**Migration Path**: GUI (`src/`) is the primary interface. Legacy CLI for advanced users and automation scripts.

---

## Standalone Usage

### Batch Download CLI

```bash
# Help
python legacy_modules/suno_batch_download.py --help

# Download from profile
python legacy_modules/suno_batch_download.py \
    --profile @username \
    --limit 50 \
    --output downloads/username

# Download from "my songs"
python legacy_modules/suno_batch_download.py \
    --me \
    --account account_name \
    --limit 100 \
    --output downloads/my_songs
```

**Key features**:
- Uses same Chrome profile system as GUI
- Same session token extraction logic
- Supports both `/profile` and `/me` endpoints
- Progress bar in terminal (using `tqdm`)

### Auto Create CLI

```bash
# Help
python legacy_modules/suno_auto_create.py --help

# Create from XML prompts
python legacy_modules/suno_auto_create.py \
    --account account_name \
    --prompts prompts/batch-1.xml \
    --batch-size 5 \
    --headless
```

**Key features**:
- Reads XML prompts (same format as GUI)
- Batch creation with configurable batch size
- Optional headless mode
- Logs to console

---

## Architecture Differences

### CLI vs GUI

| Aspect | Legacy CLI | GUI (src/) |
|--------|-----------|-----------|
| **Entry point** | Direct script execution | `app.py` â†’ `MainWindow` |
| **User interaction** | Command-line arguments | Interactive panels |
| **Progress feedback** | `tqdm` progress bar | CustomTkinter progress widgets |
| **Threading** | Synchronous (blocking) | Asynchronous (daemon threads) |
| **Session management** | Launch â†’ extract â†’ close | Launch â†’ keep open â†’ reuse |
| **Error handling** | Print to stderr, exit codes | MessageBox dialogs |

### Code Reuse

Legacy modules **duplicate some logic** from `src/core/`:

```python
# legacy_modules/suno_batch_download.py
# Has own session token extraction (similar to SessionManager)

def get_session_token(profile_name: str) -> str:
    # Similar to SessionManager.get_session_token_from_me_page()
    # but simplified for CLI
```

**Why duplication?**
- Legacy pre-dates Clean Architecture refactor
- CLI has different constraints (no UI imports)
- Maintains independence (CLI works without `src/`)

**Future**: Consider extracting common logic to `src/utils/` that both can import.

---

## Legacy Module Patterns

### Argument Parsing

Use `argparse` for CLI:

```python
import argparse

def parse_args():
    parser = argparse.ArgumentParser(
        description="Batch download songs from Suno",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument(
        '--profile',
        help='Suno profile username (e.g., @username)',
        type=str
    )
    
    parser.add_argument(
        '--me',
        action='store_true',
        help='Download from "my songs" (requires --account)'
    )
    
    parser.add_argument(
        '--account',
        help='Account name for --me mode',
        type=str
    )
    
    parser.add_argument(
        '--limit',
        help='Maximum number of songs to download (0 = all)',
        type=int,
        default=10
    )
    
    parser.add_argument(
        '--output',
        help='Output directory',
        type=str,
        default='downloads'
    )
    
    return parser.parse_args()
```

### Progress Display

Use `tqdm` for terminal progress:

```python
from tqdm import tqdm

def download_clips(clips: List[dict]):
    with tqdm(total=len(clips), desc="Downloading") as pbar:
        for clip in clips:
            # Download work...
            pbar.update(1)
            pbar.set_description(f"Downloading {clip['title']}")
```

### Logging to Console

```python
import logging

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)

logger = logging.getLogger(__name__)

# Usage
logger.info("Starting download...")
logger.error("Download failed: %s", error)
```

---

## Migration Guide

### From CLI to GUI

**User migration**:
1. Launch `python app.py`
2. Add account (uses same Chrome profile from CLI)
3. Use Download panel (same functionality as CLI)

**Advantages of GUI**:
- Visual progress tracking
- Multiple accounts management
- Queue system for batch operations
- Session reuse (no repeated logins)
- Error dialogs with recovery options

### When to Use CLI

**Use CLI when**:
- Automating with scripts (cron jobs, scheduled tasks)
- Running on headless servers (with `--headless`)
- Integrating with other tools (pipe output)
- Debugging without GUI overhead

**Use GUI when**:
- Interactive usage
- Managing multiple accounts
- Complex workflows (queue system)
- Need visual feedback

---

## Maintenance Guidelines

### Frozen API

**Rule**: Legacy CLI API is **frozen**. Do not break existing scripts.

```python
# âœ… ALLOWED: Add new optional arguments
parser.add_argument('--new-option', help='New feature', action='store_true')

# âŒ FORBIDDEN: Remove or rename required arguments
parser.add_argument('--profile-name', ...)  # Would break --profile users

# âŒ FORBIDDEN: Change default behavior
# If --limit defaulted to 10, must stay 10
```

### Bug Fixes Only

**Acceptable changes**:
- Fix crashes or data corruption
- Update selectors if Suno.com changes
- Improve error messages
- Performance optimizations

**Not acceptable**:
- New features (add to GUI instead)
- Refactoring for style (keep as-is)
- Breaking API changes

### Deprecation Process

If must deprecate:

1. **Mark deprecated** (add warning):
```python
import warnings

def old_function():
    warnings.warn(
        "old_function() is deprecated. Use new_function() instead.",
        DeprecationWarning,
        stacklevel=2
    )
    # Keep working for now
```

2. **Document in README**:
```markdown
## Deprecated Features
- `--old-flag`: Use `--new-flag` instead (removed in v3.0)
```

3. **Wait 2+ versions** before removal

---

## Testing Legacy Modules

### Manual Testing

```bash
# Smoke test download
python legacy_modules/suno_batch_download.py \
    --profile @test_user \
    --limit 1 \
    --output /tmp/test_download

# Verify output
ls -la /tmp/test_download/*.mp3

# Smoke test create
python legacy_modules/suno_auto_create.py \
    --account test_account \
    --prompts tests/fixtures/test_prompts.xml \
    --batch-size 1
```

### Automated Testing

```python
# tests/test_legacy_cli.py
import subprocess
import pytest

def test_batch_download_help():
    """Test --help works"""
    result = subprocess.run(
        ["python", "legacy_modules/suno_batch_download.py", "--help"],
        capture_output=True,
        text=True
    )
    assert result.returncode == 0
    assert "usage:" in result.stdout

def test_batch_download_invalid_args():
    """Test validation"""
    result = subprocess.run(
        ["python", "legacy_modules/suno_batch_download.py"],
        capture_output=True,
        text=True
    )
    assert result.returncode != 0
    assert "error:" in result.stderr
```

---

## Common Issues

### Chrome Profile Lock

**Problem**: CLI fails with "Chrome instance exited" if GUI has profile open.

**Solution**: Close GUI before running CLI, or use different account.

```bash
# Error
$ python legacy_modules/suno_batch_download.py --me --account my_account
Error: Chrome instance exited

# Fix: Close GUI, then retry
$ python legacy_modules/suno_batch_download.py --me --account my_account
âœ… Success
```

### Session Token Expired

**Problem**: CLI downloads fail with 401 Unauthorized.

**Solution**: Use GUI to re-login, then retry CLI.

```bash
# Error
$ python legacy_modules/suno_batch_download.py --me --account my_account
Error: 401 Unauthorized

# Fix steps:
1. python app.py
2. Go to Account panel
3. Click "ðŸ”„ Sá»­ dá»¥ng tÃ i khoáº£n" (re-login)
4. Close GUI
5. Retry CLI
```

---

## Entry Points

| File | Purpose | Key Functions |
|------|---------|--------------|
| `suno_batch_download.py` | Download CLI | `parse_args()`, `get_session_token()`, `download_clips()`, `main()` |
| `suno_auto_create.py` | Create CLI | `parse_args()`, `load_prompts()`, `create_songs()`, `main()` |
| `README.md` | Documentation | Usage examples, CLI flags |

---

## Cross-References

- **Core logic**: See `src/core/AGENTS.md#session-patterns` for session token extraction
- **Profile structure**: See `config/AGENTS.md#path-constants` for profile paths
- **XML format**: See `src/core/AGENTS.md#prompt-templates` for prompt structure
- **Testing**: See `tests/AGENTS.md#cli-testing` for test patterns

---

**Questions?** Check root `AGENTS.md` for general project guidelines.
</file>

<file path="legacy_modules/README.md">
# Legacy Modules

ThÆ° má»¥c chá»©a cÃ¡c module core tá»« v1.0 váº«n Ä‘ang Ä‘Æ°á»£c sá»­ dá»¥ng bá»Ÿi main app.

## Modules

### `suno_batch_download.py`
- **Má»¥c Ä‘Ã­ch:** Download hÃ ng loáº¡t bÃ i hÃ¡t tá»« Suno
- **ÄÆ°á»£c sá»­ dá»¥ng bá»Ÿi:**
  - `src/core/download_manager.py`
  - `src/ui/download_panel.py`
- **TÃ­nh nÄƒng:**
  - Fetch clips tá»« Suno API
  - Download MP3 vá»›i metadata
  - Pagination support
  - Auto-resume downloads

### `suno_auto_create.py`
- **Má»¥c Ä‘Ã­ch:** Tá»± Ä‘á»™ng táº¡o bÃ i hÃ¡t trÃªn Suno
- **ÄÆ°á»£c sá»­ dá»¥ng bá»Ÿi:**
  - `src/ui/create_music_panel.py`
- **TÃ­nh nÄƒng:**
  - Äiá»n form táº¡o nháº¡c tá»± Ä‘á»™ng
  - Há»— trá»£ Custom Mode
  - Batch creation vá»›i nhiá»u tabs

## Import Pattern

```python
from legacy_modules import SunoBatchDownloader
from legacy_modules import SunoMusicCreator, SunoCreateConfig
```

## TÆ°Æ¡ng lai

CÃ¡c module nÃ y sáº½ Ä‘Æ°á»£c refactor dáº§n vÃ o `src/core/` theo Clean Architecture.
Hiá»‡n táº¡i giá»¯ nguyÃªn Ä‘á»ƒ Ä‘áº£m báº£o tÃ­nh tÆ°Æ¡ng thÃ­ch.
</file>

<file path="legacy_modules/suno_auto_create.py">
"""
Suno Auto Music Creation
Tá»± Ä‘á»™ng táº¡o nháº¡c trÃªn Suno.com vá»›i Custom Mode

TÃCH Há»¢P VÃ€O UI APP (CustomTkinter GUI)
- DÃ¹ng SessionManager hiá»‡n cÃ³ Ä‘á»ƒ má»Ÿ browser vá»›i profile
- Cháº¡y tá»« menu "Táº¡o nháº¡c" trong UI
- Sá»­ dá»¥ng Chrome profile Ä‘Ã£ Ä‘Äƒng nháº­p

KIáº¾N TRÃšC:
ui/create_music_panel.py â†’ SunoMusicCreator â†’ SessionManager
"""
import time
from typing import Optional, Dict, Any, Callable
from dataclasses import dataclass
from pathlib import Path
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, NoSuchElementException

# Import tá»« project hiá»‡n cÃ³
from src.core.session_manager import SessionManager
from src.utils.logger import logger


@dataclass
class SunoCreateConfig:
    """Cáº¥u hÃ¬nh táº¡o nháº¡c Suno"""
    # BÆ°á»›c 1: Persona (optional)
    persona_name: Optional[str] = None
    
    # BÆ°á»›c 2: Ná»™i dung chÃ­nh (báº¯t buá»™c)
    lyrics: str = ""
    styles: str = ""
    title: Optional[str] = None
    
    # BÆ°á»›c 3: Advanced Options (optional)
    exclude_styles: Optional[str] = None
    vocal_gender: Optional[str] = None  # "Male" hoáº·c "Female"
    lyrics_mode: Optional[str] = None   # "Manual" hoáº·c "Auto"
    weirdness: Optional[int] = None     # 0-100
    style_influence: Optional[int] = None  # 0-100
    
    # TÃ¹y chá»n khÃ¡c
    wait_for_generation: bool = True
    timeout: int = 120  # seconds


class SunoMusicCreator:
    """
    Class tá»± Ä‘á»™ng táº¡o nháº¡c trÃªn Suno.com
    
    TÃCH Há»¢P VÃ€O UI APP:
    - DÃ¹ng SessionManager Ä‘á»ƒ má»Ÿ browser vá»›i profile
    - Cháº¡y tá»« UI panel (CreateMusicPanel)
    - Callback Ä‘á»ƒ cáº­p nháº­t progress trong GUI
    
    Workflow:
    1. UI gá»i create_song() vá»›i account_name + config
    2. SessionManager má»Ÿ browser vá»›i profile Ä‘Ã£ lÆ°u
    3. Tá»± Ä‘á»™ng Ä‘iá»n form vÃ  táº¡o nháº¡c
    4. Callback cáº­p nháº­t progress bar trong UI
    5. Tráº£ káº¿t quáº£ vá» UI
    """
    
    def __init__(self, session_manager: SessionManager, progress_callback: Optional[Callable[[str, int], None]] = None):
        """
        Khá»Ÿi táº¡o Suno Music Creator
        
        Args:
            session_manager: SessionManager instance (tá»« app)
            progress_callback: Callback Ä‘á»ƒ cáº­p nháº­t UI
                               Signature: callback(message: str, progress: int)
        """
        self.create_url = "https://suno.com/create"
        self.session_manager = session_manager
        self.progress_callback = progress_callback
        self.driver = None
        self.wait = None
        
    def _update_progress(self, message: str, progress: int):
        """
        Cáº­p nháº­t progress trong UI
        
        Args:
            message: ThÃ´ng Ä‘iá»‡p hiá»ƒn thá»‹
            progress: % hoÃ n thÃ nh (0-100)
        """
        logger.info(f"[{progress}%] {message}")
        if self.progress_callback:
            self.progress_callback(message, progress)
        
    def create_song(self, account_name: str, config: SunoCreateConfig) -> Dict[str, Any]:
        """
        Táº¡o bÃ i hÃ¡t tá»± Ä‘á»™ng tá»« account Ä‘Ã£ lÆ°u
        
        WORKFLOW:
        1. Má»Ÿ browser vá»›i profile account (qua SessionManager)
        2. Navigate Ä‘áº¿n /create vÃ  chuyá»ƒn Custom mode
        3. Chá»n Persona (optional)
        4. Äiá»n Lyrics, Styles, Title
        5. Cáº¥u hÃ¬nh Advanced Options (optional)
        6. Click Create vÃ  chá» káº¿t quáº£
        
        Args:
            account_name: TÃªn account Ä‘Ã£ lÆ°u (cÃ³ profile Chrome)
            config: Cáº¥u hÃ¬nh táº¡o nháº¡c
            
        Returns:
            Dict chá»©a thÃ´ng tin káº¿t quáº£
        """
        logger.info(f"Báº¯t Ä‘áº§u táº¡o nháº¡c cho account: {account_name}")
        self._update_progress("Äang chuáº©n bá»‹...", 0)
        
        result = {
            "success": False,
            "steps_completed": [],
            "error": None,
            "song_urls": []
        }
        
        try:
            # BÆ¯á»šC 0: Má»Ÿ browser vá»›i profile account
            self._update_progress(f"Má»Ÿ browser vá»›i profile '{account_name}'...", 5)
            self.driver = self.session_manager.launch_browser(account_name, headless=False)
            if not self.driver:
                raise Exception(f"KhÃ´ng thá»ƒ má»Ÿ browser cho account '{account_name}'")
            
            self.wait = WebDriverWait(self.driver, 10)
            result["steps_completed"].append("open_browser")
            
            # BÆ¯á»šC 1: Navigate vÃ  chuyá»ƒn Custom Mode
            self._update_progress("Chuyá»ƒn sang Custom Mode...", 10)
            self._ensure_custom_mode()
            result["steps_completed"].append("prepare_environment")
            
            # BÆ¯á»šC 2: Chá»n Persona (náº¿u cÃ³)
            if config.persona_name:
                self._update_progress(f"Chá»n Persona '{config.persona_name}'...", 20)
                self._select_persona(config.persona_name)
                result["steps_completed"].append("select_persona")
            else:
                self._update_progress("Bá» qua Persona...", 20)
                result["steps_completed"].append("skip_persona")
            
            # BÆ¯á»šC 3: Nháº­p ná»™i dung chÃ­nh
            self._update_progress("Nháº­p Lyrics, Styles, Title...", 40)
            self._fill_main_content(
                lyrics=config.lyrics,
                styles=config.styles,
                title=config.title
            )
            result["steps_completed"].append("fill_content")
            
            # BÆ¯á»šC 4: Advanced Options (náº¿u cÃ³)
            if self._has_advanced_options(config):
                self._update_progress("Cáº¥u hÃ¬nh Advanced Options...", 60)
                self._configure_advanced_options(config)
                result["steps_completed"].append("configure_advanced")
            else:
                self._update_progress("DÃ¹ng Advanced Options máº·c Ä‘á»‹nh...", 60)
                result["steps_completed"].append("skip_advanced")
            
            # BÆ¯á»šC 5: Táº¡o bÃ i hÃ¡t
            self._update_progress("Äang táº¡o bÃ i hÃ¡t...", 70)
            song_urls = self._create_and_wait(config)
            result["steps_completed"].append("create_song")
            result["song_urls"] = song_urls
            
            result["success"] = True
            self._update_progress(f"HoÃ n thÃ nh! ÄÃ£ táº¡o {len(song_urls)} bÃ i hÃ¡t", 100)
            logger.info(f"Táº¡o nháº¡c thÃ nh cÃ´ng: {len(song_urls)} bÃ i")
            
        except Exception as e:
            result["error"] = str(e)
            self._update_progress(f"Lá»—i: {str(e)}", 0)
            logger.error(f"Lá»—i táº¡o nháº¡c: {e}")
            import traceback
            logger.error(traceback.format_exc())
        
        return result
    
    def _ensure_custom_mode(self):
        """Äáº£m báº£o Ä‘ang á»Ÿ Custom Mode"""
        logger.info("Navigate Ä‘áº¿n Suno Create page...")
        self.driver.get(self.create_url)
        time.sleep(5)  # TÄƒng thá»i gian chá» page load (DOM heavy)
        
        # DEBUG: Take screenshot to see actual UI
        try:
            screenshot_path = Path("logs/debug_page_load.png")
            screenshot_path.parent.mkdir(exist_ok=True)
            self.driver.save_screenshot(str(screenshot_path))
            logger.info(f"ðŸ“¸ Screenshot saved: {screenshot_path}")
        except Exception as e:
            logger.warning(f"Failed to save screenshot: {e}")
        
        logger.info("Kiá»ƒm tra cháº¿ Ä‘á»™ Custom Mode...")
        try:
            # Wait cho page load - kiá»ƒm tra báº¥t ká»³ button nÃ o
            logger.info("Äá»£i page load (wait for any button)...")
            WebDriverWait(self.driver, 20).until(
                EC.presence_of_element_located((By.TAG_NAME, "button"))
            )
            logger.info("âœ“ Page Ä‘Ã£ load (found buttons)")
            
            # TÃ¬m nÃºt Custom - dÃ¹ng accessible name (Playwright approach)
            logger.info("TÃ¬m nÃºt Custom...")
            # Thá»­ nhiá»u strategies (verified tá»« Playwright record)
            custom_selectors = [
                "//button[normalize-space(.)='Custom']",  # Playwright: get_by_role("button", name="Custom")
                "//button[@role='button' and normalize-space(.)='Custom']",  # With role attribute
                "//button[contains(text(), 'Custom')]",  # Contains text fallback
                "//button[@aria-label='Custom']",  # Aria label fallback
            ]
            
            custom_button = None
            for selector in custom_selectors:
                try:
                    custom_button = WebDriverWait(self.driver, 5).until(
                        EC.element_to_be_clickable((By.XPATH, selector))
                    )
                    logger.info(f"âœ“ Found Custom button vá»›i: {selector}")
                    break
                except TimeoutException:
                    logger.debug(f"Selector failed: {selector}")
                    continue
            
            if not custom_button:
                logger.warning("âš ï¸ KhÃ´ng tÃ¬m tháº¥y nÃºt Custom vá»›i báº¥t ká»³ selector nÃ o")
                logger.info("Giáº£ Ä‘á»‹nh Ä‘Ã£ á»Ÿ Custom Mode, tiáº¿p tá»¥c...")
                return
            
            # Kiá»ƒm tra xem Ä‘Ã£ á»Ÿ Custom mode chÆ°a
            # Check aria-pressed hoáº·c data-state attribute
            is_active = (
                custom_button.get_attribute("aria-pressed") == "true" or
                custom_button.get_attribute("data-state") == "active" or
                custom_button.get_attribute("focused") == "focused" or
                "active" in (custom_button.get_attribute("class") or "")
            )
            
            if not is_active:
                logger.info("Chuyá»ƒn sang Custom Mode...")
                custom_button.click()
                time.sleep(2)  # Chá» UI update
                logger.info("âœ“ ÄÃ£ chuyá»ƒn sang Custom Mode")
            else:
                logger.info("âœ“ ÄÃ£ á»Ÿ Custom Mode")
            
        except TimeoutException as e:
            logger.warning(f"Timeout khi tÃ¬m nÃºt Custom: {e}")
            logger.warning("Tiáº¿p tá»¥c thá»­ fill form...")
        
    def _select_persona(self, persona_name: str):
        """
        Chá»n Persona theo tÃªn (Updated 2025-11-09)
        
        Args:
            persona_name: TÃªn persona cáº§n chá»n (vd: "Minh Chien")
            
        Flow:
            1. Click "Add Persona" button
            2. Chá» modal xuáº¥t hiá»‡n
            3. Nháº­p tÃªn vÃ o search box
            4. Click káº¿t quáº£ Ä‘áº§u tiÃªn (bá» qua "Create New Persona")
        """
        logger.info(f"Chá»n persona '{persona_name}'...")
        
        # 1. Click Persona button
        try:
            # Scroll lÃªn trÃªn cÃ¹ng
            self.driver.execute_script("window.scrollTo(0, 0);")
            time.sleep(0.5)
            
            persona_btn = self.wait.until(
                EC.element_to_be_clickable((By.XPATH, 
                    "//button[contains(., 'Persona') or contains(., 'Add Persona')]"))
            )
            persona_btn.click()
            time.sleep(1.5)
            logger.info(f"âœ“ Persona modal opened")
        except Exception as e:
            logger.warning(f"Cannot open persona modal: {e}")
            return
        
        # 2. TÃ¬m search input vÃ  nháº­p tÃªn
        try:
            # Chá» modal animation
            time.sleep(1)
            
            search_input = self.wait.until(
                EC.element_to_be_clickable((By.XPATH, 
                    "//div[contains(@class, 'chakra-modal__content')]//input[@placeholder='Search']"))
            )
            
            search_input.click()
            time.sleep(0.3)
            search_input.clear()
            search_input.send_keys(persona_name.lower())
            time.sleep(1.5)
            
            logger.info(f"âœ“ Searched for '{persona_name}'")
        except Exception as e:
            logger.warning(f"Cannot search persona: {e}")
            return
        
        # 3. Click káº¿t quáº£ Ä‘áº§u tiÃªn (bá» qua "Create New Persona")
        try:
            persona_containers = self.wait.until(
                EC.presence_of_all_elements_located((By.XPATH, 
                    "//div[contains(@class, 'group flex w-full cursor-pointer items-center gap-4')]"))
            )
            
            # Lá»c bá» "Create New Persona"
            valid_personas = []
            for container in persona_containers:
                if "Create New Persona" not in container.text:
                    valid_personas.append(container)
            
            if not valid_personas:
                logger.warning(f"No persona found matching '{persona_name}'")
                return
            
            # Click káº¿t quáº£ Ä‘áº§u tiÃªn
            first_result = valid_personas[0]
            
            # Láº¥y tÃªn Ä‘á»ƒ verify
            try:
                name_div = first_result.find_element(By.XPATH, 
                    ".//div[contains(@class, 'text-foreground-primary')]")
                found_name = name_div.text
                logger.info(f"âœ“ Found persona: '{found_name}'")
            except:
                pass
            
            # Scroll vÃ  click
            self.driver.execute_script("arguments[0].scrollIntoView({block: 'center'});", first_result)
            time.sleep(0.5)
            first_result.click()
            time.sleep(1)
            
            logger.info(f"âœ“ Persona '{persona_name}' selected successfully")
            
        except Exception as e:
            logger.warning(f"Cannot click persona: {e}")
            raise
    
    def _fill_main_content(self, lyrics: str, styles: str, title: Optional[str]):
        """
        Nháº­p Lyrics, Styles, Title vá»›i Selenium
        
        VERIFIED SELECTORS tá»« Playwright record:
        - Lyrics: role="textbox" name="Write some lyrics or a prompt"
        - Styles: role="textbox" name="indie, electronic, synths,"
        - Title: role="textbox" name="Song Title (Optional)"
        
        Strategy: Playwright-compatible XPath (role + aria-label/placeholder)
        
        Args:
            lyrics: Lá»i bÃ i hÃ¡t hoáº·c prompt
            styles: Style tags
            title: TÃªn bÃ i hÃ¡t (optional)
        """
        if lyrics:
            logger.info(f"Nháº­p Lyrics ({len(lyrics)} kÃ½ tá»±)...")
            try:
                # Playwright verified: Suno dÃ¹ng <textarea> tháº­t, khÃ´ng cÃ³ role='textbox'
                lyrics_selectors = [
                    "//textarea[contains(@placeholder, 'Write some lyrics or a prompt')]",
                    "//*[@role='textbox' and contains(@placeholder, 'Write some lyrics or a prompt')]",
                    "//*[contains(@aria-label, 'Write some lyrics')]",
                    "//textarea[@aria-label='Lyrics']",
                ]
                
                lyrics_box = None
                for selector in lyrics_selectors:
                    try:
                        lyrics_box = WebDriverWait(self.driver, 5).until(
                            EC.element_to_be_clickable((By.XPATH, selector))
                        )
                        logger.info(f"âœ“ Found lyrics box vá»›i: {selector}")
                        break
                    except TimeoutException:
                        continue
                
                if not lyrics_box:
                    raise Exception("KhÃ´ng tÃ¬m tháº¥y Lyrics textbox vá»›i báº¥t ká»³ selector nÃ o")
                
                lyrics_box.click()
                time.sleep(0.5)
                lyrics_box.clear()
                lyrics_box.send_keys(lyrics)
                logger.info("âœ“ ÄÃ£ nháº­p Lyrics")
            except Exception as e:
                logger.error(f"âŒ Lá»—i khi nháº­p Lyrics: {e}")
                raise
        else:
            logger.info("Bá» qua Lyrics (táº¡o instrumental)")
        
        if styles:
            logger.info(f"Nháº­p Styles: {styles[:50]}...")
            try:
                # Playwright verified: Suno dÃ¹ng <textarea> tháº­t
                styles_selectors = [
                    "//textarea[contains(@placeholder, 'indie, electronic, synths')]",
                    "//*[@role='textbox' and contains(@placeholder, 'indie, electronic, synths')]",
                    "//*[contains(@aria-label, 'Style of Music')]",
                    "//textarea[@aria-label='Style of Music']",
                ]
                
                styles_box = None
                for selector in styles_selectors:
                    try:
                        styles_box = WebDriverWait(self.driver, 5).until(
                            EC.element_to_be_clickable((By.XPATH, selector))
                        )
                        logger.info(f"âœ“ Found styles box vá»›i: {selector}")
                        break
                    except TimeoutException:
                        continue
                
                if not styles_box:
                    raise Exception("KhÃ´ng tÃ¬m tháº¥y Styles textbox vá»›i báº¥t ká»³ selector nÃ o")
                styles_box.click()
                time.sleep(0.5)
                styles_box.clear()
                styles_box.send_keys(styles)
                logger.info("âœ“ ÄÃ£ nháº­p Styles")
            except Exception as e:
                logger.error(f"âŒ Lá»—i khi nháº­p Styles: {e}")
                raise
        else:
            logger.warning("Cáº£nh bÃ¡o: ChÆ°a nháº­p Styles!")
        
        if title:
            logger.info(f"Nháº­p Title: {title}...")
            try:
                # Playwright verified: Suno dÃ¹ng <input> tháº­t
                title_selectors = [
                    "//input[contains(@placeholder, 'Song Title (Optional)')]",
                    "//*[@role='textbox' and contains(@placeholder, 'Song Title (Optional)')]",
                    "//*[contains(@aria-label, 'Song Title')]",
                    "//input[@aria-label='Title']",
                ]
                
                title_box = None
                for selector in title_selectors:
                    try:
                        title_box = WebDriverWait(self.driver, 5).until(
                            EC.element_to_be_clickable((By.XPATH, selector))
                        )
                        logger.info(f"âœ“ Found title box vá»›i: {selector}")
                        break
                    except TimeoutException:
                        continue
                
                if not title_box:
                    raise Exception("KhÃ´ng tÃ¬m tháº¥y Title textbox vá»›i báº¥t ká»³ selector nÃ o")
                
                title_box.click()
                time.sleep(0.5)
                title_box.clear()
                title_box.send_keys(title)
                logger.info("âœ“ ÄÃ£ nháº­p Title")
            except Exception as e:
                logger.error(f"âŒ Lá»—i khi nháº­p Title: {e}")
                raise
        else:
            logger.info("Bá» qua Title (AI tá»± táº¡o)")
        
        logger.info("âœ“ ÄÃ£ hoÃ n thÃ nh nháº­p ná»™i dung")
    
    def _open_advanced_options(self):
        """Má»Ÿ Advanced Options náº¿u chÆ°a má»Ÿ"""
        try:
            # Playwright: get_by_role("button", name="Advanced Options")
            # Multiple selectors vÃ¬ cÃ³ thá»ƒ text thay Ä‘á»•i
            adv_selectors = [
                "//button[normalize-space(.)='Advanced Options']",
                "//button[contains(text(), 'Advanced Options')]",
                "//button[contains(@aria-label, 'Advanced')]",
            ]
            
            adv_btn = None
            for selector in adv_selectors:
                try:
                    adv_btn = self.driver.find_element(By.XPATH, selector)
                    logger.debug(f"Found Advanced Options vá»›i: {selector}")
                    break
                except NoSuchElementException:
                    continue
            
            if not adv_btn:
                logger.warning("KhÃ´ng tÃ¬m tháº¥y nÃºt Advanced Options - cÃ³ thá»ƒ Ä‘Ã£ má»Ÿ sáºµn")
                return
            
            # Kiá»ƒm tra xem Ä‘Ã£ má»Ÿ chÆ°a qua attribute expanded
            is_expanded = adv_btn.get_attribute("aria-expanded") == "true"
            
            if not is_expanded:
                adv_btn.click()
                time.sleep(0.5)
                logger.info("âœ“ ÄÃ£ má»Ÿ Advanced Options")
            else:
                logger.info("âœ“ Advanced Options Ä‘Ã£ má»Ÿ sáºµn")
        except Exception as e:
            logger.debug(f"Lá»—i khi má»Ÿ Advanced Options: {e} - Tiáº¿p tá»¥c...")
    
    def _has_advanced_options(self, config: SunoCreateConfig) -> bool:
        """Kiá»ƒm tra cÃ³ cáº§n cáº¥u hÃ¬nh Advanced Options khÃ´ng"""
        return any([
            config.exclude_styles,
            config.vocal_gender,
            config.lyrics_mode,
            config.weirdness is not None,
            config.style_influence is not None
        ])
    
    def _configure_advanced_options(self, config: SunoCreateConfig):
        """
        Cáº¥u hÃ¬nh Advanced Options
        
        Args:
            config: Cáº¥u hÃ¬nh chá»©a advanced options
        """
        logger.info("Má»Ÿ Advanced Options...")
        self._open_advanced_options()
        time.sleep(0.5)
        
        if config.exclude_styles:
            logger.info(f"Exclude Styles: {config.exclude_styles}")
            try:
                # Playwright verified: Suno dÃ¹ng <input> tháº­t
                exclude_selectors = [
                    "//input[contains(@placeholder, 'Exclude styles')]",
                    "//textarea[contains(@placeholder, 'Exclude styles')]",
                    "//*[@role='textbox' and contains(@placeholder, 'Exclude styles')]",
                ]
                
                exclude_box = None
                for selector in exclude_selectors:
                    try:
                        exclude_box = WebDriverWait(self.driver, 3).until(
                            EC.element_to_be_clickable((By.XPATH, selector))
                        )
                        break
                    except TimeoutException:
                        continue
                
                if exclude_box:
                    exclude_box.clear()
                    exclude_box.send_keys(config.exclude_styles)
                    logger.info("âœ“ ÄÃ£ nháº­p Exclude Styles")
                else:
                    logger.warning("KhÃ´ng tÃ¬m tháº¥y Exclude Styles input")
            except Exception as e:
                logger.warning(f"Lá»—i khi nháº­p Exclude Styles: {e}")
        
        if config.vocal_gender:
            logger.info(f"Vocal Gender: {config.vocal_gender}")
            try:
                # Playwright: get_by_role("button", name="Male", exact=True)
                gender_btn = self.driver.find_element(
                    By.XPATH, 
                    f"//button[normalize-space(.)='{config.vocal_gender}']"
                )
                gender_btn.click()
                time.sleep(0.3)
                logger.info(f"âœ“ ÄÃ£ chá»n {config.vocal_gender}")
            except NoSuchElementException:
                logger.warning(f"KhÃ´ng tÃ¬m tháº¥y button {config.vocal_gender}")
        
        if config.lyrics_mode:
            logger.info(f"Lyrics Mode: {config.lyrics_mode}")
            try:
                # Playwright: get_by_role("button", name="Manual")
                mode_btn = self.driver.find_element(
                    By.XPATH,
                    f"//button[normalize-space(.)='{config.lyrics_mode}']"
                )
                mode_btn.click()
                time.sleep(0.3)
                logger.info(f"âœ“ ÄÃ£ chá»n {config.lyrics_mode}")
            except NoSuchElementException:
                logger.warning(f"KhÃ´ng tÃ¬m tháº¥y button {config.lyrics_mode}")
        
        if config.weirdness is not None:
            logger.info(f"Weirdness: {config.weirdness}%")
            try:
                # Set slider value qua JavaScript
                weirdness_slider = self.driver.find_element(By.XPATH, "//input[@type='range' and contains(@aria-label, 'weirdness')]")
                self.driver.execute_script(f"arguments[0].value = {config.weirdness}; arguments[0].dispatchEvent(new Event('input', {{ bubbles: true }}));", weirdness_slider)
            except NoSuchElementException:
                logger.warning("KhÃ´ng tÃ¬m tháº¥y Weirdness slider")
        
        if config.style_influence is not None:
            logger.info(f"Style Influence: {config.style_influence}%")
            try:
                # Set slider value qua JavaScript
                influence_slider = self.driver.find_element(By.XPATH, "//input[@type='range' and contains(@aria-label, 'style influence')]")
                self.driver.execute_script(f"arguments[0].value = {config.style_influence}; arguments[0].dispatchEvent(new Event('input', {{ bubbles: true }}));", influence_slider)
            except NoSuchElementException:
                logger.warning("KhÃ´ng tÃ¬m tháº¥y Style Influence slider")
        
        logger.info("âœ“ ÄÃ£ cáº¥u hÃ¬nh Advanced Options")
    
    def _create_and_wait(self, config: SunoCreateConfig) -> list:
        """
        Click Create vÃ  chá» káº¿t quáº£
        
        Args:
            config: Cáº¥u hÃ¬nh (chá»©a wait_for_generation vÃ  timeout)
            
        Returns:
            List cÃ¡c URL bÃ i hÃ¡t Ä‘Ã£ táº¡o
        """
        logger.info("Click nÃºt 'Create'...")
        try:
            # TÃ¬m nÃºt Create - cÃ³ thá»ƒ lÃ  "Create" hoáº·c "Create song"
            create_btn = self.wait.until(
                EC.element_to_be_clickable((By.XPATH, "//button[contains(text(), 'Create') and not(@disabled)]"))
            )
            create_btn.click()
            logger.info("âœ“ ÄÃ£ click Create")
        except TimeoutException:
            logger.error("NÃºt Create khÃ´ng kháº£ dá»¥ng (cÃ³ thá»ƒ thiáº¿u thÃ´ng tin)")
            return []
        
        if not config.wait_for_generation:
            logger.info("KhÃ´ng chá» generation (táº¯t wait_for_generation)")
            return []
        
        logger.info(f"Chá» AI táº¡o nháº¡c (timeout: {config.timeout}s)...")
        
        # Polling Ä‘á»ƒ chá» bÃ i hÃ¡t xuáº¥t hiá»‡n
        start_time = time.time()
        song_urls = []
        
        while time.time() - start_time < config.timeout:
            try:
                # TÃ¬m cÃ¡c song cards má»›i (cÃ³ class chá»©a "song" hoáº·c "clip")
                song_cards = self.driver.find_elements(
                    By.XPATH,
                    "//div[contains(@class, 'song-card') or contains(@class, 'clip-card')]//a[contains(@href, '/song/')]"
                )
                
                if song_cards:
                    # Extract URLs
                    song_urls = [card.get_attribute('href') for card in song_cards[:2]]  # Suno táº¡o 2 version
                    logger.info(f"âœ“ TÃ¬m tháº¥y {len(song_urls)} bÃ i hÃ¡t")
                    break
                
                # Chá» 5s trÆ°á»›c khi kiá»ƒm tra láº¡i
                elapsed = int(time.time() - start_time)
                logger.info(f"Äang chá»... ({elapsed}s/{config.timeout}s)")
                time.sleep(5)
                
            except Exception as e:
                logger.warning(f"Lá»—i khi tÃ¬m song cards: {e}")
                time.sleep(5)
        
        if not song_urls:
            logger.warning(f"Timeout sau {config.timeout}s, khÃ´ng tháº¥y bÃ i hÃ¡t")
        
        return song_urls


# ============================================
# DEMO USAGE
# ============================================

def demo_with_ui_integration():
    """
    Demo: TÃ­ch há»£p vá»›i UI App
    Giáº£ láº­p gá»i tá»« CreateMusicPanel
    """
    from src.core.session_manager import SessionManager
    
    # 1. Khá»Ÿi táº¡o SessionManager (tá»« app)
    session_manager = SessionManager()
    
    # 2. Callback Ä‘á»ƒ cáº­p nháº­t progress bar
    def update_progress(message: str, progress: int):
        print(f"[UI Progress] {progress}%: {message}")
    
    # 3. Táº¡o MusicCreator
    creator = SunoMusicCreator(
        session_manager=session_manager,
        progress_callback=update_progress
    )
    
    # 4. Config bÃ i hÃ¡t
    config = SunoCreateConfig(
        lyrics="""[Verse 1]
SÃ¡ng nay thá»©c dáº­y tháº¥y trá»i quÃ¡ Ä‘áº¹p
Náº¯ng vÃ ng chan hÃ²a kháº¯p con phá»‘

[Chorus]
HÃ£y cÃ¹ng nhau vui ca hÃ¡t
Cuá»™c sá»‘ng tháº­t tuyá»‡t vá»i""",
        
        styles="Vietnamese Pop, upbeat, 128bpm, major key, guitar, piano, cheerful",
        title="SÃ¡ng Náº¯ng",
        vocal_gender="Female",
        lyrics_mode="Manual",
        weirdness=30,
        style_influence=70,
    )
    
    # 5. Táº¡o bÃ i hÃ¡t tá»« account Ä‘Ã£ lÆ°u
    account_name = "thang"  # Account trong suno_accounts.json
    result = creator.create_song(account_name, config)
    
    # 6. Xá»­ lÃ½ káº¿t quáº£
    if result["success"]:
        print(f"\nâœ… Táº¡o nháº¡c thÃ nh cÃ´ng!")
        print(f"Steps: {', '.join(result['steps_completed'])}")
        print(f"Songs:")
        for url in result["song_urls"]:
            print(f"  ðŸŽµ {url}")
    else:
        print(f"\nâŒ Lá»—i: {result['error']}")


def demo_create_pop_song():
    """Demo: Táº¡o bÃ i Pop Viá»‡t Nam (Legacy - Standalone)"""
    print("âš ï¸  Demo nÃ y cáº§n SessionManager tá»« UI app")
    print("DÃ¹ng demo_with_ui_integration() thay tháº¿")
    return
    
    config = SunoCreateConfig(
        # BÆ°á»›c 1: KhÃ´ng dÃ¹ng persona
        persona_name=None,
        
        # BÆ°á»›c 2: Ná»™i dung chÃ­nh
        lyrics="""[Verse 1]
SÃ¡ng nay thá»©c dáº­y tháº¥y trá»i quÃ¡ Ä‘áº¹p
Náº¯ng vÃ ng chan hÃ²a kháº¯p con phá»‘

[Chorus]
HÃ£y cÃ¹ng nhau vui ca hÃ¡t
Cuá»™c sá»‘ng tháº­t tuyá»‡t vá»i""",
        
        styles="Vietnamese Pop, upbeat, 128bpm, major key, guitar, piano, cheerful, catchy melody",
        
        title="SÃ¡ng Náº¯ng",
        
        # BÆ°á»›c 3: Advanced Options
        vocal_gender="Female",
        lyrics_mode="Manual",
        weirdness=30,
        style_influence=70,
    )
    
    creator = SunoAutoCreator()
    result = creator.create_song(config)
    
    print("\n" + "=" * 60)
    print("ðŸ“Š Káº¾T QUáº¢:")
    print(f"   Success: {result['success']}")
    print(f"   Steps: {', '.join(result['steps_completed'])}")
    if result['song_urls']:
        print(f"   Songs:")
        for url in result['song_urls']:
            print(f"      - {url}")
    print("=" * 60)


def demo_create_edm_with_persona():
    """Demo: Táº¡o EDM vá»›i Persona"""
    config = SunoCreateConfig(
        # BÆ°á»›c 1: DÃ¹ng persona
        persona_name="DJ Storm",
        
        # BÆ°á»›c 2: Instrumental (khÃ´ng lá»i)
        lyrics="",  # Äá»ƒ trá»‘ng
        styles="festival anthem, epic drop, build-up",
        title="Neon Pulse",
        
        # BÆ°á»›c 3: Advanced
        weirdness=65,
        style_influence=85,
    )
    
    creator = SunoAutoCreator()
    result = creator.create_song(config)
    
    print("\n" + "=" * 60)
    print("ðŸ“Š Káº¾T QUáº¢:")
    print(f"   Success: {result['success']}")
    print(f"   Steps: {', '.join(result['steps_completed'])}")
    if result['song_urls']:
        print(f"   Songs:")
        for url in result['song_urls']:
            print(f"      - {url}")
    print("=" * 60)


def demo_create_ballad_with_persona():
    """Demo: Táº¡o Ballad vá»›i Persona 'Thang'"""
    config = SunoCreateConfig(
        # BÆ°á»›c 1: DÃ¹ng persona cÃ³ sáºµn
        persona_name="Thang",
        
        # BÆ°á»›c 2: Ná»™i dung
        lyrics="""[Verse 1]
ÄÃªm nay trÄƒng sÃ¡ng nhÆ° ngÃ y xÆ°a
Em cÃ²n nhá»› khÃ´ng nhá»¯ng lá»i thá»

[Chorus]
DÃ¹ xa cÃ¡ch nhÆ°ng tÃ¬nh váº«n mÃ£i
MÃ£i trong tim anh khÃ´ng phai""",
        
        styles="",  # Persona sáº½ tá»± Ä‘á»™ng Ä‘iá»n
        title="ÄÃªm TrÄƒng Nhá»›",
        
        # BÆ°á»›c 3: Minimal advanced options
        lyrics_mode="Manual",
    )
    
    creator = SunoAutoCreator()
    result = creator.create_song(config)
    
    print("\n" + "=" * 60)
    print("ðŸ“Š Káº¾T QUáº¢:")
    print(f"   Success: {result['success']}")
    print(f"   Steps: {', '.join(result['steps_completed'])}")
    if result['song_urls']:
        print(f"   Songs:")
        for url in result['song_urls']:
            print(f"      - {url}")
    print("=" * 60)


if __name__ == "__main__":
    print("ðŸŽµ SUNO AUTO MUSIC CREATION - DEMO")
    print("=" * 60)
    print("Chá»n demo:")
    print("1. Táº¡o bÃ i Pop Viá»‡t Nam (khÃ´ng persona)")
    print("2. Táº¡o EDM vá»›i Persona 'DJ Storm'")
    print("3. Táº¡o Ballad vá»›i Persona 'Thang'")
    print("=" * 60)
    
    choice = input("Nháº­p sá»‘ (1-3): ").strip()
    
    if choice == "1":
        demo_create_pop_song()
    elif choice == "2":
        demo_create_edm_with_persona()
    elif choice == "3":
        demo_create_ballad_with_persona()
    else:
        print("âŒ Lá»±a chá»n khÃ´ng há»£p lá»‡!")
</file>

<file path="legacy_modules/suno_batch_download.py">
"""
Batch Download Suno Songs - TÃ­ch há»£p vá»›i Multi Account Manager
Dá»±a trÃªn bulk-suno-py-2 vá»›i cáº£i tiáº¿n cho multi-account
"""
import os
import re
import time
import json
import random
import requests
from pathlib import Path
from colorama import init, Fore, Style

# Khá»Ÿi táº¡o colorama
init(autoreset=True)

class SunoBatchDownloader:
    def __init__(self, session_token=None, proxy_list=None):
        """
        Khá»Ÿi táº¡o downloader
        
        Args:
            session_token: JWT token tá»« cookies (cookie __session)
            proxy_list: List cÃ¡c proxy (optional)
        """
        self.session_token = session_token
        self.proxy_list = proxy_list or []
        self.base_url = "https://studio-api.prod.suno.com/api"
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'application/json',
        }
        
        if self.session_token:
            self.headers['Authorization'] = f'Bearer {self.session_token}'
        
        # File lÆ°u lá»‹ch sá»­ download
        self.history_file = Path("download_history.json")
    
    def load_download_history(self, account_name):
        """Load lá»‹ch sá»­ download cá»§a account"""
        try:
            if self.history_file.exists():
                with open(self.history_file, 'r', encoding='utf-8') as f:
                    history = json.load(f)
                    return history.get(account_name, {
                        'downloaded_ids': [],
                        'total_downloaded': 0,
                        'current_page': 0,
                        'last_profile': ''
                    })
        except Exception as e:
            print(f"{Fore.YELLOW}âš ï¸  Lá»—i khi load history: {str(e)}")
        
        return {
            'downloaded_ids': [],
            'total_downloaded': 0,
            'current_page': 0,
            'last_profile': ''
        }
    
    def save_download_history(self, account_name, history_data):
        """LÆ°u lá»‹ch sá»­ download cá»§a account"""
        try:
            # Load toÃ n bá»™ history
            all_history = {}
            if self.history_file.exists():
                with open(self.history_file, 'r', encoding='utf-8') as f:
                    all_history = json.load(f)
            
            # Update cho account hiá»‡n táº¡i
            all_history[account_name] = history_data
            
            # Save láº¡i file
            with open(self.history_file, 'w', encoding='utf-8') as f:
                json.dump(all_history, f, indent=4, ensure_ascii=False)
            
            print(f"{Fore.GREEN}âœ“ ÄÃ£ lÆ°u lá»‹ch sá»­ trang {history_data.get('current_page', 0)}")
        
        except Exception as e:
            print(f"{Fore.RED}âŒ Lá»—i khi save history: {str(e)}")
    
    def get_random_proxy(self):
        """Láº¥y proxy ngáº«u nhiÃªn tá»« list"""
        if not self.proxy_list:
            return None
        return {'http': random.choice(self.proxy_list), 'https': random.choice(self.proxy_list)}
    
    def sanitize_filename(self, name):
        """LÃ m sáº¡ch tÃªn file, loáº¡i bá» kÃ½ tá»± khÃ´ng há»£p lá»‡"""
        # Loáº¡i bá» cÃ¡c kÃ½ tá»± khÃ´ng há»£p lá»‡
        invalid_chars = r'<>:"/\\|?*'
        for char in invalid_chars:
            name = name.replace(char, '')
        
        # Loáº¡i bá» control characters
        name = re.sub(r'[\x00-\x1f\x7f]', '', name)
        
        # Trim spaces vÃ  dots á»Ÿ cuá»‘i
        name = name.strip().rstrip('.')
        
        # Náº¿u tÃªn rá»—ng, dÃ¹ng tÃªn máº·c Ä‘á»‹nh
        if not name:
            name = "untitled"
        
        return name
    
    def ensure_unique_filename(self, directory, base_name, extension='.mp3'):
        """Äáº£m báº£o tÃªn file khÃ´ng trÃ¹ng láº·p"""
        file_path = Path(directory) / f"{base_name}{extension}"
        
        if not file_path.exists():
            return str(file_path)
        
        counter = 2
        while True:
            new_name = f"{base_name} ({counter}){extension}"
            file_path = Path(directory) / new_name
            if not file_path.exists():
                return str(file_path)
            counter += 1
    
    def fetch_profile_clips(self, profile_name, start_page=0, max_pages=None):
        """
        Láº¥y clips tá»« profile theo page
        
        Args:
            profile_name: TÃªn profile (VD: @username)
            start_page: Trang báº¯t Ä‘áº§u (0-indexed)
            max_pages: Sá»‘ trang tá»‘i Ä‘a cáº§n fetch (None = khÃ´ng giá»›i háº¡n)
        
        Returns:
            Tuple (clips_list, last_page, has_more)
        """
        print(f"\n{Fore.CYAN}ðŸ“¥ Äang láº¥y clips tá»« profile: {profile_name} (báº¯t Ä‘áº§u tá»« trang {start_page})")
        
        # Bá» @ náº¿u cÃ³
        if profile_name.startswith('@'):
            profile_name = profile_name[1:]
        
        url = f"{self.base_url}/profiles/{profile_name}/clips"
        all_clips = []
        page = start_page
        retry_wait = 10
        pages_fetched = 0
        
        while True:
            # Kiá»ƒm tra giá»›i háº¡n sá»‘ trang
            if max_pages and pages_fetched >= max_pages:
                print(f"{Fore.YELLOW}âš ï¸  ÄÃ£ Ä‘áº¡t giá»›i háº¡n {max_pages} trang")
                return all_clips, page - 1, True
            
            try:
                params = {'page': page}
                proxies = self.get_random_proxy()
                
                response = requests.get(
                    url,
                    headers=self.headers,
                    params=params,
                    proxies=proxies,
                    timeout=30
                )
                
                if response.status_code == 429:
                    print(f"{Fore.YELLOW}âš ï¸  Rate limit (429), Ä‘á»£i {retry_wait}s...")
                    time.sleep(retry_wait)
                    retry_wait = min(retry_wait + 5, 60)
                    continue
                
                response.raise_for_status()
                data = response.json()
                
                clips = data.get('clips', [])
                if not clips:
                    # KhÃ´ng cÃ²n clips ná»¯a
                    print(f"{Fore.GREEN}âœ… ÄÃ£ háº¿t clips á»Ÿ trang {page}")
                    return all_clips, page - 1, False
                
                all_clips.extend(clips)
                print(f"{Fore.GREEN}âœ“ Page {page}: {len(clips)} clips")
                
                page += 1
                pages_fetched += 1
                time.sleep(5)  # Äá»£i giá»¯a cÃ¡c page
                retry_wait = 10  # Reset retry wait
                
            except requests.exceptions.RequestException as e:
                print(f"{Fore.RED}âŒ Lá»—i khi fetch page {page}: {str(e)}")
                return all_clips, page - 1, False
        
        print(f"{Fore.GREEN}âœ… Tá»•ng cá»™ng: {len(all_clips)} clips")
        return all_clips, page - 1, False
    
    def fetch_my_clips(self):
        """
        Láº¥y táº¥t cáº£ clips cá»§a user hiá»‡n táº¡i (tá»« /me)
        
        Returns:
            List cÃ¡c clip info
        """
        print(f"\n{Fore.CYAN}ðŸ“¥ Äang láº¥y clips cá»§a báº¡n tá»« /me...")
        
        url = f"{self.base_url}/feed/v2"
        params = {'page': 0}
        all_clips = []
        retry_wait = 10
        
        try:
            proxies = self.get_random_proxy()
            
            response = requests.get(
                url,
                headers=self.headers,
                params=params,
                proxies=proxies,
                timeout=30
            )
            
            if response.status_code == 429:
                print(f"{Fore.YELLOW}âš ï¸  Rate limit (429), Ä‘á»£i {retry_wait}s...")
                time.sleep(retry_wait)
                return []
            
            response.raise_for_status()
            data = response.json()
            
            # Láº¥y clips tá»« feed
            clips = data.get('clips', [])
            all_clips.extend(clips)
            
            print(f"{Fore.GREEN}âœ… TÃ¬m tháº¥y: {len(all_clips)} clips")
            return all_clips
            
        except requests.exceptions.RequestException as e:
            print(f"{Fore.RED}âŒ Lá»—i khi fetch clips: {str(e)}")
            return []
    
    def get_current_user_info(self):
        """
        Láº¥y thÃ´ng tin user hiá»‡n táº¡i
        
        Returns:
            Dict chá»©a user info (username, email, etc.)
        """
        try:
            url = f"{self.base_url}/billing/info"
            proxies = self.get_random_proxy()
            
            response = requests.get(
                url,
                headers=self.headers,
                proxies=proxies,
                timeout=30
            )
            
            response.raise_for_status()
            data = response.json()
            
            # TrÃ­ch xuáº¥t username tá»« response
            user_info = {
                'username': data.get('display_name', ''),
                'email': data.get('email', ''),
                'credits': data.get('total_credits_left', 0)
            }
            
            print(f"{Fore.GREEN}âœ“ User: @{user_info['username']}, Credits: {user_info['credits']}")
            return user_info
            
        except requests.exceptions.RequestException as e:
            print(f"{Fore.RED}âŒ Lá»—i khi láº¥y user info: {str(e)}")
            return None
    
    def fetch_clips_by_uuids(self, uuids):
        """
        Láº¥y thÃ´ng tin clips theo UUIDs
        
        Args:
            uuids: List hoáº·c set cÃ¡c UUID
        
        Returns:
            List cÃ¡c clip info
        """
        print(f"\n{Fore.CYAN}ðŸ“¥ Äang láº¥y {len(uuids)} clips theo UUID...")
        
        clips = []
        for idx, uuid in enumerate(uuids, 1):
            try:
                url = f"{self.base_url}/clips/{uuid}"
                proxies = self.get_random_proxy()
                
                response = requests.get(
                    url,
                    headers=self.headers,
                    proxies=proxies,
                    timeout=30
                )
                
                if response.status_code == 429:
                    print(f"{Fore.YELLOW}âš ï¸  Rate limit, Ä‘á»£i 10s...")
                    time.sleep(10)
                    response = requests.get(url, headers=self.headers, proxies=proxies, timeout=30)
                
                response.raise_for_status()
                clip_data = response.json()
                clips.append(clip_data)
                
                print(f"{Fore.GREEN}âœ“ [{idx}/{len(uuids)}] {clip_data.get('title', 'Unknown')}")
                time.sleep(2)
                
            except requests.exceptions.RequestException as e:
                print(f"{Fore.RED}âŒ Lá»—i khi fetch UUID {uuid}: {str(e)}")
        
        return clips

    def fetch_my_clips_paginated(self, start_page: int = 0, max_pages: int | None = None):
        """
        Fetch clips from the user's feed (/feed/v2) across multiple pages.

        Args:
            start_page: page index to start from
            max_pages: maximum number of pages to fetch (None == all available)

        Returns:
            (all_clips, last_page, has_more)
        """
        print(f"\n{Fore.CYAN}ðŸ“¥ Äang láº¥y clips tá»« /feed/v2 (create/me) ...")

        url = f"{self.base_url}/feed/v2"
        current_page = start_page
        all_clips = []
        pages_fetched = 0

        while True:
            params = {"page": current_page}
            try:
                proxies = self.get_random_proxy()
                response = requests.get(
                    url,
                    headers=self.headers,
                    params=params,
                    proxies=proxies,
                    timeout=30
                )

                if response.status_code == 429:
                    print(f"{Fore.YELLOW}âš ï¸  Rate limit (429), Ä‘á»£i 10s...")
                    time.sleep(10)
                    continue

                response.raise_for_status()
                data = response.json()

                clips = data.get("clips", [])
                all_clips.extend(clips)

                # Determine has_more: server may include pagination metadata
                has_more = bool(data.get("has_more", False))
                # Fallback: if clips length < page size then no more
                if not has_more and len(clips) == 0:
                    has_more = False

                pages_fetched += 1

                print(f"{Fore.GREEN}âœ“ Trang {current_page}: TÃ¬m tháº¥y {len(clips)} clips (tá»•ng: {len(all_clips)})")

                # Check stopping conditions
                if max_pages is not None and pages_fetched >= max_pages:
                    return all_clips, current_page, True

                if not has_more:
                    return all_clips, current_page, False

                current_page += 1
                time.sleep(1)

            except requests.exceptions.RequestException as e:
                print(f"{Fore.RED}âŒ Lá»—i khi fetch feed page {current_page}: {str(e)}")
                return all_clips, current_page, False
    
    def download_audio(self, clip_info, directory, append_uuid=False):
        """
        Download file audio tá»« clip info
        
        Args:
            clip_info: Dict chá»©a thÃ´ng tin clip
            directory: ThÆ° má»¥c lÆ°u file
            append_uuid: CÃ³ thÃªm UUID vÃ o tÃªn file khÃ´ng
        
        Returns:
            Path Ä‘áº¿n file Ä‘Ã£ download hoáº·c None náº¿u tháº¥t báº¡i
        """
        title = clip_info.get('title', 'Untitled')
        clip_id = clip_info.get('id', 'unknown')
        audio_url = clip_info.get('audio_url')
        
        if not audio_url:
            print(f"{Fore.YELLOW}âš ï¸  KhÃ´ng cÃ³ audio_url cho: {title}")
            return None
        
        # Táº¡o tÃªn file
        safe_title = self.sanitize_filename(title)
        if append_uuid:
            base_name = f"{safe_title}__ID__{clip_id}"
        else:
            base_name = safe_title
        
        # Äáº£m báº£o tÃªn file unique
        file_path = self.ensure_unique_filename(directory, base_name)
        
        try:
            proxies = self.get_random_proxy()
            response = requests.get(audio_url, proxies=proxies, stream=True, timeout=60)
            response.raise_for_status()
            
            # Download file
            with open(file_path, 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192):
                    f.write(chunk)
            
            file_size = os.path.getsize(file_path)
            print(f"{Fore.GREEN}âœ“ Downloaded: {Path(file_path).name} ({file_size/1024/1024:.2f} MB)")
            
            return file_path
            
        except Exception as e:
            print(f"{Fore.RED}âŒ Lá»—i khi download {title}: {str(e)}")
            if os.path.exists(file_path):
                os.remove(file_path)
            return None
    
    def download_thumbnail(self, clip_info, directory):
        """Download thumbnail/cover art"""
        image_url = clip_info.get('image_url')
        if not image_url:
            return None
        
        clip_id = clip_info.get('id', 'unknown')
        file_path = Path(directory) / f"{clip_id}_cover.jpg"
        
        try:
            proxies = self.get_random_proxy()
            response = requests.get(image_url, proxies=proxies, timeout=30)
            response.raise_for_status()
            
            with open(file_path, 'wb') as f:
                f.write(response.content)
            
            return str(file_path)
            
        except Exception as e:
            print(f"{Fore.YELLOW}âš ï¸  KhÃ´ng download Ä‘Æ°á»£c thumbnail: {str(e)}")
            return None
    
    def embed_metadata(self, audio_path, clip_info, thumbnail_path=None):
        """NhÃºng metadata vÃ o file MP3"""
        try:
            from mutagen.id3 import ID3, TIT2, TPE1, TALB, TCON, TPUB, WOAR, APIC
            from mutagen.mp3 import MP3
            
            audio = MP3(audio_path, ID3=ID3)
            
            # XÃ³a ID3 tags cÅ© náº¿u cÃ³
            try:
                audio.delete()
            except:
                pass
            
            # Táº¡o ID3 tags má»›i
            audio.add_tags()
            
            # ThÃªm metadata cÆ¡ báº£n
            audio.tags.add(TIT2(encoding=3, text=clip_info.get('title', '')))
            
            if clip_info.get('display_name'):
                audio.tags.add(TPE1(encoding=3, text=clip_info['display_name']))
            
            if clip_info.get('metadata', {}).get('tags'):
                audio.tags.add(TCON(encoding=3, text=', '.join(clip_info['metadata']['tags'])))
            
            if clip_info.get('display_name'):
                audio.tags.add(TPUB(encoding=3, text=clip_info['display_name']))
            
            # ThÃªm URL
            song_url = f"https://suno.com/song/{clip_info.get('id', '')}"
            audio.tags.add(WOAR(url=song_url))
            
            # ThÃªm cover art
            if thumbnail_path and os.path.exists(thumbnail_path):
                with open(thumbnail_path, 'rb') as img:
                    audio.tags.add(
                        APIC(
                            encoding=3,
                            mime='image/jpeg',
                            type=3,  # Cover (front)
                            desc='Cover',
                            data=img.read()
                        )
                    )
            
            audio.save()
            print(f"{Fore.GREEN}âœ“ ÄÃ£ nhÃºng metadata cho: {Path(audio_path).name}")
            
        except ImportError:
            print(f"{Fore.YELLOW}âš ï¸  mutagen chÆ°a cÃ i Ä‘áº·t, bá» qua metadata")
        except Exception as e:
            print(f"{Fore.YELLOW}âš ï¸  Lá»—i khi nhÃºng metadata: {str(e)}")
    
    def batch_download_with_pagination(self, profile_name, directory, account_name, 
                                      max_songs_per_page=20, resume=False, 
                                      with_thumbnail=False, append_uuid=False,
                                      use_create_page: bool = False):
        """
        Batch download vá»›i há»— trá»£ pagination vÃ  resume
        
        Args:
            profile_name: TÃªn profile Ä‘á»ƒ download (VD: @username)
            directory: ThÆ° má»¥c lÆ°u file
            account_name: TÃªn account (Ä‘á»ƒ lÆ°u history)
            max_songs_per_page: Sá»‘ bÃ i tá»‘i Ä‘a má»—i trang (máº·c Ä‘á»‹nh 20)
            resume: Tiáº¿p tá»¥c tá»« trang Ä‘Ã£ lÆ°u (True/False)
            with_thumbnail: Download vÃ  nhÃºng thumbnail
            append_uuid: ThÃªm UUID vÃ o tÃªn file
        
        Returns:
            Dict chá»©a thá»‘ng kÃª download
        """
        # Load lá»‹ch sá»­
        history = self.load_download_history(account_name)
        downloaded_ids = set(history.get('downloaded_ids', []))
        
        # XÃ¡c Ä‘á»‹nh trang báº¯t Ä‘áº§u
        if resume and history.get('last_profile') == profile_name:
            start_page = history.get('current_page', 0)
            print(f"{Fore.CYAN}ðŸ”„ Tiáº¿p tá»¥c tá»« trang {start_page} (Ä‘Ã£ táº£i {len(downloaded_ids)} bÃ i)")
        else:
            start_page = 0
            if not resume:
                # Reset history náº¿u khÃ´ng resume
                downloaded_ids = set()
            print(f"{Fore.CYAN}ðŸ†• Báº¯t Ä‘áº§u má»›i tá»« trang 0")
        
        # Táº¡o thÆ° má»¥c
        Path(directory).mkdir(parents=True, exist_ok=True)
        
        total_success = 0
        total_fail = 0
        current_page = start_page
        
        print(f"\n{Fore.CYAN}{'='*70}")
        print(f"{Fore.CYAN}ðŸŽµ BATCH DOWNLOAD Tá»ª PROFILE: {profile_name}")
        print(f"{Fore.CYAN}{'='*70}\n")
        
        while True:
            print(f"\n{Fore.YELLOW}ðŸ“„ Äang xá»­ lÃ½ trang {current_page}...")
            
            # Fetch clips tá»« trang hiá»‡n táº¡i (chá»‰ láº¥y 1 trang)
            if use_create_page:
                # Fetch from /feed/v2 (create or /me context)
                # fetch_my_clips_paginated returns (clips_all, last_page, has_more)
                clips_all, last_page, has_more = self.fetch_my_clips_paginated(start_page=current_page, max_pages=1)
                clips = clips_all
            else:
                clips, last_page, has_more = self.fetch_profile_clips(
                    profile_name, 
                    start_page=current_page,
                    max_pages=1
                )
            
            if not clips:
                print(f"{Fore.GREEN}âœ… ÄÃ£ táº£i háº¿t táº¥t cáº£ bÃ i hÃ¡t!")
                break
            
            # Lá»c bá» cÃ¡c bÃ i Ä‘Ã£ download
            new_clips = [c for c in clips if c.get('id') not in downloaded_ids]
            
            if not new_clips:
                print(f"{Fore.YELLOW}âš ï¸  Trang {current_page}: Táº¥t cáº£ {len(clips)} bÃ i Ä‘Ã£ Ä‘Æ°á»£c táº£i")
                current_page += 1
                
                # Update history
                history['current_page'] = current_page
                history['last_profile'] = profile_name
                self.save_download_history(account_name, history)
                
                if not has_more:
                    print(f"{Fore.GREEN}âœ… ÄÃ£ háº¿t clips!")
                    break
                continue
            
            print(f"{Fore.CYAN}ðŸ“¥ Trang {current_page}: {len(new_clips)}/{len(clips)} bÃ i má»›i")
            
            # Download tá»«ng bÃ i
            page_success = 0
            page_fail = 0
            
            for idx, clip in enumerate(new_clips, 1):
                clip_id = clip.get('id')
                title = clip.get('title', 'Unknown')
                
                print(f"\n{Fore.CYAN}[{idx}/{len(new_clips)}] {title}")
                
                # Download audio
                audio_path = self.download_audio(clip, directory, append_uuid)
                
                if audio_path:
                    page_success += 1
                    total_success += 1
                    
                    # ThÃªm vÃ o downloaded_ids
                    downloaded_ids.add(clip_id)
                    
                    # Download thumbnail vÃ  nhÃºng metadata
                    if with_thumbnail:
                        thumbnail_path = self.download_thumbnail(clip, directory)
                        self.embed_metadata(audio_path, clip, thumbnail_path)
                        
                        # XÃ³a thumbnail file sau khi nhÃºng
                        if thumbnail_path and os.path.exists(thumbnail_path):
                            os.remove(thumbnail_path)
                else:
                    page_fail += 1
                    total_fail += 1
                
                # Äá»£i giá»¯a cÃ¡c downloads
                if idx < len(new_clips):
                    time.sleep(2)
                
                # Update history sau má»—i bÃ i thÃ nh cÃ´ng
                if audio_path:
                    history['downloaded_ids'] = list(downloaded_ids)
                    history['total_downloaded'] = len(downloaded_ids)
                    history['current_page'] = current_page
                    history['last_profile'] = profile_name
                    history['last_download'] = time.strftime('%Y-%m-%d %H:%M:%S')
                    self.save_download_history(account_name, history)
            
            print(f"\n{Fore.GREEN}âœ“ Trang {current_page}: ThÃ nh cÃ´ng {page_success}/{len(new_clips)}")
            
            # Chuyá»ƒn sang trang tiáº¿p theo
            current_page += 1
            
            # Update history trang
            history['current_page'] = current_page
            history['last_profile'] = profile_name
            self.save_download_history(account_name, history)
            
            # Kiá»ƒm tra cÃ²n trang ná»¯a khÃ´ng
            if not has_more:
                print(f"{Fore.GREEN}âœ… ÄÃ£ háº¿t clips!")
                break
            
            print(f"{Fore.YELLOW}âž¡ï¸  Chuyá»ƒn sang trang {current_page}...")
            time.sleep(3)  # Äá»£i trÆ°á»›c khi fetch trang má»›i
        
        print(f"\n{Fore.CYAN}{'='*70}")
        print(f"{Fore.GREEN}âœ… HOÃ€N Táº¤T!")
        print(f"{Fore.GREEN}   Tá»•ng thÃ nh cÃ´ng: {total_success}")
        print(f"{Fore.RED}   Tá»•ng tháº¥t báº¡i: {total_fail}")
        print(f"{Fore.CYAN}   Trang cuá»‘i: {current_page - 1}")
        print(f"{Fore.CYAN}   Tá»•ng Ä‘Ã£ táº£i: {len(downloaded_ids)} bÃ i")
        print(f"{Fore.CYAN}{'='*70}\n")
        
        return {
            'success': total_success,
            'failed': total_fail,
            'total_downloaded': len(downloaded_ids),
            'last_page': current_page - 1
        }
    
    def batch_download(self, clips, directory, with_thumbnail=False, append_uuid=False):
        """
        Batch download nhiá»u clips (phÆ°Æ¡ng thá»©c cÅ© - giá»¯ láº¡i Ä‘á»ƒ tÆ°Æ¡ng thÃ­ch)
        
        Args:
            clips: List cÃ¡c clip info
            directory: ThÆ° má»¥c lÆ°u file
            with_thumbnail: Download vÃ  nhÃºng thumbnail
            append_uuid: ThÃªm UUID vÃ o tÃªn file
        """
        # Táº¡o thÆ° má»¥c náº¿u chÆ°a cÃ³
        Path(directory).mkdir(parents=True, exist_ok=True)
        
        print(f"\n{Fore.CYAN}{'='*70}")
        print(f"{Fore.CYAN}ðŸŽµ Báº®T Äáº¦U DOWNLOAD {len(clips)} SONGS")
        print(f"{Fore.CYAN}{'='*70}\n")
        
        success_count = 0
        fail_count = 0
        
        for idx, clip in enumerate(clips, 1):
            title = clip.get('title', 'Unknown')
            print(f"\n{Fore.CYAN}[{idx}/{len(clips)}] {title}")
            
            # Download audio
            audio_path = self.download_audio(clip, directory, append_uuid)
            
            if audio_path:
                success_count += 1
                
                # Download thumbnail vÃ  nhÃºng metadata
                if with_thumbnail:
                    thumbnail_path = self.download_thumbnail(clip, directory)
                    self.embed_metadata(audio_path, clip, thumbnail_path)
                    
                    # XÃ³a thumbnail file sau khi nhÃºng
                    if thumbnail_path and os.path.exists(thumbnail_path):
                        os.remove(thumbnail_path)
            else:
                fail_count += 1
            
            # Äá»£i má»™t chÃºt giá»¯a cÃ¡c downloads
            if idx < len(clips):
                time.sleep(2)
        
        print(f"\n{Fore.CYAN}{'='*70}")
        print(f"{Fore.GREEN}âœ… ThÃ nh cÃ´ng: {success_count}")
        print(f"{Fore.RED}âŒ Tháº¥t báº¡i: {fail_count}")
        print(f"{Fore.CYAN}{'='*70}\n")


def main():
    """Test function - sáº½ Ä‘Æ°á»£c tÃ­ch há»£p vÃ o suno_multi_account.py"""
    print("Batch Downloader Test")
    print("Chá»©c nÄƒng nÃ y sáº½ Ä‘Æ°á»£c tÃ­ch há»£p vÃ o suno_multi_account.py")

if __name__ == "__main__":
    main()
</file>

<file path="log.txt">
Fetched 40 clips from pages 0 and 1

1. Snowfall On The Vinyl â€” ee0cced1-b3c2-43b3-b90a-a70183b5af54
2. Snowfall On The Vinyl â€” 581dab19-c027-412c-bce7-a31fdfa8fd61
3. Snowfall On The Vinyl â€” 12e3d714-e88d-4991-86bd-a9d7f2c4d5a0
4. Snowfall On The Vinyl â€” 14db0068-9bb3-4f18-8db3-a076c6d05eba
5. ðŸŽµ à¸ªà¸¸à¸”à¸—à¹‰à¸²à¸¢à¸‚à¸­à¸‡à¸„à¸£à¸´à¸ªà¸•à¹Œà¸¡à¸²à¸ª â€” d331186e-1f3e-4b48-b1b0-b9897787a374
6. ðŸŽµ à¸ªà¸¸à¸”à¸—à¹‰à¸²à¸¢à¸‚à¸­à¸‡à¸„à¸£à¸´à¸ªà¸•à¹Œà¸¡à¸²à¸ª â€” 24b3138e-d0b1-43fd-8361-6e5a990abcf1
7. UNBREAKABLE â€” 1a1cee54-0586-4e83-b9b7-1fb09cca713c
8. UNBREAKABLE â€” 23f7a7b2-1186-40f6-bf90-488d58d1d75e
9. Echoes Fade â€” 30925a4e-4805-4c9c-ae11-12ce99a03092
10. Echoes Fade â€” b8550f6d-c25c-4228-b0f8-ef9db82c1ed9
11. Snowfall On The Vinyl â€” 42fb3554-8b9e-4159-ae80-f73aa0856581
12. Snowfall On The Vinyl â€” 366f8129-5866-41e0-87db-277030161ba9
13. Roi toi luon â€” 32300929-bffa-4407-a836-af2f88793f0f
14. Roi toi luon â€” 013ef495-d11a-4501-b3db-1d434af417e8
15. Roi toi luon â€” f853b90c-d034-4485-85ad-9bdd4f5e89cb
16. Roi toi luon â€” 59c6cf2b-6982-4724-8dd7-4cc5d4c4fc2c
17. Roi toi lun â€” a0635dab-ce8d-495e-892f-2583ee9b1f9a
18. Roi toi lun â€” 6d6420e4-e56f-48ad-be42-db6968261c2a
19. 2025-11-08_06:31:07 â€” 214203a5-fefe-468c-9b68-91ffdc9f8752
20. Bek Sloy - Lee Yang (Instrumental) â€” a7ff375b-e1bf-4882-bd59-2ddc8b9b90c3
21. Bek Sloy - Lee Yang (Vocals) â€” 4c989b48-506d-4eea-8070-84f93d5af05f
22. Bek Sloy - Lee Yang (Instrumental) â€” 1e7ee0bb-1368-45f2-b286-14b32c3914aa
23. Bek Sloy - Lee Yang (Vocals) â€” 7720e1c1-fe78-40e2-a063-624fdf7f8a5a
24. Hoa No  (Instrumental) â€” 8e2f0ff9-a0cb-4868-9a6b-1b2bba727013
25. Hoa No  (Vocals) â€” 41a39021-56f8-4d40-8121-fd17cfa0dc64
26. Hoa No  (Instrumental) â€” 5c44c764-cfab-4d2f-ab4f-94dd5d65782d
27. Hoa No  (Vocals) â€” 5efe6f1a-e005-4d85-9349-4575c7fc5fee
28. Hoa No  (Cover) â€” b4dfbb4f-8898-4dec-9dad-9121de7a4bb5
29. Hoa No  (Cover) â€” 9e1b30d3-e1bb-4b44-b7ac-a53c62bbbcfb
30. Hoa No â€” 27b9c914-b826-45c8-adec-857c6aaf57b0
31. Hoa No â€” 99160759-fa25-4c3c-9123-bbaee3f7b087
32. Hoa No â€” 82b8bfce-c96a-4286-8646-1aa9e6b7c703
33. Hoa No â€” 5d2e85f9-33a8-46f2-9988-2e53d85ba565
34. Hoa No â€” 4dd00e9d-68b5-41f0-a652-49a01aec9cd4
35. Hoa No â€” b89937e2-ce30-4fc3-958f-aa00efa8ac5a
36. Hoa No â€” f460aaa1-f07b-4265-b2fa-fe6ec540cc08
37. cc â€” 7cff8765-fadb-4a06-aeda-27ef55d5e2d9
38. LUX â€” d09bdc6c-fee8-45e3-b9bc-abdafcf2f9a8
39. LUX â€” 287ce245-3ad7-49fb-9c74-5f65f5226d5c
40. Dove â€” 7bdc23ec-f3d4-44c4-959d-847ee72a676e
</file>

<file path="nul">
mkdir: cannot create directory â€˜.claudeâ€™: File exists
</file>

<file path="plan.txt">
Trong menu "Táº¡o Nhiá»u BÃ i", bá» Ã´ tÃ­ch chá»n Tá»± Ä‘á»™ng báº¥m Create, máº·c Ä‘á»‹nh sáº½ luÃ´n lÃ  tá»± Ä‘á»™ng Create.
Ã” Danh SÃ¡ch BÃ i HÃ¡t, chá»‰ hiá»‡n thá»‹ tÃªn bÃ i hÃ¡t thÃ´i, vÃ  ngÆ°á»i dÃ¹ng khÃ´ng cÃ³ quyá»n edit text trong Ã´ nÃ y.
ThÃªm tÃ­nh nÄƒng danh sÃ¡ch bÃ i hÃ¡t chá» táº¡o, nghÄ©a lÃ  khi ngÆ°á»i dÃ¹ng upload lÃªn 100 prompt, chá»n account 1, thÃªm Ã´ nháº­p tá»•ng sá»‘ bÃ i sáº½ táº¡o, ngÆ°á»i dÃ¹ng nháº­p lÃ  30 bÃ i, má»—i láº§n táº¡o lÃ  5 bÃ i. Báº¥m xÃ¡c nháº­n, thÃ¬ 30 bÃ i Ä‘Ã³ sáº½ vÃ o danh sÃ¡ch chá» táº¡o. Tiáº¿p theo ngÆ°á»i dÃ¹ng chá»n account 2, cÅ©ng sáº½ nháº­p tá»•ng sá»‘ bÃ i muá»‘n táº¡o lÃ  30 bÃ i, má»—i láº§n táº¡o 6 bÃ i. Báº¥m xÃ¡c nháº­n vÃ o danh sÃ¡ch chá». NgÆ°á»i dÃ¹ng chá»n account 3, chá»n tá»•ng sá»‘ bÃ i 40 bÃ i, thÃªm vÃ o hÃ ng chá». Sáº½ cÃ³ bá»™ Ä‘áº¿m sá»‘ bÃ i sao cho khÃ´ng vÆ°á»£t quÃ¡ sá»‘ bÃ i Ä‘Ã£ táº£i lÃªn tá»« prompt.
Sáº½ cÃ³ list danh sÃ¡ch bÃ i hÃ¡t, vÃ  pháº§n tÃ­ch chá»n cÃ¡c bÃ i sáº½ táº¡o, vÃ  tÃ­ch all táº¡o táº¥t cáº£ láº§n lÆ°á»£t.
TÃ­ch chá»n xong thÃ¬ nÃºt báº¯t Ä‘áº§u má»›i sÃ¡ng lÃªn Ä‘á»ƒ ngÆ°á»i dÃ¹ng chá»n.
Sáº½ cÃ³ log hiá»ƒn thá»‹, bÃ i nÃ o Ä‘Ã£ táº¡o thÃ nh cÃ´ng, khÃ´ng thÃ nh cÃ´ng. BÃ i nÃ o táº¡o thÃ nh cÃ´ng sáº½ cÃ³ tÃ­ch icon hiá»ƒn thá»‹ thÃ nh cÃ´ng, vÃ  sáº½ Ä‘Æ°á»£c lÆ°u láº¡i luÃ´n id cá»§a bÃ i Ä‘Ã³ vÃ o menu lá»‹ch sá»­ táº¡o bÃ i hÃ¡t (táº¡o thÃªm tab xem lá»‹ch sá»­ táº¡o bÃ i hÃ¡t)
tab lá»‹ch sá»­ down load sáº½ sá»­a láº¡i thÃ nh tÃªn Lá»‹ch sá»­ download cho dá»… phÃ¢n biá»‡t.
chá»‰ khi nÃ o káº¿t thÃºc táº¡o táº¥t cáº£ bÃ i hÃ¡t hoáº·c user báº¥m dá»«ng hoáº·c user táº¯t app hoáº·c tab Ä‘Ã³ Ä‘Ã£ táº¡o Ä‘Æ°á»£c 10 bÃ i thÃ¬ browser má»›i Ä‘Ã³ng, bá» lá»±a chá»n giá»¯ browser má»Ÿ 30s Ä‘i.
má»—i tab browser má»Ÿ lÃªn sáº½ táº¡o Ä‘Æ°á»£c 10 bÃ i láº§n lÆ°á»£t rá»“i má»›i táº¯t Ä‘i, chá»© khÃ´ng pháº£i táº¡o Ä‘Æ°á»£c 1 bÃ i rá»“i táº¯t nhÆ° hiá»‡n nay
App sáº½ lÆ°u láº¡i lá»‹ch sá»­ táº¡o bÃ i hÃ¡t, prompt, danh sÃ¡ch bÃ i hÃ¡t. Khi user má»Ÿ láº¡i app, sáº½ cÃ³ thá»ƒ báº¯t Ä‘áº§u táº¡o tiáº¿p tá»« láº§n trÆ°á»›c.
</file>

<file path="requirements.txt">
selenium>=4.15.0
requests>=2.31.0
webdriver-manager>=4.0.1
colorama>=0.4.6
mutagen>=1.47.0
customtkinter>=5.2.0
</file>

<file path="scripts/smoke_check_app.py">
"""
Smoke test script: launch app.py, wait briefly for the app logger to emit
"Application started", then terminate the process.

This is a lightweight headless-friendly smoke check: it looks for the
log entry written by `src.utils.logger.logger` and also watches stdout.

Exit codes:
 - 0: success (Application started detected)
 - 2: failure (not detected)
"""
from __future__ import annotations
import subprocess
import sys
import time
from pathlib import Path
import datetime

REPO_ROOT = Path(__file__).resolve().parents[1]
APP_PY = REPO_ROOT / "app.py"
LOG_DIR = REPO_ROOT / "logs"
LOG_FILE = LOG_DIR / f"app_{datetime.date.today().strftime('%Y%m%d')}.log"

TIMEOUT_SECONDS = 15


def run_smoke():
    if not APP_PY.exists():
        print(f"ERROR: {APP_PY} not found")
        return 2

    # Start the app as subprocess
    proc = subprocess.Popen(
        [sys.executable, str(APP_PY)],
        cwd=str(REPO_ROOT),
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True,
        bufsize=1,
    )

    deadline = time.time() + TIMEOUT_SECONDS
    found = False

    try:
        # Poll stdout and log file for the marker
        while time.time() < deadline:
            # Check stdout if available
            if proc.stdout:
                try:
                    # Non-blocking readline; if empty, continue
                    line = proc.stdout.readline()
                except Exception:
                    line = ""
                if line:
                    print(f"[app stdout] {line.strip()}")
                    if "Application started" in line:
                        found = True
                        break

            # Check log file
            if LOG_FILE.exists():
                try:
                    txt = LOG_FILE.read_text(encoding='utf-8', errors='ignore')
                    if "Application started" in txt:
                        found = True
                        break
                except Exception:
                    pass

            time.sleep(0.3)
    finally:
        # Terminate the app process
        try:
            proc.terminate()
            proc.wait(timeout=5)
        except Exception:
            try:
                proc.kill()
            except Exception:
                pass

    if found:
        print("SMOKE OK: Application started detected")
        return 0
    else:
        print("SMOKE FAIL: Application started not detected")
        return 2


if __name__ == '__main__':
    sys.exit(run_smoke())
</file>

<file path="src/__init__.py">
"""
Suno Account Manager - Source Package
"""
__version__ = "2.0.0"
</file>

<file path="src/core/__init__.py">
"""
Core package
"""
from importlib import import_module

__all__ = [
    'AccountManager',
    'SessionManager',
    'DownloadManager',
    'QueueManager',
    'SongCreationHistoryManager'
]


def __getattr__(name: str):
    if name in __all__:
        module_name = "".join(
            f"_{ch.lower()}" if ch.isupper() else ch
            for ch in name
        ).lstrip("_")
        module = import_module(f".{module_name}", __name__)
        return getattr(module, name)
    raise AttributeError(f"module {__name__} has no attribute {name}")
</file>

<file path="src/core/account_manager.py">
"""
Account Manager - Manages Suno accounts
"""
import shutil
from typing import Dict, List, Optional
from datetime import datetime
from pathlib import Path

from config.settings import ACCOUNTS_FILE, PROFILES_DIR
from src.models import Account
from src.utils import load_json, save_json, logger


class AccountManager:
    """Manages Suno accounts and their metadata"""
    
    def __init__(self):
        self.accounts: Dict[str, Account] = {}
        self.load_accounts()
    
    def load_accounts(self) -> None:
        """Load account list from JSON file"""
        data = load_json(ACCOUNTS_FILE, {})
        self.accounts = {}
        for name, info in data.items():
            # Add name to info dict
            info['name'] = name
            self.accounts[name] = Account.from_dict(info)
        logger.info(f"Loaded {len(self.accounts)} accounts")
    
    def save_accounts(self) -> bool:
        """Save account list to JSON file"""
        data = {}
        for name, account in self.accounts.items():
            account_dict = account.to_dict()
            # Remove name from dict since it's the key
            account_dict.pop('name', None)
            data[name] = account_dict
        
        if save_json(ACCOUNTS_FILE, data):
            logger.info("Accounts saved successfully")
            return True
        return False
    
    def add_account(self, name: str, email: str) -> bool:
        """Add new account"""
        if name in self.accounts:
            logger.warning(f"Account {name} already exists")
            return False
        
        account = Account(
            name=name,
            email=email,
            created_at=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            status="active"
        )
        
        self.accounts[name] = account
        self.save_accounts()
        logger.info(f"Added account: {name}")
        return True
    
    def get_account(self, name: str) -> Optional[Account]:
        """Get account information"""
        return self.accounts.get(name)
    
    def update_account(self, name: str, **kwargs) -> bool:
        """Update account information"""
        if name not in self.accounts:
            return False
        
        account = self.accounts[name]
        for key, value in kwargs.items():
            if hasattr(account, key):
                setattr(account, key, value)
        
        self.save_accounts()
        logger.info(f"Updated account: {name}")
        return True
    
    def rename_account(self, old_name: str, new_name: str) -> bool:
        """Rename account"""
        if old_name not in self.accounts:
            logger.warning(f"Account {old_name} not found")
            return False
        
        if new_name in self.accounts:
            logger.warning(f"Account {new_name} already exists")
            return False
        
        # Rename profile directory
        old_profile = PROFILES_DIR / old_name
        new_profile = PROFILES_DIR / new_name
        
        if old_profile.exists():
            try:
                old_profile.rename(new_profile)
            except Exception as e:
                logger.error(f"Failed to rename profile: {e}")
                return False
        
        # Update account
        account = self.accounts.pop(old_name)
        account.name = new_name
        self.accounts[new_name] = account
        
        self.save_accounts()
        logger.info(f"Renamed account: {old_name} -> {new_name}")
        return True
    
    def delete_account(self, name: str, delete_profile: bool = False) -> bool:
        """Delete account"""
        if name not in self.accounts:
            return False
        
        # Delete from accounts
        del self.accounts[name]
        self.save_accounts()
        
        # Delete profile if requested
        if delete_profile:
            profile_dir = PROFILES_DIR / name
            if profile_dir.exists():
                try:
                    shutil.rmtree(profile_dir)
                    logger.info(f"Deleted profile for {name}")
                except Exception as e:
                    logger.error(f"Failed to delete profile: {e}")
        
        logger.info(f"Deleted account: {name}")
        return True
    
    def get_all_accounts(self) -> List[Account]:
        """Get all accounts"""
        return list(self.accounts.values())
    
    def update_last_used(self, name: str) -> None:
        """Update last used timestamp"""
        if name in self.accounts:
            self.accounts[name].last_used = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            self.save_accounts()
    
    def get_profile_path(self, name: str) -> Optional[Path]:
        """Get account profile path"""
        if name not in self.accounts:
            return None
        
        profile_path = PROFILES_DIR / name
        return profile_path if profile_path.exists() else None
</file>

<file path="src/core/AGENTS.md">
# AGENTS.md

**Audience:** AI coding agents, developers working on business logic  
**Applies to:** `src/core/**/*.py`  
**Scope:** Manager lifecycle, session patterns, queue workflows, API integration, browser automation  
**Last reviewed:** 2025-11-10  
**Owners:** Core team, backend developers

---

## Architecture Overview

### Clean Architecture Layers

Core layer sits between UI (presentation) and Models (domain):

```
UI Layer (src/ui/) 
    â†“ depends on
Core Layer (src/core/) â† YOU ARE HERE
    â†“ depends on
Models Layer (src/models/)
    â†“ uses
Utils Layer (src/utils/)
```

**Critical Rule**: Core NEVER imports from UI. Core provides interfaces (callbacks) that UI implements.

### Component Map

| Manager | Responsibility | Key Dependencies |
|---------|---------------|------------------|
| `AccountManager` | CRUD for accounts, JSON persistence | Models (Account), Utils (helpers) |
| `SessionManager` | Chrome profile launch, token extraction | Utils (stealth_driver), Config (PROFILES_DIR) |
| `QueueManager` | Queue CRUD, state persistence | Models (QueueEntry), Config (QUEUE_STATE_FILE) |
| `BatchSongCreator` | Multi-queue execution engine | SessionManager, SunoFormFiller, SunoApiClient |
| `DownloadManager` | Download orchestration, history | SessionManager, SunoApiClient, Utils (file_downloader) |
| `SongCreationHistoryManager` | Creation history, CSV export | Models (SongCreationRecord), Config (SONG_CREATION_HISTORY_FILE) |

---

## Manager Lifecycle

### Singleton Pattern

**All managers are created once** in `MainWindow.__init__()` and **injected into panels**.

```python
# âœ… CORRECT: Create in MainWindow
class MainWindow(ctk.CTk):
    def __init__(self):
        self.account_manager = AccountManager()
        self.session_manager = SessionManager()
        self.queue_manager = QueueManager()
        
        # Inject into panels
        self.account_panel = AccountPanel(
            parent=content_frame,
            account_manager=self.account_manager,
            session_manager=self.session_manager
        )

# âŒ WRONG: Never create inside panels
class AccountPanel(ctk.CTkFrame):
    def __init__(self, parent):
        self.account_manager = AccountManager()  # Creates duplicate instance!
```

**Why singleton-like?**
- Managers hold shared state (accounts dict, queues dict)
- Multiple instances cause state divergence
- Testability: inject mock managers in tests

### Constructor Patterns

```python
class YourManager:
    def __init__(self):
        """
        Managers initialize in __init__:
        1. Load persisted state from JSON
        2. Initialize empty collections
        3. Set up logging
        
        Do NOT:
        - Launch browsers (lazy on-demand)
        - Make network calls (lazy on-demand)
        - Create heavy resources
        """
        self.data = self._load_state()
        self.logger = Logger()
```

---

## Session Patterns

### Chrome Profile Management

**Why profiles?** Suno uses Clerk.com auth with critical data in `localStorage` (not just cookies).

```
profiles/{account_name}/
â””â”€â”€ Default/
    â”œâ”€â”€ Cookies              # __session JWT token
    â”œâ”€â”€ Local Storage/       # __clerk_environment (CRITICAL!)
    â””â”€â”€ Preferences          # Chrome settings
```

### Token Extraction

```python
# session_manager.py pattern
def get_session_token_from_me_page(self, account_name: str) -> Tuple[str, webdriver.Chrome]:
    """
    1. Launch Chrome with --user-data-dir=profiles/{account_name}
    2. Navigate to suno.com/me
    3. Wait 3s for cookies to load
    4. Extract __session cookie
    5. Return (token, driver) â† IMPORTANT: Keep driver open!
    
    Why keep driver open?
    - Session stays valid while browser open
    - User may need to re-login if CAPTCHA
    - Caller responsible for closing driver
    """
    profile_path = PROFILES_DIR / account_name
    driver = create_stealth_driver(profile_path, headless=False)
    driver.get(f"{SUNO_URL}/me")
    time.sleep(3)
    
    cookies = driver.get_cookies()
    for cookie in cookies:
        if cookie['name'] == '__session':
            return cookie['value'], driver
    
    raise SessionTokenError(f"No __session cookie for {account_name}")
```

### Anti-Detection (Stealth Driver)

See `src/utils/stealth_driver.py` for implementation. Core principles:

1. **Hide navigator.webdriver** via CDP injection
2. **Mock plugins/languages** to look like real browser
3. **Rotate User-Agents** (Chrome 129-131)
4. **Human delays**: `random.uniform(3.0, 5.0)` seconds between actions
5. **Manual submit default**: Let user click "Create" button (avoid bot detection)

**Usage Pattern:**
```python
from src.utils.stealth_driver import create_stealth_driver, add_human_delays

driver = create_stealth_driver(profile_path, headless=False)
# Fill form...
time.sleep(add_human_delays())  # 3-5s random delay
# Next action...
```

---

## Queue Workflows

### State Machine

```
pending â†’ running â†’ completed
   â†“         â†“          â†‘
   â†“      paused    â”€â”€â”€â”€â”˜
   â†“         â†“
   â””â”€â”€â†’ cancelled
```

**Rules:**
- Never skip states (e.g., pending â†’ completed directly)
- Save state after EVERY transition
- Progress tracked: `songs_completed / total_songs`

### Queue Persistence

```python
# queue_manager.py pattern
def add_queue_entry(self, account_name: str, song_count: int, batch_size: int, prompts: List[SunoPrompt]) -> str:
    """
    Validation order:
    1. prompts available >= song_count
    2. batch_size in [1, 10]
    3. account exists in AccountManager
    4. No duplicate queue_id
    
    Then:
    1. Create QueueEntry
    2. Add to self.queues dict
    3. self._save_state() â† CRITICAL: Immediate save!
    4. Update prompt_cursor
    5. Return queue_id
    """
    # Validation...
    entry = QueueEntry(...)
    self.queues[queue_id] = entry
    self._save_state()  # Atomic write to queue_state.json
    return queue_id

def _save_state(self):
    """
    Always use atomic write:
    1. Write to temp file
    2. Rename to replace original
    3. Prevents corruption on crash
    """
    atomic_write_json(QUEUE_STATE_FILE, {
        "version": "1.0",
        "prompts": [p.to_dict() for p in self.prompts],
        "prompt_cursor": self.prompt_cursor,
        "queues": [q.to_dict() for q in self.queues.values()]
    })
```

### Batch Execution Engine

See `batch_song_creator.py` for full implementation. Key patterns:

```python
def execute_queues(self, queues: List[QueueEntry], progress_callback: Callable):
    """
    For each queue:
      1. Split into batches (e.g., 30 songs, batch_size=5 â†’ 6 batches)
      2. For each batch:
         a. Open Chrome with profile
         b. Create N tabs (N = batch_size)
         c. For each tab:
            - Fill form with 3-5s delays
            - Wait for user to click Create (or auto-click)
            - Extract song URLs
            - Save to history
            - Update queue progress
            - Call progress_callback(queue_id, batch, song, "success", msg)
         d. Close tabs after 10 songs (memory cleanup)
      3. Mark queue completed
      4. Save state
    
    Error handling:
    - If 1 song fails â†’ log error, continue with rest
    - If browser crashes â†’ mark queue failed, save state
    - Always call progress_callback with status
    """
```

**Progress Callback Signature** (DO NOT change):
```python
def callback(
    queue_id: str,
    batch_num: int,
    song_num: int,
    status: str,  # "creating" | "success" | "error"
    message: str
) -> None:
    pass
```

---

## API Integration

### Suno API Client

```python
# suno_api_client.py pattern
class SunoApiClient:
    def __init__(self, session_token: str):
        """
        Always require session_token in constructor.
        Never store profiles or launch browsers here.
        """
        self.token = session_token
        self.headers = {
            "Authorization": f"Bearer {session_token}",
            "Content-Type": "application/json"
        }
    
    def fetch_clips(self, page: int = 0) -> List[dict]:
        """
        Paginated API: /api/feed/v2?page=N
        Returns 20 clips per page.
        
        Handle:
        - 401 Unauthorized â†’ raise SessionTokenError
        - 429 Rate limit â†’ retry with exponential backoff
        - Network errors â†’ retry RETRY_ATTEMPTS times
        """
        url = f"{SUNO_API_URL}/feed/v2"
        response = requests.get(url, headers=self.headers, params={"page": page})
        response.raise_for_status()
        return response.json()
```

### Form Automation

React controlled inputs require special handling:

```python
# suno_form_automation.py pattern
class SunoFormFiller:
    def fill_lyrics(self, driver: webdriver.Chrome, lyrics: str):
        """
        React inputs ignore send_keys()!
        Use native setter + synthetic events:
        """
        lyrics_input = driver.find_element(By.CSS_SELECTOR, "textarea[placeholder*='lyrics']")
        driver.execute_script("""
            const input = arguments[0];
            const value = arguments[1];
            
            // Get native setter
            const nativeSetter = Object.getOwnPropertyDescriptor(
                window.HTMLTextAreaElement.prototype, 'value'
            ).set;
            
            // Call native setter (bypasses React)
            nativeSetter.call(input, value);
            
            // Dispatch events React listens for
            input.dispatchEvent(new Event('input', { bubbles: true }));
            input.dispatchEvent(new Event('change', { bubbles: true }));
        """, lyrics_input, lyrics)
        
        time.sleep(add_human_delays())  # 3-5s delay
```

---

## Browser Automation

### Profile Lock Error

**Problem**: Chrome crashes with "Chrome instance exited" if profile already in use.

```python
# session_manager.py pattern
def launch_browser(self, account_name: str) -> Optional[webdriver.Chrome]:
    try:
        driver = create_stealth_driver(profile_path, headless=False)
        return driver
    except Exception as e:
        if "Chrome instance exited" in str(e):
            # Profile locked by another Chrome window
            logger.error(f"Profile {account_name} is locked")
            # UI should show: "ÄÃ³ng táº¥t cáº£ cá»­a sá»• Chrome vÃ  thá»­ láº¡i"
            return None
        raise
```

**Fix**: Close ALL Chrome windows before launching with same profile.

### Tab Management

```python
# batch_song_creator.py pattern
def create_batch_tabs(self, driver: webdriver.Chrome, batch_size: int):
    """
    Memory optimization:
    - Close tabs after every 10 songs
    - Reopen fresh tabs for next batch
    - Prevents Chrome memory bloat (5GB+ after 50 tabs)
    """
    tabs = []
    for i in range(batch_size):
        if i == 0:
            tabs.append(driver.current_window_handle)
        else:
            driver.execute_script("window.open('');")
            tabs.append(driver.window_handles[-1])
    return tabs
```

---

## Data Models

Models live in `src/models/data_models.py` but documented here for context.

### Account Model

```python
@dataclass
class Account:
    name: str
    email: str
    created_at: str
    last_used: str
    status: str = "active"
    
    # JSON pattern: name is KEY, not in value
    # See config/AGENTS.md#json-persistence
```

### QueueEntry Model

```python
@dataclass
class QueueEntry:
    id: str
    account_name: str
    total_songs: int
    batch_size: int
    songs_completed: int = 0
    status: str = "pending"  # pending|running|paused|completed|failed|cancelled
    progress_percent: float = 0.0
    created_at: str = field(default_factory=lambda: datetime.now().isoformat())
    started_at: Optional[str] = None
    completed_at: Optional[str] = None
    current_batch: int = 0
```

---

## Logging

Use shared Logger singleton:

```python
from src.utils.logger import logger

class YourManager:
    def some_method(self):
        logger.info("Operation started")
        try:
            # Work...
            logger.debug(f"Processed {count} items")
        except Exception as e:
            logger.error(f"Operation failed: {e}", exc_info=True)
```

**Log Levels:**
- `DEBUG`: Verbose details (API responses, state dumps)
- `INFO`: Normal flow (queue started, download completed)
- `WARNING`: Recoverable issues (retry after timeout)
- `ERROR`: Failures requiring attention (session expired, validation failed)

Logs write to `logs/app_YYYYMMDD.log`.

---

## Prompt Templates

XML templates in `src/prompt/` folder (e.g., `default-prompt.xml`):

```xml
<PROMPTS>
  <PROMPT>
    <TITLE>Song Title</TITLE>
    <LYRICS>
Verse 1 lyrics...
Chorus...
    </LYRICS>
    <STYLE>Pop, upbeat, 80s</STYLE>
  </PROMPT>
</PROMPTS>
```

**Parsing:** Use `SunoPromptParser` from `src/utils/prompt_parser.py`.

```python
from src.utils.prompt_parser import SunoPromptParser

parser = SunoPromptParser()
prompts = parser.parse_file("prompts/my-batch.xml")  # Returns List[SunoPrompt]
```

---

## Testing Patterns

Mock managers in tests:

```python
from unittest.mock import MagicMock, patch

@patch('src.core.batch_song_creator.webdriver.Chrome')
def test_song_creation(mock_chrome):
    mock_driver = MagicMock()
    mock_chrome.return_value = mock_driver
    
    # Test without launching real browser
    creator = BatchSongCreator(session_manager=mock_session, queue_manager=mock_queue)
    creator.execute_queues([queue], callback=lambda *args: None)
    
    assert mock_driver.get.called
```

See `tests/AGENTS.md#mocking-patterns` for comprehensive guide.

---

## Entry Points

| File | Primary Class/Function | Purpose |
|------|----------------------|---------|
| `account_manager.py` | `AccountManager` | Account CRUD, JSON persistence |
| `session_manager.py` | `SessionManager` | Chrome launch, token extraction |
| `queue_manager.py` | `QueueManager` | Queue CRUD, state persistence |
| `batch_song_creator.py` | `BatchSongCreator` | Multi-queue execution engine |
| `download_manager.py` | `DownloadManager` | Download orchestration |
| `song_creation_history_manager.py` | `SongCreationHistoryManager` | History tracking, CSV export |
| `suno_api_client.py` | `SunoApiClient` | API wrapper |
| `suno_form_automation.py` | `SunoFormFiller`, `SunoPersonaSelector`, `SunoModeSelector`, `SunoAdvancedOptionsConfigurator` | Form automation helpers |

---

## Cross-References

- **UI integration**: See `src/ui/AGENTS.md#panel-patterns`
- **Configuration**: See `config/AGENTS.md#path-constants`
- **Testing**: See `tests/AGENTS.md#mocking-patterns`
- **Architecture diagrams**: See `memory-bank/FLOW_DIAGRAMS.md#system-architecture`

---

**Questions?** Check root `AGENTS.md` for general guidelines or Memory Bank for design rationale.
</file>

<file path="src/core/batch_song_creator.py">
"""
Batch Song Creator - Business logic táº¡o nhiá»u bÃ i hÃ¡t
"""
import time
import math
import random
from typing import List, Callable, Dict, Any, Optional
from pathlib import Path

from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.action_chains import ActionChains
from selenium.common.exceptions import TimeoutException

from src.utils.prompt_parser import SunoPrompt
from src.ui.components.suno_selectors import SunoSelectors
from src.utils import logger
from src.utils.stealth_driver import add_human_delays, create_stealth_driver
from src.models import SongCreationRecord
from src.core.song_creation_history_manager import SongCreationHistoryManager


class BatchSongCreator:
    """
    Business logic táº¡o nhiá»u bÃ i hÃ¡t cÃ¹ng lÃºc
    
    Features:
    - Má»Ÿ nhiá»u tabs Chrome
    - Fill form song song
    - Apply advanced options
    - Auto-submit (optional)
    - Progress callback
    """
    
    def __init__(self, profile_path: Path):
        """
        Args:
            profile_path: ÄÆ°á»ng dáº«n Ä‘áº¿n Chrome profile
        """
        self.profile_path = profile_path
        self.driver = None
    
    def create_songs_batch(
        self,
        prompts: List[SunoPrompt],
        songs_per_session: int,
        advanced_options: Dict[str, Any],
        auto_submit: bool,
        progress_callback: Callable[[str, int, Optional[str], str, str], None],
        account_name: str | None = None,
        history_manager: SongCreationHistoryManager | None = None
    ) -> List[Dict[str, Any]]:
        """
        Táº¡o nhiá»u bÃ i hÃ¡t theo batch
        
        Args:
            prompts: List of SunoPrompt
            batch_size: Sá»‘ bÃ i má»—i batch
            advanced_options: Dict chá»©a advanced settings
            keep_browser: Giá»¯ browser má»Ÿ 30s sau khi xong
            auto_submit: Tá»± Ä‘á»™ng báº¥m Create (cÃ³ thá»ƒ gáº·p CAPTCHA)
            progress_callback: Callback(message, progress_percent)
        
        Returns:
            List of {title, success, error}
        """
        results: List[Dict[str, Any]] = []
        if not prompts:
            return results

        progress_callback = progress_callback or (lambda *_: None)
        session_size = max(1, songs_per_session)
        total_songs = len(prompts)
        session_count = (total_songs + session_size - 1) // session_size

        completed_songs = 0

        try:
            self._initialize_driver()
            for session_index in range(session_count):
                start_idx = session_index * session_size
                session_prompts = prompts[start_idx:start_idx + session_size]
                logger.info(f"â³ Session {session_index + 1}/{session_count} contains {len(session_prompts)} prompts")

                try:
                    session_results = self._run_session(
                        session_prompts,
                        advanced_options,
                        auto_submit,
                        progress_callback,
                        session_index,
                        session_count,
                        completed_songs,
                        total_songs,
                        account_name=account_name,
                        history_manager=history_manager
                    )
                    results.extend(session_results)
                except Exception as exc:
                    logger.error(f"âŒ Session error: {exc}")
                    results.append({'title': 'SESSION ERROR', 'success': False, 'error': str(exc)})
                finally:
                    completed_songs += len(session_prompts)
        finally:
            self._teardown_driver()

        progress_callback("âœ… HoÃ n thÃ nh!", 100, None, "complete", "Batch finished")
        return results

    def _initialize_driver(self) -> None:
        if self.driver:
            self.driver.quit()
        self.driver = create_stealth_driver(self.profile_path, headless=False)

    def _teardown_driver(self) -> None:
        if self.driver:
            self.driver.quit()
            self.driver = None

    def _run_session(
        self,
        prompts: List[SunoPrompt],
        advanced_options: Dict[str, Any],
        auto_submit: bool,
        progress_callback: Callable[[str, int, Optional[str], str, str], None],
        session_index: int,
        session_count: int,
        completed_before_session: int,
        total_songs: int,
        account_name: str | None = None,
        history_manager: SongCreationHistoryManager | None = None
    ) -> List[Dict[str, Any]]:
        if not self.driver:
            return []

        results: List[Dict[str, Any]] = []
        self.driver.get("https://suno.com/create")
        for _ in range(1, len(prompts)):
            self.driver.execute_script("window.open('https://suno.com/create', '_blank');")
            time.sleep(0.5)

        tabs = self.driver.window_handles

        for prompt_index, prompt in enumerate(prompts):
            tab_handle = tabs[prompt_index]
            progress_percent = min(
                100,
                int(((completed_before_session + prompt_index + 1) / total_songs) * 100)
            )
            message = (
                f"âœï¸ Session {session_index + 1}/{session_count} - "
                f"BÃ i {prompt_index + 1}/{len(prompts)}: {prompt.title}"
            )

            success = self._fill_song_form(prompt, tab_handle, advanced_options, prompt_index + 1)
            song_id: Optional[str] = None
            error_message: Optional[str] = None
            status_label = "success"

            if success:
                if auto_submit:
                    try:
                        delay = random.uniform(2, 5)
                        logger.info(f"â³ Tab {prompt_index + 1}: Ä‘á»£i {delay:.2f}s trÆ°á»›c khi submit")
                        time.sleep(delay)
                        song_id = self._submit_and_get_id(tab_handle)
                        logger.info(f"âœ… Song created (auto) tab {prompt_index + 1}: {song_id}")
                    except TimeoutException:
                        status_label = "pending"
                        error_message = "ÄÃ£ gá»­i yÃªu cáº§u â€“ chá» ID"
                        logger.info(f"â³ Song pending (tab {prompt_index + 1}) - waiting for ID")
                    except Exception as exc:
                        logger.error(f"âŒ Auto-submit failed: {exc}")
                        success = False
                        status_label = "failed"
                        error_message = str(exc)
                else:
                    status_label = "pending"
                    logger.info(f"â„¹ï¸ Tab {prompt_index + 1} ready for manual submit")
            else:
                status_label = "failed"
                error_message = "Fill form failed"

            results.append({
                'title': prompt.title,
                'success': success,
                'pending': status_label == "pending",
                'error': None if success else error_message
            })

            self._record_history_entry(
                history_manager,
                account_name,
                prompt,
                completed_before_session + prompt_index + 1,
                song_id,
                status_label,
                error_message
            )

            progress_callback(message, progress_percent, song_id, status_label, prompt.title)
            time.sleep(3)

        return results

    def _record_history_entry(
        self,
        history_manager: SongCreationHistoryManager | None,
        account_name: str | None,
        prompt: SunoPrompt,
        prompt_index: int,
        song_id: str | None,
        status_label: str,
        error_message: Optional[str]
    ) -> None:
        if not history_manager:
            return

        record = SongCreationRecord(
            song_id=song_id or "",
            title=prompt.title,
            prompt_index=prompt_index,
            account_name=account_name or self.profile_path.name,
            status=status_label,
            error_message=error_message
        )
        history_manager.add_creation_record(record)

    def _submit_and_get_id(self, tab_handle: str) -> str:
        if not self.driver:
            raise RuntimeError("WebDriver is not initialized")
        self.driver.switch_to.window(tab_handle)
        create_btn = self.driver.find_element(By.XPATH, SunoSelectors.CREATE_BUTTON)
        create_btn.click()
        WebDriverWait(self.driver, 20).until(
            EC.url_contains("/song/")
        )
        return self._extract_song_id(self.driver.current_url)

    def _extract_song_id(self, url: str) -> str:
        parsed = url.rstrip("/").split("/")
        return parsed[-1] if parsed else ""
    
    def _fill_song_form(
        self,
        prompt: SunoPrompt,
        tab_handle: str,
        advanced_options: Dict[str, Any],
        tab_index: int
    ) -> bool:
        """Fill form cho 1 bÃ i hÃ¡t"""
        try:
            add_human_delays()
            self.driver.switch_to.window(tab_handle)

            lyrics_inputs = self.driver.find_elements(By.XPATH, SunoSelectors.LYRICS_TEXTAREA)
            if not lyrics_inputs:
                custom_btn = WebDriverWait(self.driver, 5).until(
                    EC.element_to_be_clickable((By.XPATH, SunoSelectors.CUSTOM_BUTTON))
                )
                custom_btn.click()
                time.sleep(2)

            add_human_delays()
            lyrics_box = WebDriverWait(self.driver, 5).until(
                EC.element_to_be_clickable((By.XPATH, SunoSelectors.LYRICS_TEXTAREA))
            )
            lyrics_box.clear()
            lyrics_box.send_keys(prompt.lyrics)

            add_human_delays()
            styles_box = WebDriverWait(self.driver, 5).until(
                EC.element_to_be_clickable((By.XPATH, SunoSelectors.STYLES_TEXTAREA))
            )
            styles_box.clear()
            styles_box.send_keys(prompt.style)

            add_human_delays()
            title_filled = False
            try:
                title_box = WebDriverWait(self.driver, 3).until(
                    EC.element_to_be_clickable((By.XPATH, SunoSelectors.TITLE_INPUT))
                )
                title_box.clear()
                title_box.send_keys(prompt.title)
                title_filled = True
            except Exception:
                try:
                    title_box = WebDriverWait(self.driver, 2).until(
                        EC.element_to_be_clickable(
                            (By.XPATH, SunoSelectors.TITLE_INPUT_BY_LABEL)
                        )
                    )
                    title_box.click()
                    time.sleep(0.2)
                    title_box.clear()
                    title_box.send_keys(prompt.title)
                    title_filled = True
                except Exception:
                    pass

            if not title_filled:
                try:
                    js = """
                    const els = Array.from(document.querySelectorAll('input[placeholder="Song Title (Optional)"]'));
                    const el = els.find(e => e && e.offsetParent !== null && getComputedStyle(e).visibility !== 'hidden');
                    if(!el) return {ok:false, reason:'not-found-visible'};
                    el.scrollIntoView({block:'center'});
                    el.focus();
                    const setter = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, 'value').set;
                    setter.call(el, '');
                    el.dispatchEvent(new Event('input', {bubbles:true}));
                    setter.call(el, arguments[0]);
                    el.dispatchEvent(new Event('input', {bubbles:true}));
                    el.dispatchEvent(new Event('change', {bubbles:true}));
                    return {ok: el.value === arguments[0], value: el.value};
                    """
                    res = self.driver.execute_script(js, prompt.title)
                    if res and res.get('ok'):
                        title_filled = True
                        logger.info(f"TAB {tab_index}: JS fallback Title OK â†’ '{res.get('value')}'")
                    else:
                        logger.warning(f"TAB {tab_index}: JS fallback Title fail: {res}")
                except Exception as e:
                    logger.warning(f"TAB {tab_index}: JS fallback Title exception: {e}")

            if not title_filled:
                logger.warning(f"TAB {tab_index}: KhÃ´ng tÃ¬m tháº¥y Ã´ nháº­p Title, bá» qua.")

            if advanced_options.get('enabled'):
                self._apply_advanced_options(advanced_options, tab_index)

            logger.info(f"âœ… TAB {tab_index}: Filled {prompt.title}")
            return True
        except Exception as e:
            logger.error(f"âŒ TAB {tab_index} error: {e}")
            return False
    
            title_filled = False
            try:
                title_box = WebDriverWait(self.driver, 3).until(
                    EC.element_to_be_clickable((By.XPATH, SunoSelectors.TITLE_INPUT))
                )
                title_box.click(); time.sleep(0.2)
                title_box.clear(); title_box.send_keys(prompt.title)
                title_filled = True
            except Exception:
                # Fallback theo label
                try:
                    title_box = WebDriverWait(self.driver, 2).until(
                        EC.element_to_be_clickable((By.XPATH, SunoSelectors.TITLE_INPUT_BY_LABEL))
                    )
                    title_box.click(); time.sleep(0.2)
                    title_box.clear(); title_box.send_keys(prompt.title)
                    title_filled = True
                except Exception:
                    pass

            # JS fallback cho React controlled input (náº¿u váº«n chÆ°a Ä‘iá»n Ä‘Æ°á»£c Title)
            if not title_filled:
                try:
                    js = """
                    const els = Array.from(document.querySelectorAll('input[placeholder="Song Title (Optional)"]'));
                    const el = els.find(e => e && e.offsetParent !== null && getComputedStyle(e).visibility !== 'hidden');
                    if(!el) return {ok:false, reason:'not-found-visible'};
                    el.scrollIntoView({block:'center'});
                    el.focus();
                    const setter = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, 'value').set;
                    setter.call(el, '');
                    el.dispatchEvent(new Event('input', {bubbles:true}));
                    setter.call(el, arguments[0]);
                    el.dispatchEvent(new Event('input', {bubbles:true}));
                    el.dispatchEvent(new Event('change', {bubbles:true}));
                    return {ok: el.value === arguments[0], value: el.value};
                    """
                    res = self.driver.execute_script(js, prompt.title)
                    if res and res.get('ok'):
                        title_filled = True
                        logger.info(f"TAB {tab_index}: JS fallback Title OK â†’ '{res.get('value')}'")
                    else:
                        logger.warning(f"TAB {tab_index}: JS fallback Title fail: {res}")
                except Exception as e:
                    logger.warning(f"TAB {tab_index}: JS fallback Title exception: {e}")

            if not title_filled:
                logger.warning(f"TAB {tab_index}: KhÃ´ng tÃ¬m tháº¥y Ã´ nháº­p Title, bá» qua.")
            
            # Apply Advanced Options
            if advanced_options['enabled']:
                self._apply_advanced_options(advanced_options, tab_index)
            
            logger.info(f"âœ… TAB {tab_index}: Filled {prompt.title}")
            return True
            
        except Exception as e:
            logger.error(f"âŒ TAB {tab_index} error: {e}")
            return False
    
    def _apply_advanced_options(self, options: Dict[str, Any], tab_index: int):
        """Ãp dá»¥ng Advanced Options"""
        try:
            # Click Advanced Options button
            logger.info(f"TAB {tab_index}: Opening Advanced Options...")
            self.driver.execute_script("window.scrollBy(0, 300);")
            time.sleep(1)
            
            try:
                advanced_btn = WebDriverWait(self.driver, 5).until(
                    EC.element_to_be_clickable((By.XPATH, SunoSelectors.ADVANCED_OPTIONS_BUTTON))
                )
                self.driver.execute_script("arguments[0].scrollIntoView({block: 'center'});", advanced_btn)
                time.sleep(0.5)
                advanced_btn.click()
                time.sleep(1)
            except:
                logger.warning(f"TAB {tab_index}: Could not open Advanced Options")
                return
            
            # Exclude Styles
            if options['exclude_styles']:
                try:
                    exclude_input = self.driver.find_element(By.XPATH, SunoSelectors.EXCLUDE_STYLES_INPUT)
                    exclude_input.clear()
                    exclude_input.send_keys(options['exclude_styles'])
                    logger.info(f"TAB {tab_index}: Exclude styles = {options['exclude_styles']}")
                except:
                    pass
            
            # Vocal Gender
            if options['vocal_gender'] in ["Male", "Female"]:
                try:
                    selector = SunoSelectors.MALE_BUTTON if options['vocal_gender'] == "Male" else SunoSelectors.FEMALE_BUTTON
                    gender_btn = self.driver.find_element(By.XPATH, selector)
                    gender_btn.click()
                    time.sleep(0.5)
                except:
                    pass
            
            # Lyrics Mode
            if options['lyrics_mode'] in ["Manual", "Auto"]:
                try:
                    selector = SunoSelectors.MANUAL_LYRICS_BUTTON if options['lyrics_mode'] == "Manual" else SunoSelectors.AUTO_LYRICS_BUTTON
                    mode_btn = self.driver.find_element(By.XPATH, selector)
                    mode_btn.click()
                    time.sleep(0.5)
                except:
                    pass
            
            # Weirdness
            if options['weirdness'] != 50:
                try:
                    weirdness_slider = self.driver.find_element(By.XPATH, SunoSelectors.WEIRDNESS_SLIDER)
                    self._set_slider_value(weirdness_slider, options['weirdness'])
                except:
                    pass
            
            # Style Influence
            if options['style_influence'] != 50:
                try:
                    style_slider = self.driver.find_element(By.XPATH, SunoSelectors.STYLE_INFLUENCE_SLIDER)
                    self._set_slider_value(style_slider, options['style_influence'])
                except:
                    pass
            
            # Persona
            if options['persona_name']:
                try:
                    self._select_persona(options['persona_name'], tab_index)
                except:
                    pass
            
        except Exception as e:
            logger.error(f"TAB {tab_index}: Error applying advanced options: {e}")
    
    def _set_slider_value(self, slider_element, percentage: int):
        """Set slider value"""
        current_value = int(slider_element.get_attribute('aria-valuenow'))
        min_value = int(slider_element.get_attribute('aria-valuemin'))
        max_value = int(slider_element.get_attribute('aria-valuemax'))
        
        if current_value == percentage:
            return
        
        slider_width = slider_element.size['width']
        current_position = (current_value - min_value) / (max_value - min_value)
        target_position = (percentage - min_value) / (max_value - min_value)
        drag_offset = (target_position - current_position) * slider_width
        
        actions = ActionChains(self.driver)
        actions.click_and_hold(slider_element)
        actions.move_by_offset(drag_offset, 0)
        actions.release()
        actions.perform()
        
        time.sleep(0.3)
    
    def _select_persona(self, persona_name: str, tab_index: int):
        """Chá»n persona"""
        logger.info(f"TAB {tab_index}: Selecting persona '{persona_name}'...")
        
        # Scroll lÃªn trÃªn
        self.driver.execute_script("window.scrollTo(0, 0);")
        time.sleep(0.5)
        
        # Click Persona button
        try:
            persona_btn = WebDriverWait(self.driver, 5).until(
                EC.element_to_be_clickable((By.XPATH, SunoSelectors.PERSONA_BUTTON))
            )
            persona_btn.click()
            time.sleep(1.5)
        except:
            return
        
        # Search
        try:
            time.sleep(1)
            search_input = WebDriverWait(self.driver, 5).until(
                EC.element_to_be_clickable((By.XPATH, SunoSelectors.PERSONA_MODAL_SEARCH))
            )
            search_input.click()
            time.sleep(0.3)
            search_input.clear()
            search_input.send_keys(persona_name.lower())
            time.sleep(1.5)
        except:
            return
        
        # Click káº¿t quáº£ Ä‘áº§u tiÃªn
        try:
            persona_containers = WebDriverWait(self.driver, 5).until(
                EC.presence_of_all_elements_located((By.XPATH, SunoSelectors.PERSONA_CONTAINER))
            )
            
            valid_personas = [c for c in persona_containers if "Create New Persona" not in c.text]
            
            if valid_personas:
                first_result = valid_personas[0]
                self.driver.execute_script("arguments[0].scrollIntoView({block: 'center'});", first_result)
                time.sleep(0.5)
                first_result.click()
                time.sleep(1)
                logger.info(f"TAB {tab_index}: Persona selected")
        except:
            pass
    
    def stop(self):
        """Dá»«ng quÃ¡ trÃ¬nh"""
        if self.driver:
            self.driver.quit()
            self.driver = None
</file>

<file path="src/core/download_manager.py">
"""
Download Manager - Manages song download operations
"""
import os
import time
from typing import Dict, List, Optional
from pathlib import Path
from datetime import datetime

from config.settings import HISTORY_FILE, DOWNLOADS_DIR
from src.models import DownloadHistory, SongClip, DownloadTask
from src.utils import load_json, save_json, logger
from src.core.suno_api_client import SunoApiClient
from src.utils.file_downloader import SunoFileDownloader
from src.utils.metadata_handler import SunoMetadataHandler


class DownloadManager:
    """Manages song download operations"""
    
    def __init__(self):
        self.histories: Dict[str, DownloadHistory] = {}
        self.api_client = SunoApiClient()
        self.file_downloader = SunoFileDownloader()
        self.metadata_handler = SunoMetadataHandler()
        self.load_histories()
    
    def load_histories(self) -> None:
        """Load download history from file"""
        data = load_json(HISTORY_FILE, {})
        self.histories = {}
        for account, hist_data in data.items():
            # Add account_name to data
            hist_data['account_name'] = account
            self.histories[account] = DownloadHistory.from_dict(hist_data)
        logger.info(f"Loaded download histories for {len(self.histories)} accounts")
    
    def save_histories(self) -> bool:
        """Save download history to file"""
        data = {}
        for account, history in self.histories.items():
            hist_dict = history.to_dict()
            # Remove account_name from dict since it's the key
            hist_dict.pop('account_name', None)
            data[account] = hist_dict
        
        if save_json(HISTORY_FILE, data):
            logger.info("Download histories saved")
            return True
        return False
    
    def get_history(self, account_name: str) -> DownloadHistory:
        """Get download history for account"""
        if account_name not in self.histories:
            self.histories[account_name] = DownloadHistory(account_name=account_name)
        return self.histories[account_name]
    
    def clear_history(self, account_name: str) -> bool:
        """Clear download history for account"""
        if account_name in self.histories:
            self.histories[account_name].clear()
            self.save_histories()
            logger.info(f"Cleared download history for: {account_name}")
            return True
        return False
    
    def fetch_clips(self, session_token: str, profile_name: str = None, use_my_songs: bool = False, use_create_page: bool = False) -> List[SongClip]:
        """Fetch clips from profile, /me, or /create endpoint"""
        try:
            # Update API client with session token
            self.api_client.update_session_token(session_token)
            
            if use_create_page:
                # Fetch from /create context (paginated)
                api_clips, last_page, has_more = self.api_client.fetch_create_clips_paginated(start_page=0, max_pages=None)
                logger.info(f"Fetched {len(api_clips)} clips from /create (last_page={last_page}, has_more={has_more})")
            elif use_my_songs:
                # Fetch from /me (legacy)
                api_clips = self.api_client.fetch_my_clips()
                logger.info(f"Fetched {len(api_clips)} clips from /me")
            else:
                # Fetch from profile (get first page only for compatibility)
                clips, _, _ = self.api_client.fetch_profile_clips(profile_name, max_pages=1)
                api_clips = clips
                logger.info(f"Fetched {len(api_clips)} clips from {profile_name}")
            
            clips = [SongClip.from_api_response(clip) for clip in api_clips]
            return clips
            
        except Exception as e:
            logger.error(f"Failed to fetch clips: {e}")
            return []
    
    def get_user_info(self, session_token: str) -> dict:
        """Get current user information"""
        try:
            self.api_client.update_session_token(session_token)
            user_info = self.api_client.get_current_user_info()
            return user_info or {}
        except Exception as e:
            logger.error(f"Failed to get user info: {e}")
            return {}
    
    def get_new_clips(self, account_name: str, all_clips: List[SongClip]) -> List[SongClip]:
        """Filter clips that haven't been downloaded yet"""
        history = self.get_history(account_name)
        new_clips = [
            clip for clip in all_clips
            if not history.is_downloaded(clip.id)
        ]
        logger.info(f"Found {len(new_clips)} new clips for {account_name}")
        return new_clips
    
    def download_clip(
        self,
        session_token: str,
        clip: SongClip,
        output_dir: Path,
        with_thumbnail: bool = True,
        append_uuid: bool = True,
        progress_callback = None
    ) -> bool:
        """Download a single clip"""
        try:
            # Convert SongClip to dict format expected by downloader
            clip_data = {
                'id': clip.id,
                'title': clip.title,
                'audio_url': clip.audio_url,
                'image_url': clip.image_url,
                'display_name': getattr(clip, 'display_name', 'Unknown Artist'),
                'metadata': {
                    'tags': clip.tags if clip.tags else ''
                }
            }
            
            # Download audio
            if progress_callback:
                progress_callback(f"Downloading: {clip.title}", 30)
            
            audio_path = self.file_downloader.download_audio(clip_data, str(output_dir), append_uuid)
            
            if not audio_path:
                logger.error(f"Failed to download audio: {clip.title}")
                return False
            
            # Download thumbnail and embed metadata
            if with_thumbnail:
                if progress_callback:
                    progress_callback(f"Embedding metadata: {clip.title}", 70)
                
                thumbnail_path = self.file_downloader.download_thumbnail(clip_data, str(output_dir))
                self.metadata_handler.embed_metadata(audio_path, clip_data, thumbnail_path)
                
                # Remove thumbnail file
                if thumbnail_path:
                    try:
                        os.remove(thumbnail_path)
                    except Exception:
                        pass
            
            if progress_callback:
                progress_callback(f"Completed: {clip.title}", 100)
            
            logger.info(f"Downloaded: {clip.title}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to download clip {clip.title}: {e}")
            return False
    
    def batch_download(
        self,
        account_name: str,
        session_token: str,
        clips: List[SongClip],
        output_dir: Path,
        with_thumbnail: bool = True,
        append_uuid: bool = True,
        progress_callback = None,
        delay: int = 2
    ) -> Dict[str, int]:
        """Batch download multiple clips"""
        
        history = self.get_history(account_name)
        stats = {'success': 0, 'failed': 0, 'skipped': 0}
        
        total = len(clips)
        
        for idx, clip in enumerate(clips, 1):
            if progress_callback:
                progress_callback(f"Processing {idx}/{total}: {clip.title}", (idx-1) * 100 // total)
            
            # Skip if already downloaded
            if history.is_downloaded(clip.id):
                stats['skipped'] += 1
                continue
            
            # Download clip
            success = self.download_clip(
                session_token, clip, output_dir,
                with_thumbnail, append_uuid, None
            )
            
            if success:
                history.add_download(clip.id)
                stats['success'] += 1
            else:
                stats['failed'] += 1
            
            # Delay between downloads
            if idx < total:
                time.sleep(delay)
        
        # Save history
        self.save_histories()
        
        logger.info(f"Batch download completed: {stats}")
        return stats
    
    def batch_download_paginated(
        self,
        account_name: str,
        session_token: str,
        output_dir: Path,
        profile_name: str = None,
        use_create_page: bool = False,
        start_page: int = 0,
        max_pages: Optional[int] = None,
        max_clips: Optional[int] = None,
        with_thumbnail: bool = True,
        append_uuid: bool = True,
        progress_callback = None,
        delay: int = 2
    ) -> Dict[str, int]:
        """
        Batch download with pagination - fetches and downloads page-by-page to save memory.
        
        Args:
            account_name: Account name for history tracking
            session_token: JWT session token
            output_dir: Output directory for downloads
            profile_name: Profile name (if downloading from profile)
            use_create_page: If True, fetch from /create feed; if False, fetch from profile
            start_page: Starting page index
            max_pages: Maximum pages to process (None = all)
            max_clips: Maximum clips to download (None = all)
            with_thumbnail: Download and embed thumbnails
            append_uuid: Append UUID to filenames
            progress_callback: Callback(message, progress_percent)
            delay: Delay between downloads in seconds
        
        Returns:
            Dict with 'success', 'failed', 'skipped', 'total_pages' counts
        """
        history = self.get_history(account_name)
        stats = {'success': 0, 'failed': 0, 'skipped': 0, 'total_pages': 0}
        
        # Update API client token
        self.api_client.update_session_token(session_token)
        
        current_page = start_page
        pages_processed = 0
        
        while True:
            # Check max_pages limit
            if max_pages is not None and pages_processed >= max_pages:
                logger.info(f"Reached max_pages limit: {max_pages}")
                break
            
            # Check max_clips limit
            if max_clips is not None and (stats['success'] + stats['skipped']) >= max_clips:
                logger.info(f"Reached max_clips limit: {max_clips}")
                break
            
            if progress_callback:
                progress_callback(f"Äang táº£i trang {current_page}...", 0)
            
            # Fetch one page of clips
            try:
                if use_create_page:
                    # Fetch from /create feed (one page)
                    api_clips, last_page, has_more = self.api_client.fetch_create_clips_paginated(
                        start_page=current_page, 
                        max_pages=1
                    )
                else:
                    # Fetch from profile (one page)
                    api_clips, last_page, has_more = self.api_client.fetch_profile_clips(
                        profile_name, 
                        start_page=current_page, 
                        max_pages=1
                    )
                
                if not api_clips:
                    logger.info(f"No more clips at page {current_page}")
                    break
                
                clips = [SongClip.from_api_response(clip) for clip in api_clips]
                stats['total_pages'] += 1
                pages_processed += 1
                
                logger.info(f"Page {current_page}: {len(clips)} clips")
                
                # Download clips from this page
                for idx, clip in enumerate(clips, 1):
                    # Check max_clips limit before processing each clip
                    if max_clips is not None and (stats['success'] + stats['skipped']) >= max_clips:
                        logger.info(f"Reached max_clips limit during page processing: {max_clips}")
                        break
                    
                    if progress_callback:
                        msg = f"Trang {current_page} - {idx}/{len(clips)}: {clip.title}"
                        progress_callback(msg, 0)
                    
                    # Skip if already downloaded
                    if history.is_downloaded(clip.id):
                        stats['skipped'] += 1
                        logger.debug(f"Skipped (already downloaded): {clip.title}")
                        continue
                    
                    # Download clip
                    success = self.download_clip(
                        session_token, clip, output_dir,
                        with_thumbnail, append_uuid, None
                    )
                    
                    if success:
                        history.add_download(clip.id)
                        stats['success'] += 1
                        # Save history after each successful download
                        self.save_histories()
                    else:
                        stats['failed'] += 1
                    
                    # Delay between downloads
                    if idx < len(clips) or has_more:
                        time.sleep(delay)
                
                # Move to next page
                if not has_more:
                    logger.info("No more pages available")
                    break
                
                current_page += 1
                
            except Exception as e:
                logger.error(f"Error fetching/downloading page {current_page}: {e}")
                stats['failed'] += 1
                break
        
        logger.info(f"Paginated batch download completed: {stats}")
        return stats
</file>

<file path="src/core/js_snippets.py">
"""JavaScript snippets used by Selenium automation.

Expose small JS scripts as Python string constants so tests and automation
can execute them via `driver.execute_script(...)`.
"""

# Script to set the value of a React-controlled <input> or <textarea> using
# the native property setter so React's internal change handlers pick up the
# change. Expects two arguments when executed via Selenium:
#   arguments[0] -> element
#   arguments[1] -> value (string)
SET_REACT_VALUE_SCRIPT = """
const el = arguments[0];
const value = arguments[1];
const nativeSetter = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, 'value')?.set ||
					  Object.getOwnPropertyDescriptor(window.HTMLTextAreaElement.prototype, 'value')?.set;
if (nativeSetter) {
	nativeSetter.call(el, value);
} else {
	el.value = value;
}
el.dispatchEvent(new Event('input', { bubbles: true }));
el.dispatchEvent(new Event('change', { bubbles: true }));
"""
</file>

<file path="src/core/queue_manager.py">
"""
Queue manager - orchestrates prompt queues per account.
"""
from __future__ import annotations

from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional
from uuid import uuid4

from config.settings import QUEUE_STATE_FILE
from src.models import QueueEntry
from src.utils import atomic_write_json, load_json, logger
from src.utils.prompt_parser import SunoPrompt


class QueueValidationError(Exception):
    """Raised when queue state violates prompt limits or input rules."""


class QueueManager:
    """Manages queue entries and persistence for multi-account song creation."""

    def __init__(self, state_file: Path = QUEUE_STATE_FILE):
        self.state_file = state_file
        self.version = "1.0"
        self.prompts: List[SunoPrompt] = []
        self.prompt_cursor = 0
        self.queues: Dict[str, QueueEntry] = {}
        self.last_updated: Optional[str] = None
        self._load_state()

    def _load_state(self) -> None:
        """Load the queue state from disk."""
        data = load_json(self.state_file, self._default_state())
        self.version = data.get("version", "1.0")
        self.prompts = self._deserialize_prompts(data.get("prompts", []))
        self.prompt_cursor = data.get("prompt_cursor", 0)
        self.last_updated = data.get("last_updated")
        self.queues = {}
        for raw in data.get("queues", []):
            try:
                entry = QueueEntry.from_dict(raw)
                self.queues[entry.id] = entry
            except KeyError:
                logger.warning("Skipped malformed queue entry during load")
        logger.info(f"Queue state loaded ({len(self.queues)} entries)")

    def _default_state(self) -> dict[str, object]:
        return {
            "version": self.version,
            "prompts": [],
            "prompt_cursor": 0,
            "queues": [],
            "last_updated": None,
        }

    def _deserialize_prompts(self, data: List[dict[str, str]]) -> List[SunoPrompt]:
        prompts: List[SunoPrompt] = []
        for item in data:
            title = item.get("title", "")
            lyrics = item.get("lyrics", "")
            style = item.get("style", "")
            if title and lyrics and style:
                prompts.append(SunoPrompt(title=title, lyrics=lyrics, style=style))
        return prompts

    def _serialize_prompts(self) -> List[dict[str, str]]:
        return [
            {"title": prompt.title, "lyrics": prompt.lyrics, "style": prompt.style}
            for prompt in self.prompts
        ]

    def _ensure_prompts(self, prompts: List[SunoPrompt]) -> None:
        if not prompts:
            raise QueueValidationError("At least one prompt is required to queue songs")
        if self.prompts and self.prompts != prompts and self.queues:
            raise QueueValidationError("Cannot switch prompts while queues exist")
        if not self.prompts or self.prompts != prompts:
            self.prompts = list(prompts)
            self.prompt_cursor = 0

    def _save_state(self) -> bool:
        payload = {
            "version": self.version,
            "prompts": self._serialize_prompts(),
            "prompt_cursor": self.prompt_cursor,
            "queues": [entry.to_dict() for entry in self.queues.values()],
            "last_updated": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        }
        if atomic_write_json(self.state_file, payload):
            self.last_updated = payload["last_updated"]
            logger.info(f"Queue state saved ({len(self.queues)} entries)")
            return True
        logger.error("Failed to persist queue state")
        return False

    def add_queue_entry(
        self,
        account_name: str,
        total_songs: int,
        songs_per_batch: int,
        prompts: List[SunoPrompt],
    ) -> QueueEntry:
        """
        Add a new queue entry if prompts remain.

        Args:
            account_name: Account responsible for the queue.
            total_songs: Number of songs to create for this entry.
            songs_per_batch: Number of songs to create per browser session.
            prompts: List of parsed SunoPrompt objects.
        """
        self._ensure_prompts(prompts)
        if total_songs <= 0 or songs_per_batch <= 0:
            raise QueueValidationError("Song counts must be positive")
        if songs_per_batch > total_songs:
            raise QueueValidationError("Songs per batch cannot exceed total songs")
        if self.prompt_cursor + total_songs > len(self.prompts):
            raise QueueValidationError("Not enough prompts remain to fulfill request")
        entry = QueueEntry(
            id=str(uuid4()),
            account_name=account_name,
            total_songs=total_songs,
            songs_per_batch=songs_per_batch,
            prompts_range=(self.prompt_cursor, self.prompt_cursor + total_songs),
        )
        self.prompt_cursor += total_songs
        self.queues[entry.id] = entry
        self._save_state()
        return entry

    def remove_queue_entry(self, queue_id: str) -> bool:
        """Remove a queue entry by its ID."""
        if queue_id not in self.queues:
            return False
        del self.queues[queue_id]
        self._save_state()
        return True

    def get_queue(self, queue_id: str) -> Optional[QueueEntry]:
        """Return a queue entry by ID."""
        return self.queues.get(queue_id)

    def get_all_queues(self) -> List[QueueEntry]:
        """Return all queue entries in creation order."""
        return sorted(self.queues.values(), key=lambda entry: entry.created_at)

    def get_pending_queues(self) -> List[QueueEntry]:
        """Return queue entries that are not completed or failed yet."""
        return [
            entry
            for entry in self.queues.values()
            if entry.status in {"pending", "in_progress"}
        ]

    def update_queue_progress(
        self,
        queue_id: str,
        completed_count: Optional[int] = None,
        status: Optional[str] = None,
    ) -> bool:
        """Update progress metrics for a queue entry."""
        entry = self.queues.get(queue_id)
        if not entry:
            return False
        if completed_count is not None:
            entry.completed_count = min(completed_count, entry.total_songs)
        if status:
            entry.status = status
        self._save_state()
        return True

    def validate_total_prompts(self, requested_total: int) -> bool:
        """Verify that enough prompts remain before creating a queue."""
        return requested_total <= self.available_prompt_slots

    @property
    def available_prompt_slots(self) -> int:
        """Number of prompts still unassigned."""
        return len(self.prompts) - self.prompt_cursor

    def clear(self) -> None:
        """Reset queue state completely (prompts and entries)."""
        self.prompts = []
        self.prompt_cursor = 0
        self.queues.clear()
        self._save_state()
</file>

<file path="src/core/session_manager.py">
"""
Session Manager - Manages Chrome sessions and authentication tokens
"""
import time
from pathlib import Path
from tkinter import Tk
from typing import Optional
from selenium import webdriver
from selenium.webdriver.chrome.options import Options

from config.settings import PROFILES_DIR, SUNO_URL, CHROME_OPTIONS
from src.utils import logger


class SessionManager:
    """Manages Chrome sessions and authentication tokens"""
    
    @staticmethod
    def _cleanup_profile_locks(profile_path: Path) -> None:
        """Remove leftover lock files to avoid Chrome refusing to start."""
        lock_candidates = (
            "SingletonLock",
            "SingletonLock.bak",
            "lockfile",
            "LOCK",
            "Chrome SingletonLock",
        )
        for lock_name in lock_candidates:
            target = profile_path / lock_name
            try:
                if target.exists():
                    target.unlink()
            except Exception:
                # best-effort cleanup, ignore if removal fails
                pass

    @staticmethod
    def _get_quarter_screen_size() -> tuple[int, int] | None:
        try:
            root = Tk()
            root.withdraw()
            width = max(640, root.winfo_screenwidth() // 2)
            height = max(480, root.winfo_screenheight() // 2)
            root.destroy()
            return width, height
        except Exception:
            return None

    @staticmethod
    def create_chrome_options(profile_path: Path, headless: bool = False) -> Options:
        """Create Chrome options with profile"""
        options = Options()
        options.add_argument(f'--user-data-dir={profile_path}')
        options.add_argument('--profile-directory=Default')
        
        for opt in CHROME_OPTIONS:
            options.add_argument(opt)
        
        if headless:
            options.add_argument('--headless=new')  # New headless mode
            options.add_argument('--disable-extensions')
            options.add_argument('--disable-plugins')
            options.add_argument('--window-size=1920,1080')
        else:
            size = SessionManager._get_quarter_screen_size()
            if size:
                options.add_argument(f'--window-size={size[0]},{size[1]}')
        
        options.add_experimental_option('excludeSwitches', ['enable-automation'])
        options.add_experimental_option('useAutomationExtension', False)
        
        return options
    
    @staticmethod
    def launch_browser(account_name: str, headless: bool = False) -> Optional[webdriver.Chrome]:
        """Launch browser with account profile"""
        profile_path = PROFILES_DIR / account_name
        profile_path.mkdir(parents=True, exist_ok=True)
        SessionManager._cleanup_profile_locks(profile_path)
        
        try:
            options = SessionManager.create_chrome_options(profile_path, headless)
            driver = webdriver.Chrome(options=options)
            
            # Anti-detection
            driver.execute_cdp_cmd('Page.addScriptToEvaluateOnNewDocument', {
                'source': '''
                    Object.defineProperty(navigator, 'webdriver', {
                        get: () => undefined
                    });
                '''
            })
            
            driver.get(SUNO_URL)
            logger.info(f"Browser launched for account: {account_name}")
            return driver
            
        except Exception as e:
            logger.error(f"Failed to launch browser: {e}")
            return None
    
    @staticmethod
    def get_session_token(account_name: str) -> Optional[str]:
        """Get session token from Chrome profile"""
        profile_path = PROFILES_DIR / account_name
        profile_path.mkdir(parents=True, exist_ok=True)
        
        driver = None
        try:
            logger.info(f"Opening browser to get session token...")
            options = SessionManager.create_chrome_options(profile_path, headless=False)
            driver = webdriver.Chrome(options=options)
            driver.get(SUNO_URL)
            
            # Wait for page load
            time.sleep(3)
            
            # Get cookies
            cookies = driver.get_cookies()
            
            # Find __session cookie
            for cookie in cookies:
                if cookie['name'] == '__session':
                    token = cookie['value']
                    logger.info(f"âœ“ Session token retrieved for: {account_name} (length: {len(token)})")
                    return token
            
            logger.warning(f"No __session cookie found")
            logger.debug(f"Available cookies: {[c['name'] for c in cookies]}")
            return None
                    
        except Exception as e:
            logger.error(f"Failed to get session token: {e}")
            return None
        finally:
            if driver:
                try:
                    driver.quit()
                except Exception:
                    pass
    
    @staticmethod
    def get_session_token_from_me_page(account_name: str) -> tuple[Optional[str], Optional[webdriver.Chrome]]:
        """
        Open suno.com/create and retrieve session token
        Returns: (token, driver) - keep driver open for user interaction
        """
        profile_path = PROFILES_DIR / account_name
        profile_path.mkdir(parents=True, exist_ok=True)
        
        driver = None
        try:
            logger.info(f"Opening https://suno.com/create to get session token...")
            options = SessionManager.create_chrome_options(profile_path, headless=False)
            
            # Add more options to avoid profile lock issues
            options.add_argument('--disable-lock-screen-chrome-profile')
            options.add_argument('--disable-extensions')
            
            driver = webdriver.Chrome(options=options)
            
            # Anti-detection
            driver.execute_cdp_cmd('Page.addScriptToEvaluateOnNewDocument', {
                'source': '''
                    Object.defineProperty(navigator, 'webdriver', {
                        get: () => undefined
                    });
                '''
            })
            
            # Navigate to /create page directly
            create_url = "https://suno.com/create"
            logger.info(f"Navigating to {create_url}...")
            driver.get(create_url)
            
            # Wait for page load
            time.sleep(5)  # Increase wait time for better loading
            
            # Get cookies
            cookies = driver.get_cookies()
            logger.info(f"Found {len(cookies)} cookies")
            
            # Find __session cookie
            for cookie in cookies:
                if cookie['name'] == '__session':
                    token = cookie['value']
                    logger.info(f"âœ“ Session token retrieved from /create (length: {len(token)})")
                    return token, driver  # Tráº£ vá» cáº£ driver Ä‘á»ƒ giá»¯ browser má»Ÿ
            
            logger.warning(f"No __session cookie found on /create")
            logger.debug(f"Available cookies: {[c['name'] for c in cookies]}")
            return None, driver
                    
        except Exception as e:
            error_msg = str(e)
            if "Chrome instance exited" in error_msg:
                logger.error(f"Chrome profile is locked. Close all Chrome windows using profile '{account_name}' and try again.")
            else:
                logger.error(f"Failed to get session token from /create: {error_msg}")
            
            if driver:
                try:
                    driver.quit()
                except Exception:
                    pass
            return None, None
    
    @staticmethod
    def verify_session(account_name: str) -> bool:
        """Verify if session is still valid"""
        token = SessionManager.get_session_token(account_name)
        return token is not None

    # Backwards-compatible alias: some tests/consumers expect this name
    @staticmethod
    def get_session_token_from_create_page(account_name: str) -> tuple[Optional[str], Optional[webdriver.Chrome]]:
        """Alias for get_session_token_from_me_page to preserve older API name."""
        return SessionManager.get_session_token_from_me_page(account_name)
</file>

<file path="src/core/song_creation_history_manager.py">
"""
Manage persistence of song creation history records.
"""
import csv
import json
from pathlib import Path
from typing import List

from config.settings import SONG_CREATION_HISTORY_FILE
from src.models import SongCreationRecord
from src.utils import logger


class SongCreationHistoryManager:
    """Persistent manager for SongCreationRecord entries."""

    def __init__(self, file_path: Path | None = None):
        self.file_path = file_path or SONG_CREATION_HISTORY_FILE
        self.records: List[SongCreationRecord] = []
        self._ensure_file()
        self.load_records()

    def _ensure_file(self):
        self.file_path.parent.mkdir(parents=True, exist_ok=True)
        if not self.file_path.exists():
            self.file_path.write_text("[]", encoding="utf-8")

    def load_records(self):
        """Load records from disk."""
        try:
            with self.file_path.open("r", encoding="utf-8") as handle:
                data = json.load(handle)
        except Exception as exc:
            logger.error(f"Failed to load song creation history: {exc}")
            data = []

        self.records = [
            SongCreationRecord.from_dict(record) for record in data if isinstance(record, dict)
        ]

    def _save(self):
        try:
            with self.file_path.open("w", encoding="utf-8") as handle:
                json.dump([record.to_dict() for record in self.records], handle, ensure_ascii=False, indent=2)
        except Exception as exc:
            logger.error(f"Unable to save song creation history: {exc}")

    def add_creation_record(self, record: SongCreationRecord):
        """Store a new record and persist immediately."""
        self.records.insert(0, record)
        self._save()

    def get_all_records(self) -> List[SongCreationRecord]:
        """Return all records sorted newest first."""
        return list(self.records)

    def get_records_by_account(self, account_name: str) -> List[SongCreationRecord]:
        """Return records filtered by account."""
        return [rec for rec in self.records if rec.account_name == account_name]

    def search_records(self, keyword: str) -> List[SongCreationRecord]:
        """Search records by title, song ID, or status."""
        if not keyword:
            return self.get_all_records()

        lower = keyword.lower()
        return [
            rec for rec in self.records
            if lower in rec.title.lower()
            or lower in rec.song_id.lower()
            or lower in rec.status.lower()
        ]

    def export_to_csv(self, output_path: Path) -> Path:
        """Export the current records to CSV."""
        fields = ["timestamp", "account", "title", "song_id", "status", "error"]
        try:
            with output_path.open("w", encoding="utf-8", newline="") as handle:
                writer = csv.writer(handle)
                writer.writerow(fields)
                for rec in self.records:
                    writer.writerow([
                        rec.created_at,
                        rec.account_name,
                        rec.title,
                        rec.song_id,
                        rec.status,
                        rec.error_message or ""
                    ])
        except Exception as exc:
            logger.error(f"Failed to export song creation history to CSV: {exc}")
            raise
        return output_path
</file>

<file path="src/core/suno_api_client.py">
"""
Suno API Client
Handles all API interactions with Suno.com

Part of Clean Architecture refactor from legacy_modules/suno_batch_download.py
"""
import time
import requests
from typing import List, Dict, Tuple, Optional, Any
from pathlib import Path

from src.utils.logger import logger


class SunoApiClient:
    """
    API Client for Suno.com interactions

    Handles:
    - Profile clips fetching with pagination
    - User information retrieval
    - Clip fetching by UUIDs
    - Rate limiting and proxy management
    - Session token authentication
    """

    def __init__(self, session_token: Optional[str] = None, proxy_list: Optional[List[str]] = None):
        """
        Initialize Suno API Client

        Args:
            session_token: JWT token from browser cookies (__session)
            proxy_list: List of proxy URLs for requests
        """
        self.session_token = session_token
        self.proxy_list = proxy_list or []
        self.base_url = "https://studio-api.prod.suno.com/api"

        # Setup headers
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'application/json',
        }

        if self.session_token:
            self.headers['Authorization'] = f'Bearer {self.session_token}'

        # Rate limiting state
        self._last_request_time = 0
        self._rate_limit_wait = 10

    def _get_random_proxy(self) -> Optional[Dict[str, str]]:
        """Get a random proxy from the proxy list"""
        if not self.proxy_list:
            return None
        proxy_url = self.proxy_list[len(self.proxy_list) % len(self.proxy_list)]  # Simple rotation
        return {'http': proxy_url, 'https': proxy_url}

    def _handle_rate_limit(self, response: requests.Response) -> bool:
        """
        Handle rate limiting from API responses

        Args:
            response: The HTTP response

        Returns:
            True if rate limited and should retry, False otherwise
        """
        if response.status_code == 429:
            logger.warning(f"Rate limit hit (429), waiting {self._rate_limit_wait}s...")
            time.sleep(self._rate_limit_wait)
            self._rate_limit_wait = min(self._rate_limit_wait + 5, 60)  # Exponential backoff
            return True

        # Reset rate limit wait on successful request
        if response.status_code == 200:
            self._rate_limit_wait = 10

        return False

    def _make_request(self, method: str, endpoint: str, **kwargs) -> Optional[Dict[str, Any]]:
        """
        Make an HTTP request with error handling and rate limiting

        Args:
            method: HTTP method (GET, POST, etc.)
            endpoint: API endpoint (without base URL)
            **kwargs: Additional requests parameters

        Returns:
            JSON response data or None if failed
        """
        url = f"{self.base_url}{endpoint}"

        # Add proxies if available
        if 'proxies' not in kwargs:
            kwargs['proxies'] = self._get_random_proxy()

        # Add default timeout
        if 'timeout' not in kwargs:
            kwargs['timeout'] = 30

        # Add headers
        if 'headers' not in kwargs:
            kwargs['headers'] = self.headers

        try:
            # Rate limiting: ensure minimum delay between requests
            elapsed = time.time() - self._last_request_time
            if elapsed < 2:  # Minimum 2 seconds between requests
                time.sleep(2 - elapsed)

            response = requests.request(method, url, **kwargs)
            self._last_request_time = time.time()

            # Handle rate limiting
            if self._handle_rate_limit(response):
                # Retry once after rate limit
                response = requests.request(method, url, **kwargs)
                self._last_request_time = time.time()

            response.raise_for_status()
            return response.json()

        except requests.exceptions.RequestException as e:
            logger.error(f"API request failed: {method} {endpoint} - {str(e)}")
            return None

    def fetch_profile_clips(self, profile_name: str, start_page: int = 0,
                           max_pages: Optional[int] = None) -> Tuple[List[Dict], int, bool]:
        """
        Fetch clips from a user profile with pagination

        Args:
            profile_name: Profile name (with or without @)
            start_page: Starting page number (0-indexed)
            max_pages: Maximum pages to fetch (None for unlimited)

        Returns:
            Tuple of (clips_list, last_page_fetched, has_more_pages)
        """
        logger.info(f"Fetching clips from profile: {profile_name} (starting page {start_page})")

        # Remove @ prefix if present
        if profile_name.startswith('@'):
            profile_name = profile_name[1:]

        endpoint = f"/profiles/{profile_name}/clips"
        all_clips = []
        page = start_page
        pages_fetched = 0

        while True:
            # Check page limit
            if max_pages and pages_fetched >= max_pages:
                logger.info(f"Reached maximum pages limit: {max_pages}")
                return all_clips, page - 1, True

            params = {'page': page}
            data = self._make_request('GET', endpoint, params=params)

            if not data:
                logger.error(f"Failed to fetch page {page}")
                return all_clips, page - 1, False

            clips = data.get('clips', [])
            if not clips:
                logger.info(f"No more clips found at page {page}")
                return all_clips, page - 1, False

            all_clips.extend(clips)
            logger.info(f"Page {page}: {len(clips)} clips")
            page += 1
            pages_fetched += 1

            # Delay between pages
            if pages_fetched < (max_pages or float('inf')):
                time.sleep(5)

        return all_clips, page - 1, False

    def fetch_my_clips(self) -> List[Dict]:
        """
        Fetch current user's clips from /feed/v2

        Returns:
            List of clip dictionaries
        """
        logger.info("Fetching current user's clips from /feed/v2")

        endpoint = "/feed/v2"
        params = {'page': 0}

        data = self._make_request('GET', endpoint, params=params)

        if not data:
            logger.error("Failed to fetch user clips")
            return []

        clips = data.get('clips', [])
        logger.info(f"Found {len(clips)} user clips from /feed/v2")
        return clips

    def fetch_create_clips(self) -> List[Dict]:
        """
        Fetch current user's clips from /feed/v2 (accessed via /create page)
        This is the same endpoint as fetch_my_clips but accessed from /create context

        Returns:
            List of clip dictionaries
        """
        # Backwards-compatible single-page fetch (kept for callers that expect a simple list)
        logger.info("Fetching clips from /create page context (using /feed/v2) - single page")

        endpoint = "/feed/v2"
        params = {'page': 0}

        data = self._make_request('GET', endpoint, params=params)

        if not data:
            logger.error("Failed to fetch clips from /create context")
            return []

        clips = data.get('clips', [])
        logger.info(f"Found {len(clips)} clips from /create context (page 0)")
        return clips

    def fetch_create_clips_paginated(self, start_page: int = 0, max_pages: Optional[int] = None) -> Tuple[List[Dict], int, bool]:
        """
        Fetch current user's clips from the feed endpoint used by /create with pagination.

        Args:
            start_page: starting page (0-indexed)
            max_pages: maximum pages to fetch (None = fetch until empty)

        Returns:
            (all_clips, last_page_fetched, has_more_pages)
        """
        logger.info(f"Fetching clips from /create context with pagination (starting page {start_page})")

        endpoint = "/feed/v2"
        all_clips: List[Dict] = []
        page = start_page
        pages_fetched = 0

        while True:
            if max_pages and pages_fetched >= max_pages:
                logger.info(f"Reached maximum pages limit: {max_pages}")
                return all_clips, page - 1, True

            params = {'page': page}
            data = self._make_request('GET', endpoint, params=params)

            if not data:
                logger.error(f"Failed to fetch /feed/v2 page {page}")
                return all_clips, page - 1, False

            clips = data.get('clips', [])
            if not clips:
                logger.info(f"No more clips found at /feed/v2 page {page}")
                return all_clips, page - 1, False

            all_clips.extend(clips)
            logger.info(f"/feed/v2 Page {page}: {len(clips)} clips")
            page += 1
            pages_fetched += 1

            # polite delay between pages
            if pages_fetched < (max_pages or float('inf')):
                time.sleep(2)

        return all_clips, page - 1, False

    def get_current_user_info(self) -> Optional[Dict[str, Any]]:
        """
        Get current user information

        Returns:
            User info dict with username, email, credits, etc.
        """
        logger.info("Fetching current user information")

        endpoint = "/billing/info"
        data = self._make_request('GET', endpoint)

        if not data:
            logger.error("Failed to fetch user info")
            return None

        user_info = {
            'username': data.get('display_name', ''),
            'email': data.get('email', ''),
            'credits': data.get('total_credits_left', 0)
        }

        logger.info(f"User: @{user_info['username']}, Credits: {user_info['credits']}")
        return user_info

    def fetch_clips_by_uuids(self, uuids: List[str]) -> List[Dict]:
        """
        Fetch clip information by UUIDs

        Args:
            uuids: List of clip UUIDs

        Returns:
            List of clip dictionaries
        """
        logger.info(f"Fetching {len(uuids)} clips by UUID")

        clips = []

        for idx, uuid in enumerate(uuids, 1):
            endpoint = f"/clips/{uuid}"
            data = self._make_request('GET', endpoint)

            if data:
                clips.append(data)
                logger.info(f"[{idx}/{len(uuids)}] {data.get('title', 'Unknown')}")
            else:
                logger.error(f"Failed to fetch clip {uuid}")

            # Delay between requests
            if idx < len(uuids):
                time.sleep(2)

        return clips

    def update_session_token(self, token: str):
        """
        Update the session token for authentication

        Args:
            token: New JWT session token
        """
        self.session_token = token
        if token:
            self.headers['Authorization'] = f'Bearer {token}'
        else:
            self.headers.pop('Authorization', None)

    def set_proxy_list(self, proxy_list: List[str]):
        """
        Update the proxy list

        Args:
            proxy_list: New list of proxy URLs
        """
        self.proxy_list = proxy_list or []
</file>

<file path="src/core/suno_form_automation.py">
"""
Form Automation Components for Suno Music Creation
Extracted from legacy_modules/suno_auto_create.py

Part of Clean Architecture refactor
"""
import time
from typing import Optional, Dict, Any
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, NoSuchElementException

from src.utils.logger import logger


class SunoFormFiller:
    """
    Handles form filling operations for Suno music creation

    Responsibilities:
    - Fill lyrics textarea
    - Fill styles textarea
    - Fill title input
    - Validate form completion
    """

    def __init__(self, driver):
        """
        Initialize form filler

        Args:
            driver: Selenium WebDriver instance
        """
        self.driver = driver
        self.wait = WebDriverWait(driver, 10)

    def fill_lyrics(self, lyrics: str) -> bool:
        """
        Fill the lyrics textarea

        Args:
            lyrics: Song lyrics or prompt text

        Returns:
            True if successful, False otherwise
        """
        if not lyrics:
            logger.info("Skipping lyrics (instrumental mode)")
            return True

        logger.info(f"Filling lyrics ({len(lyrics)} characters)...")

        selectors = [
            "//textarea[contains(@placeholder, 'Write some lyrics or a prompt')]",
            "//*[@role='textbox' and contains(@placeholder, 'Write some lyrics or a prompt')]",
            "//*[contains(@aria-label, 'Write some lyrics')]",
            "//textarea[@aria-label='Lyrics']",
        ]

        for selector in selectors:
            try:
                lyrics_box = self.wait.until(
                    EC.element_to_be_clickable((By.XPATH, selector))
                )
                lyrics_box.click()
                time.sleep(0.5)
                lyrics_box.clear()
                lyrics_box.send_keys(lyrics)
                logger.info("âœ“ Lyrics filled successfully")
                return True
            except TimeoutException:
                continue

        logger.error("âŒ Could not find lyrics textarea")
        return False

    def fill_styles(self, styles: str) -> bool:
        """
        Fill the styles textarea

        Args:
            styles: Music style tags

        Returns:
            True if successful, False otherwise
        """
        if not styles:
            logger.warning("âš ï¸ No styles provided!")
            return False

        logger.info(f"Filling styles: {styles[:50]}...")

        selectors = [
            "//textarea[contains(@placeholder, 'indie, electronic, synths')]",
            "//*[@role='textbox' and contains(@placeholder, 'indie, electronic, synths')]",
            "//*[contains(@aria-label, 'Style of Music')]",
            "//textarea[@aria-label='Style of Music']",
        ]

        for selector in selectors:
            try:
                styles_box = self.wait.until(
                    EC.element_to_be_clickable((By.XPATH, selector))
                )
                styles_box.click()
                time.sleep(0.5)
                styles_box.clear()
                styles_box.send_keys(styles)
                logger.info("âœ“ Styles filled successfully")
                return True
            except TimeoutException:
                continue

        logger.error("âŒ Could not find styles textarea")
        return False

    def fill_title(self, title: Optional[str]) -> bool:
        """
        Fill the title input (optional)

        Args:
            title: Song title

        Returns:
            True if successful or skipped, False on error
        """
        if not title:
            logger.info("Skipping title (AI will generate)")
            return True

        logger.info(f"Filling title: {title}")

        selectors = [
            "//input[contains(@placeholder, 'Song Title (Optional)')]",
            "//*[@role='textbox' and contains(@placeholder, 'Song Title (Optional)')]",
            "//*[contains(@aria-label, 'Song Title')]",
            "//input[@aria-label='Title']",
        ]

        for selector in selectors:
            try:
                title_box = self.wait.until(
                    EC.element_to_be_clickable((By.XPATH, selector))
                )
                title_box.click()
                time.sleep(0.5)
                title_box.clear()
                title_box.send_keys(title)
                logger.info("âœ“ Title filled successfully")
                return True
            except TimeoutException:
                continue

        logger.error("âŒ Could not find title input")
        return False

    def fill_form(self, lyrics: str, styles: str, title: Optional[str] = None) -> bool:
        """
        Fill the complete form

        Args:
            lyrics: Song lyrics or prompt
            styles: Music style tags
            title: Optional song title

        Returns:
            True if all required fields filled successfully
        """
        logger.info("Starting form fill process...")

        success = True
        success &= self.fill_lyrics(lyrics)
        success &= self.fill_styles(styles)
        success &= self.fill_title(title)

        if success:
            logger.info("âœ“ Form fill completed successfully")
        else:
            logger.error("âŒ Form fill failed")

        return success


class SunoPersonaSelector:
    """
    Handles persona selection for Suno music creation
    """

    def __init__(self, driver):
        """
        Initialize persona selector

        Args:
            driver: Selenium WebDriver instance
        """
        self.driver = driver
        self.wait = WebDriverWait(driver, 10)

    def select_persona(self, persona_name: str) -> bool:
        """
        Select a persona by name

        Args:
            persona_name: Name of the persona to select

        Returns:
            True if successful, False otherwise
        """
        logger.info(f"Selecting persona: {persona_name}")

        try:
            # Click "Add Persona" button
            persona_btn = self.wait.until(
                EC.element_to_be_clickable((By.XPATH,
                    "//button[contains(., 'Persona') or contains(., 'Add Persona')]"))
            )
            persona_btn.click()
            time.sleep(1.5)
            logger.info("âœ“ Persona modal opened")

            # Search for persona
            search_input = self.wait.until(
                EC.element_to_be_clickable((By.XPATH,
                    "//div[contains(@class, 'chakra-modal__content')]//input[@placeholder='Search']"))
            )
            search_input.click()
            time.sleep(0.3)
            search_input.clear()
            search_input.send_keys(persona_name.lower())
            time.sleep(1.5)
            logger.info(f"âœ“ Searched for '{persona_name}'")

            # Click first valid result (exclude "Create New Persona")
            persona_containers = self.wait.until(
                EC.presence_of_all_elements_located((By.XPATH,
                    "//div[contains(@class, 'group flex w-full cursor-pointer items-center gap-4')]"))
            )

            valid_personas = []
            for container in persona_containers:
                if "Create New Persona" not in container.text:
                    valid_personas.append(container)

            if not valid_personas:
                logger.warning(f"No persona found matching '{persona_name}'")
                return False

            # Click first result
            first_result = valid_personas[0]
            self.driver.execute_script("arguments[0].scrollIntoView({block: 'center'});", first_result)
            time.sleep(0.5)
            first_result.click()
            time.sleep(1)

            logger.info(f"âœ“ Persona '{persona_name}' selected successfully")
            return True

        except Exception as e:
            logger.error(f"âŒ Failed to select persona '{persona_name}': {e}")
            return False


class SunoModeSelector:
    """
    Handles mode selection (Custom mode) for Suno
    """

    def __init__(self, driver):
        """
        Initialize mode selector

        Args:
            driver: Selenium WebDriver instance
        """
        self.driver = driver
        self.wait = WebDriverWait(driver, 10)

    def ensure_custom_mode(self) -> bool:
        """
        Ensure Custom mode is selected

        Returns:
            True if Custom mode is active, False otherwise
        """
        logger.info("Checking Custom mode...")

        try:
            # Wait for page to load
            self.wait.until(
                EC.presence_of_element_located((By.TAG_NAME, "button"))
            )

            # Find Custom button
            custom_selectors = [
                "//button[normalize-space(.)='Custom']",
                "//button[@role='button' and normalize-space(.)='Custom']",
                "//button[contains(text(), 'Custom')]",
                "//button[@aria-label='Custom']",
            ]

            custom_button = None
            for selector in custom_selectors:
                try:
                    custom_button = self.wait.until(
                        EC.element_to_be_clickable((By.XPATH, selector))
                    )
                    logger.debug(f"âœ“ Found Custom button with: {selector}")
                    break
                except TimeoutException:
                    continue

            if not custom_button:
                logger.warning("âš ï¸ Custom button not found, assuming already in Custom mode")
                return True

            # Check if already active
            is_active = (
                custom_button.get_attribute("aria-pressed") == "true" or
                custom_button.get_attribute("data-state") == "active" or
                "active" in (custom_button.get_attribute("class") or "")
            )

            if not is_active:
                logger.info("Switching to Custom mode...")
                custom_button.click()
                time.sleep(2)
                logger.info("âœ“ Switched to Custom mode")
            else:
                logger.info("âœ“ Already in Custom mode")

            return True

        except Exception as e:
            logger.warning(f"âš ï¸ Error checking Custom mode: {e}")
            return False


class SunoAdvancedOptionsConfigurator:
    """
    Handles advanced options configuration
    """

    def __init__(self, driver):
        """
        Initialize advanced options configurator

        Args:
            driver: Selenium WebDriver instance
        """
        self.driver = driver
        self.wait = WebDriverWait(driver, 10)

    def open_advanced_options(self) -> bool:
        """
        Open advanced options panel if not already open

        Returns:
            True if panel is open, False otherwise
        """
        try:
            adv_selectors = [
                "//button[normalize-space(.)='Advanced Options']",
                "//button[contains(text(), 'Advanced Options')]",
                "//button[contains(@aria-label, 'Advanced')]",
            ]

            adv_btn = None
            for selector in adv_selectors:
                try:
                    adv_btn = self.driver.find_element(By.XPATH, selector)
                    break
                except NoSuchElementException:
                    continue

            if not adv_btn:
                logger.warning("Advanced Options button not found")
                return False

            is_expanded = adv_btn.get_attribute("aria-expanded") == "true"
            if not is_expanded:
                adv_btn.click()
                time.sleep(0.5)
                logger.info("âœ“ Opened Advanced Options")
            else:
                logger.info("âœ“ Advanced Options already open")

            return True

        except Exception as e:
            logger.debug(f"Error opening Advanced Options: {e}")
            return False

    def configure_exclude_styles(self, exclude_styles: str) -> bool:
        """
        Configure exclude styles

        Args:
            exclude_styles: Styles to exclude

        Returns:
            True if successful, False otherwise
        """
        if not exclude_styles:
            return True

        logger.info(f"Setting exclude styles: {exclude_styles}")

        try:
            selectors = [
                "//input[contains(@placeholder, 'Exclude styles')]",
                "//textarea[contains(@placeholder, 'Exclude styles')]",
                "//*[@role='textbox' and contains(@placeholder, 'Exclude styles')]",
            ]

            exclude_box = None
            for selector in selectors:
                try:
                    exclude_box = self.wait.until(
                        EC.element_to_be_clickable((By.XPATH, selector))
                    )
                    break
                except TimeoutException:
                    continue

            if exclude_box:
                exclude_box.clear()
                exclude_box.send_keys(exclude_styles)
                logger.info("âœ“ Exclude styles set")
                return True
            else:
                logger.warning("Exclude styles input not found")
                return False

        except Exception as e:
            logger.warning(f"Error setting exclude styles: {e}")
            return False

    def configure_vocal_gender(self, gender: str) -> bool:
        """
        Configure vocal gender

        Args:
            gender: "Male" or "Female"

        Returns:
            True if successful, False otherwise
        """
        if not gender:
            return True

        logger.info(f"Setting vocal gender: {gender}")

        try:
            gender_btn = self.driver.find_element(
                By.XPATH,
                f"//button[normalize-space(.)='{gender}']"
            )
            gender_btn.click()
            time.sleep(0.3)
            logger.info(f"âœ“ Vocal gender set to {gender}")
            return True
        except NoSuchElementException:
            logger.warning(f"Vocal gender button '{gender}' not found")
            return False

    def configure_lyrics_mode(self, mode: str) -> bool:
        """
        Configure lyrics mode

        Args:
            mode: "Manual" or "Auto"

        Returns:
            True if successful, False otherwise
        """
        if not mode:
            return True

        logger.info(f"Setting lyrics mode: {mode}")

        try:
            mode_btn = self.driver.find_element(
                By.XPATH,
                f"//button[normalize-space(.)='{mode}']"
            )
            mode_btn.click()
            time.sleep(0.3)
            logger.info(f"âœ“ Lyrics mode set to {mode}")
            return True
        except NoSuchElementException:
            logger.warning(f"Lyrics mode button '{mode}' not found")
            return False

    def configure_weirdness(self, weirdness: int) -> bool:
        """
        Configure weirdness slider

        Args:
            weirdness: Value 0-100

        Returns:
            True if successful, False otherwise
        """
        if weirdness is None:
            return True

        logger.info(f"Setting weirdness: {weirdness}%")

        try:
            slider = self.driver.find_element(By.XPATH,
                "//input[@type='range' and contains(@aria-label, 'weirdness')]")
            self.driver.execute_script(
                "arguments[0].value = arguments[1]; arguments[0].dispatchEvent(new Event('input', { bubbles: true }));",
                slider, weirdness
            )
            logger.info(f"âœ“ Weirdness set to {weirdness}%")
            return True
        except NoSuchElementException:
            logger.warning("Weirdness slider not found")
            return False

    def configure_style_influence(self, influence: int) -> bool:
        """
        Configure style influence slider

        Args:
            influence: Value 0-100

        Returns:
            True if successful, False otherwise
        """
        if influence is None:
            return True

        logger.info(f"Setting style influence: {influence}%")

        try:
            slider = self.driver.find_element(By.XPATH,
                "//input[@type='range' and contains(@aria-label, 'style influence')]")
            self.driver.execute_script(
                "arguments[0].value = arguments[1]; arguments[0].dispatchEvent(new Event('input', { bubbles: true }));",
                slider, influence
            )
            logger.info(f"âœ“ Style influence set to {influence}%")
            return True
        except NoSuchElementException:
            logger.warning("Style influence slider not found")
            return False

    def configure_options(self, exclude_styles: Optional[str] = None,
                         vocal_gender: Optional[str] = None,
                         lyrics_mode: Optional[str] = None,
                         weirdness: Optional[int] = None,
                         style_influence: Optional[int] = None) -> bool:
        """
        Configure all advanced options

        Args:
            exclude_styles: Styles to exclude
            vocal_gender: "Male" or "Female"
            lyrics_mode: "Manual" or "Auto"
            weirdness: Weirdness level 0-100
            style_influence: Style influence 0-100

        Returns:
            True if all configurations successful
        """
        logger.info("Configuring advanced options...")

        # Open panel first
        if not self.open_advanced_options():
            return False

        success = True
        success &= self.configure_exclude_styles(exclude_styles or "")
        success &= self.configure_vocal_gender(vocal_gender or "")
        success &= self.configure_lyrics_mode(lyrics_mode or "")
        success &= self.configure_weirdness(weirdness)
        success &= self.configure_style_influence(style_influence)

        if success:
            logger.info("âœ“ Advanced options configured successfully")
        else:
            logger.warning("âš ï¸ Some advanced options failed to configure")

        return success
</file>

<file path="src/models/__init__.py">
"""
Models package
"""
from .data_models import (
    Account,
    DownloadHistory,
    SongClip,
    DownloadTask,
    QueueEntry,
    SongCreationRecord
)

__all__ = [
    'Account',
    'DownloadHistory',
    'SongClip',
    'DownloadTask',
    'QueueEntry',
    'SongCreationRecord'
]
</file>

<file path="src/models/data_models.py">
"""
Data Models
"""
from dataclasses import dataclass, field, asdict
from datetime import datetime
from typing import Any, List, Optional, Tuple
import json


@dataclass
class Account:
    """Account model"""
    name: str
    email: str
    created_at: str
    last_used: Optional[str] = None
    status: str = "active"
    
    def to_dict(self):
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: dict):
        return cls(**data)


@dataclass
class DownloadHistory:
    """Download history for an account"""
    account_name: str
    downloaded_ids: List[str] = field(default_factory=list)
    total_downloaded: int = 0
    last_download: Optional[str] = None
    current_page: int = 1
    last_profile: str = ""
    
    def add_download(self, clip_id: str):
        """Add a downloaded clip ID"""
        if clip_id not in self.downloaded_ids:
            self.downloaded_ids.append(clip_id)
            self.total_downloaded = len(self.downloaded_ids)
            self.last_download = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    def is_downloaded(self, clip_id: str) -> bool:
        """Check if clip was already downloaded"""
        return clip_id in self.downloaded_ids
    
    def clear(self):
        """Clear download history"""
        self.downloaded_ids = []
        self.total_downloaded = 0
        self.last_download = None
    
    def to_dict(self):
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: dict):
        return cls(**data)


@dataclass
class SongClip:
    """Song clip model"""
    id: str
    title: str
    audio_url: Optional[str] = None
    image_url: Optional[str] = None
    tags: str = ""
    created_at: Optional[str] = None
    duration: Optional[float] = None
    
    @classmethod
    def from_api_response(cls, data: dict):
        """Create from API response"""
        return cls(
            id=data.get('id', ''),
            title=data.get('title', 'Unknown'),
            audio_url=data.get('audio_url'),
            image_url=data.get('image_url') or data.get('image_large_url'),
            tags=data.get('metadata', {}).get('tags', ''),
            created_at=data.get('created_at'),
            duration=data.get('metadata', {}).get('duration_formatted')
        )


@dataclass
class DownloadTask:
    """Download task model"""
    clip: SongClip
    output_dir: str
    with_thumbnail: bool = True
    append_uuid: bool = True
    status: str = "pending"  # pending, downloading, completed, failed
    progress: int = 0
    error_message: Optional[str] = None
    
    def to_dict(self):
        result = asdict(self)
        result['clip'] = asdict(self.clip)
        return result


@dataclass
class QueueEntry:
    """Queue entry describing a portion of the prompt upload."""
    id: str
    account_name: str
    total_songs: int
    songs_per_batch: int
    prompts_range: Tuple[int, int]
    status: str = "pending"
    created_at: str = field(
        default_factory=lambda: datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    )
    completed_count: int = 0

    def to_dict(self) -> dict[str, Any]:
        data = asdict(self)
        data['prompts_range'] = list(self.prompts_range)
        return data

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "QueueEntry":
        prompts_range = tuple(data.get("prompts_range", (0, 0)))
        return cls(
            id=data["id"],
            account_name=data["account_name"],
            total_songs=data.get("total_songs", 0),
            songs_per_batch=data.get("songs_per_batch", 1),
            prompts_range=prompts_range,
            status=data.get("status", "pending"),
            created_at=data.get("created_at", datetime.now().strftime("%Y-%m-%d %H:%M:%S")),
            completed_count=data.get("completed_count", 0)
        )


@dataclass
class SongCreationRecord:
    """Record of a generated song for history panel tracking."""
    song_id: str
    title: str
    prompt_index: int
    account_name: str
    status: str
    created_at: str = field(
        default_factory=lambda: datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    )
    error_message: Optional[str] = None

    def to_dict(self) -> dict[str, Any]:
        return asdict(self)

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "SongCreationRecord":
        return cls(
            song_id=data["song_id"],
            title=data["title"],
            prompt_index=data["prompt_index"],
            account_name=data["account_name"],
            status=data.get("status", "pending"),
            created_at=data.get("created_at", datetime.now().strftime("%Y-%m-%d %H:%M:%S")),
            error_message=data.get("error_message")
        )
</file>

<file path="src/prompt/multiple-suno-prompt.xml">
<TITLE>Snowfall On The Vinyl</TITLE>

<LYRICS>
[Verse 1]
The needle drops, a soft hiss found
Outside the glass, the snow floats down
The tenor sax breathes a silver theme
Lost in a quiet, holiday dream
The streetlights wear a misty halo

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Verse 2]
Your shadow sways against the wall
I hear the distant church bells call
The piano chords hang in the air
A silent wish, a whispered prayer
Each note a ghost of Christmases past

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Bridge]
Time is a record, spinning slow
Every refrain, a soft afterglow
The world outside can rush and race
We've found our rhythm in this place

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Outro]
Just the brushes on the snare
And snowflakes melting in your hair
Fading...
</LYRICS>

<STYLE>Cool Jazz Christmas â€¢ 92 BPM â€¢ Tenor saxophone, piano, upright bass, brush drums, vibraphone â€¢ Mellow, urban nostalgia with a snowy afterhours vibe</STYLE>

<TITLE>UNBREAKABLE</TITLE>

<LYRICS>
[Intro] (Sound of rain and a distant thunderclap) (Dark Piano Melody begins) (Whispered): They thought I was broken... Thought I was done...

[Verse 1] (Beat drops hard, fast rap flow) Yeah, I've been through the fire, walked on the coals Fought with the demons tryin' to swallow me whole Every scar is a story, every cut is a map They wrote me off, said I'd collapse, (ha) But they don't know the steel that's inside my bones Built this kingdom all alone, sittin' on a broken throne This ain't for the fame, this ain't for the gold This is for the ones they told would never get old!

[Pre-Chorus] (Music swells, strings come in, drums build) They can push me down, down to the ground But I LOVE the sound... of the comeback! (Shouted) Can you hear it now?!

[Chorus] (Full instrumentation: Guitars, Drums, Strings, Gang Vocals) (Shouted) I AM UNBREAKABLE! (Chant) Whoa-oh-oh-oh! My spirit's a FIRE, UNQUENCHABLE! (Chant) Whoa-oh-oh-oh! I'll rise from the ashes, I'm more than this flesh Yeah, you can't kill a legend, I'm coming up fresh! I AM UNBREAKABLE!

[Verse 2] (Fast rap flow returns, guitar riff is prominent) So take your shot, yeah, give it your best Put my armor to the test, I got no time for rest While you were talkin', I was trainin' in the dark Turned all my pain into an arc, a work of art I'm the 1 in 100, the survivor, the chief The anchor of my own belief, the end of all my grief This is the new me, this is the final form The quiet center... of the storm!

[Pre-Chorus] (Music swells, strings come in, drums build) They can push me down, down to the ground But I LOVE the sound... of the comeback! (Shouted) Can you hear it now?!

[Chorus] (Full instrumentation: Guitars, Drums, Strings, Gang Vocals) (Shouted) I AM UNBREAKABLE! (Chant) Whoa-oh-oh-oh! My spirit's a FIRE, UNQUENCHABLE! (Chant) Whoa-oh-oh-oh! I'll rise from the ashes, I'm more than this flesh Yeah, you can't kill a legend, I'm coming up fresh! I AM UNBREAKABLE!

[Bridge] (Music drops to just Piano and Cinematic Strings) (Melodic singing, emotional) They tried to bury me... They didn't know... I was a seed... (Drums start to build... faster... faster...) (Shouted) I WAS A SEED! WATCH ME GROW!

[Chorus] (Maximum energy, double-time drums, guitars shredding) (Shouted) I AM UNBREAKABLE! (Chant) Whoa-oh-oh-oh! My spirit's a FIRE, UNQUENCHABLE! (Chant) Whoa-oh-oh-oh! I'll rise from the ashes, I'm more than this flesh Yeah, you can't kill a legend, I'm coming up fresh! I AM UNBREAKABLE!

[Outro] (Music swells to a final crash) (Chant) Whoa-oh-oh-oh! (Shouted) UNBREAKABLE! (Sound of a final guitar chord and thunderclap)
</LYRICS>

<STYLE>motivational hip-hop, dark electronic, arena rock</STYLE>

<TITLE>Echoes Fade</TITLE>

<LYRICS>
[Piano Intro] (Soft, atmospheric piano and strings)

[Verse 1: Female Vocals] (Soft, reflective) I built these walls up, stone by stone Learned how to make it on my own The ghosts of goodbye, they haunt this room Afraid to let a new flower bloom

[Verse 2: Male Vocals] (Matching energy, drums enter softly) I wear the armor, hide the scars Wished on a million broken stars This fragile trust, it's hard to find When you've been the one left behind

[Pre-Chorus: Duet] (Harmonizing, building tension) (Female): But I see the truth inside your eyes (Male): We're tired of living in disguise (Duet): What if we let the past ignite?

[Chorus: Duet, Anthemic] (Drums kick in, strings swell, full power) Let's let the echoes fade tonight Run from the shadow, find the light I won't give up, I won't give in This is where our new story begins We've said our last goodbyes Set fire to the old lies This time, I'm not letting go This time, I'm not letting go

[Verse 3: Female Vocals] (Stronger, more confident) You trace the lines upon my hand You're the one who understands The wreckage of what came before You're standing at the open door

[Pre-Chorus: Duet] (Harmonizing, building again) (Female): I see the future in your eyes (Male): No more excuses, no more lies (Duet): It's time to let our new life rise

[Chorus: Duet, Anthemic] (Full power, soaring vocals) Let's let the echoes fade tonight Run from the shadow, find the light I won't give up, I won't give in This is where our new story begins We've said our last goodbyes Set fire to the old lies This time, I'm not letting go This time, I'm not letting go

[Bridge: Duet] (Music drops slightly, then builds massively) (Female): We can't erase all the pain (Male): But we can learn to live again (Duet): Through all the thunder, all the rain (Female): I won't let go! (Male): I won't let go!

[Guitar Solo] (Epic, melodic, emotional guitar solo over heavy drums and strings)

[Chorus: Duet, Anthemic] (Biggest chorus, ad-libs) Let's let the echoes fade tonight Run from the shadow, find the light I won't give up, I won't give in This is where our new story begins We've said our last goodbyes Set fire to the old lies This time, I'm not letting go This time, I'm not letting go

[Outro: Duet] (Fading out with piano and strings) (Female): Just let the echoes go... (Male): I'm not letting go... (Duet): This time... we won't let go. (Piano fades to nothing)
</LYRICS>

<STYLE>pop rock, power ballad, epic ballad</STYLE>

<TITLE>Snowfall On The Vinyl</TITLE>

<LYRICS>
[Verse 1]
The needle drops, a soft hiss found
Outside the glass, the snow floats down
The tenor sax breathes a silver theme
Lost in a quiet, holiday dream
The streetlights wear a misty halo

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Verse 2]
Your shadow sways against the wall
I hear the distant church bells call
The piano chords hang in the air
A silent wish, a whispered prayer
Each note a ghost of Christmases past

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Bridge]
Time is a record, spinning slow
Every refrain, a soft afterglow
The world outside can rush and race
We've found our rhythm in this place

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Outro]
Just the brushes on the snare
And snowflakes melting in your hair
Fading...
</LYRICS>

<STYLE>Cool Jazz Christmas â€¢ 92 BPM â€¢ Tenor saxophone, piano, upright bass, brush drums, vibraphone â€¢ Mellow, urban nostalgia with a snowy afterhours vibe</STYLE>

<TITLE>Snowfall On The Vinyl</TITLE>

<LYRICS>
[Verse 1]
The needle drops, a soft hiss found
Outside the glass, the snow floats down
The tenor sax breathes a silver theme
Lost in a quiet, holiday dream
The streetlights wear a misty halo

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Verse 2]
Your shadow sways against the wall
I hear the distant church bells call
The piano chords hang in the air
A silent wish, a whispered prayer
Each note a ghost of Christmases past

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Bridge]
Time is a record, spinning slow
Every refrain, a soft afterglow
The world outside can rush and race
We've found our rhythm in this place

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Outro]
Just the brushes on the snare
And snowflakes melting in your hair
Fading...
</LYRICS>

<STYLE>Cool Jazz Christmas â€¢ 92 BPM â€¢ Tenor saxophone, piano, upright bass, brush drums, vibraphone â€¢ Mellow, urban nostalgia with a snowy afterhours vibe</STYLE>

<TITLE>Snowfall On The Vinyl</TITLE>

<LYRICS>
[Verse 1]
The needle drops, a soft hiss found
Outside the glass, the snow floats down
The tenor sax breathes a silver theme
Lost in a quiet, holiday dream
The streetlights wear a misty halo

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Verse 2]
Your shadow sways against the wall
I hear the distant church bells call
The piano chords hang in the air
A silent wish, a whispered prayer
Each note a ghost of Christmases past

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Bridge]
Time is a record, spinning slow
Every refrain, a soft afterglow
The world outside can rush and race
We've found our rhythm in this place

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Outro]
Just the brushes on the snare
And snowflakes melting in your hair
Fading...
</LYRICS>

<STYLE>Cool Jazz Christmas â€¢ 92 BPM â€¢ Tenor saxophone, piano, upright bass, brush drums, vibraphone â€¢ Mellow, urban nostalgia with a snowy afterhours vibe</STYLE>

<TITLE>Snowfall On The Vinyl</TITLE>

<LYRICS>
[Verse 1]
The needle drops, a soft hiss found
Outside the glass, the snow floats down
The tenor sax breathes a silver theme
Lost in a quiet, holiday dream
The streetlights wear a misty halo

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Verse 2]
Your shadow sways against the wall
I hear the distant church bells call
The piano chords hang in the air
A silent wish, a whispered prayer
Each note a ghost of Christmases past

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Bridge]
Time is a record, spinning slow
Every refrain, a soft afterglow
The world outside can rush and race
We've found our rhythm in this place

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Outro]
Just the brushes on the snare
And snowflakes melting in your hair
Fading...
</LYRICS>

<STYLE>Cool Jazz Christmas â€¢ 92 BPM â€¢ Tenor saxophone, piano, upright bass, brush drums, vibraphone â€¢ Mellow, urban nostalgia with a snowy afterhours vibe</STYLE>

<TITLE>Snowfall On The Vinyl</TITLE>

<LYRICS>
[Verse 1]
The needle drops, a soft hiss found
Outside the glass, the snow floats down
The tenor sax breathes a silver theme
Lost in a quiet, holiday dream
The streetlights wear a misty halo

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Verse 2]
Your shadow sways against the wall
I hear the distant church bells call
The piano chords hang in the air
A silent wish, a whispered prayer
Each note a ghost of Christmases past

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Bridge]
Time is a record, spinning slow
Every refrain, a soft afterglow
The world outside can rush and race
We've found our rhythm in this place

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Outro]
Just the brushes on the snare
And snowflakes melting in your hair
Fading...
</LYRICS>

<STYLE>Cool Jazz Christmas â€¢ 92 BPM â€¢ Tenor saxophone, piano, upright bass, brush drums, vibraphone â€¢ Mellow, urban nostalgia with a snowy afterhours vibe</STYLE>

<TITLE>Snowfall On The Vinyl</TITLE>

<LYRICS>
[Verse 1]
The needle drops, a soft hiss found
Outside the glass, the snow floats down
The tenor sax breathes a silver theme
Lost in a quiet, holiday dream
The streetlights wear a misty halo

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Verse 2]
Your shadow sways against the wall
I hear the distant church bells call
The piano chords hang in the air
A silent wish, a whispered prayer
Each note a ghost of Christmases past

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Bridge]
Time is a record, spinning slow
Every refrain, a soft afterglow
The world outside can rush and race
We've found our rhythm in this place

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Outro]
Just the brushes on the snare
And snowflakes melting in your hair
Fading...
</LYRICS>

<STYLE>Cool Jazz Christmas â€¢ 92 BPM â€¢ Tenor saxophone, piano, upright bass, brush drums, vibraphone â€¢ Mellow, urban nostalgia with a snowy afterhours vibe</STYLE>

<TITLE>Snowfall On The Vinyl</TITLE>

<LYRICS>
[Verse 1]
The needle drops, a soft hiss found
Outside the glass, the snow floats down
The tenor sax breathes a silver theme
Lost in a quiet, holiday dream
The streetlights wear a misty halo

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Verse 2]
Your shadow sways against the wall
I hear the distant church bells call
The piano chords hang in the air
A silent wish, a whispered prayer
Each note a ghost of Christmases past

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Bridge]
Time is a record, spinning slow
Every refrain, a soft afterglow
The world outside can rush and race
We've found our rhythm in this place

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Outro]
Just the brushes on the snare
And snowflakes melting in your hair
Fading...
</LYRICS>

<STYLE>Cool Jazz Christmas â€¢ 92 BPM â€¢ Tenor saxophone, piano, upright bass, brush drums, vibraphone â€¢ Mellow, urban nostalgia with a snowy afterhours vibe</STYLE>

<TITLE>Snowfall On The Vinyl</TITLE>

<LYRICS>
[Verse 1]
The needle drops, a soft hiss found
Outside the glass, the snow floats down
The tenor sax breathes a silver theme
Lost in a quiet, holiday dream
The streetlights wear a misty halo

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Verse 2]
Your shadow sways against the wall
I hear the distant church bells call
The piano chords hang in the air
A silent wish, a whispered prayer
Each note a ghost of Christmases past

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Bridge]
Time is a record, spinning slow
Every refrain, a soft afterglow
The world outside can rush and race
We've found our rhythm in this place

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Outro]
Just the brushes on the snare
And snowflakes melting in your hair
Fading...
</LYRICS>

<STYLE>Cool Jazz Christmas â€¢ 92 BPM â€¢ Tenor saxophone, piano, upright bass, brush drums, vibraphone â€¢ Mellow, urban nostalgia with a snowy afterhours vibe</STYLE>

<TITLE>Snowfall On The Vinyl</TITLE>

<LYRICS>
[Verse 1]
The needle drops, a soft hiss found
Outside the glass, the snow floats down
The tenor sax breathes a silver theme
Lost in a quiet, holiday dream
The streetlights wear a misty halo

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Verse 2]
Your shadow sways against the wall
I hear the distant church bells call
The piano chords hang in the air
A silent wish, a whispered prayer
Each note a ghost of Christmases past

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Bridge]
Time is a record, spinning slow
Every refrain, a soft afterglow
The world outside can rush and race
We've found our rhythm in this place

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Outro]
Just the brushes on the snare
And snowflakes melting in your hair
Fading...
</LYRICS>

<STYLE>Cool Jazz Christmas â€¢ 92 BPM â€¢ Tenor saxophone, piano, upright bass, brush drums, vibraphone â€¢ Mellow, urban nostalgia with a snowy afterhours vibe</STYLE>

<TITLE>Snowfall On The Vinyl</TITLE>

<LYRICS>
[Verse 1]
The needle drops, a soft hiss found
Outside the glass, the snow floats down
The tenor sax breathes a silver theme
Lost in a quiet, holiday dream
The streetlights wear a misty halo

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Verse 2]
Your shadow sways against the wall
I hear the distant church bells call
The piano chords hang in the air
A silent wish, a whispered prayer
Each note a ghost of Christmases past

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Bridge]
Time is a record, spinning slow
Every refrain, a soft afterglow
The world outside can rush and race
We've found our rhythm in this place

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Outro]
Just the brushes on the snare
And snowflakes melting in your hair
Fading...
</LYRICS>

<STYLE>Cool Jazz Christmas â€¢ 92 BPM â€¢ Tenor saxophone, piano, upright bass, brush drums, vibraphone â€¢ Mellow, urban nostalgia with a snowy afterhours vibe</STYLE>

<TITLE>Snowfall On The Vinyl</TITLE>

<LYRICS>
[Verse 1]
The needle drops, a soft hiss found
Outside the glass, the snow floats down
The tenor sax breathes a silver theme
Lost in a quiet, holiday dream
The streetlights wear a misty halo

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Verse 2]
Your shadow sways against the wall
I hear the distant church bells call
The piano chords hang in the air
A silent wish, a whispered prayer
Each note a ghost of Christmases past

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Bridge]
Time is a record, spinning slow
Every refrain, a soft afterglow
The world outside can rush and race
We've found our rhythm in this place

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Outro]
Just the brushes on the snare
And snowflakes melting in your hair
Fading...
</LYRICS>

<STYLE>Cool Jazz Christmas â€¢ 92 BPM â€¢ Tenor saxophone, piano, upright bass, brush drums, vibraphone â€¢ Mellow, urban nostalgia with a snowy afterhours vibe</STYLE>

<TITLE>Snowfall On The Vinyl</TITLE>

<LYRICS>
[Verse 1]
The needle drops, a soft hiss found
Outside the glass, the snow floats down
The tenor sax breathes a silver theme
Lost in a quiet, holiday dream
The streetlights wear a misty halo

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Verse 2]
Your shadow sways against the wall
I hear the distant church bells call
The piano chords hang in the air
A silent wish, a whispered prayer
Each note a ghost of Christmases past

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Bridge]
Time is a record, spinning slow
Every refrain, a soft afterglow
The world outside can rush and race
We've found our rhythm in this place

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Outro]
Just the brushes on the snare
And snowflakes melting in your hair
Fading...
</LYRICS>

<STYLE>Cool Jazz Christmas â€¢ 92 BPM â€¢ Tenor saxophone, piano, upright bass, brush drums, vibraphone â€¢ Mellow, urban nostalgia with a snowy afterhours vibe</STYLE>

<TITLE>Snowfall On The Vinyl</TITLE>

<LYRICS>
[Verse 1]
The needle drops, a soft hiss found
Outside the glass, the snow floats down
The tenor sax breathes a silver theme
Lost in a quiet, holiday dream
The streetlights wear a misty halo

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Verse 2]
Your shadow sways against the wall
I hear the distant church bells call
The piano chords hang in the air
A silent wish, a whispered prayer
Each note a ghost of Christmases past

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Bridge]
Time is a record, spinning slow
Every refrain, a soft afterglow
The world outside can rush and race
We've found our rhythm in this place

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Outro]
Just the brushes on the snare
And snowflakes melting in your hair
Fading...
</LYRICS>

<STYLE>Cool Jazz Christmas â€¢ 92 BPM â€¢ Tenor saxophone, piano, upright bass, brush drums, vibraphone â€¢ Mellow, urban nostalgia with a snowy afterhours vibe</STYLE>

<TITLE>Snowfall On The Vinyl</TITLE>

<LYRICS>
[Verse 1]
The needle drops, a soft hiss found
Outside the glass, the snow floats down
The tenor sax breathes a silver theme
Lost in a quiet, holiday dream
The streetlights wear a misty halo

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Verse 2]
Your shadow sways against the wall
I hear the distant church bells call
The piano chords hang in the air
A silent wish, a whispered prayer
Each note a ghost of Christmases past

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Bridge]
Time is a record, spinning slow
Every refrain, a soft afterglow
The world outside can rush and race
We've found our rhythm in this place

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Outro]
Just the brushes on the snare
And snowflakes melting in your hair
Fading...
</LYRICS>

<STYLE>Cool Jazz Christmas â€¢ 92 BPM â€¢ Tenor saxophone, piano, upright bass, brush drums, vibraphone â€¢ Mellow, urban nostalgia with a snowy afterhours vibe</STYLE>

<TITLE>Snowfall On The Vinyl</TITLE>

<LYRICS>
[Verse 1]
The needle drops, a soft hiss found
Outside the glass, the snow floats down
The tenor sax breathes a silver theme
Lost in a quiet, holiday dream
The streetlights wear a misty halo

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Verse 2]
Your shadow sways against the wall
I hear the distant church bells call
The piano chords hang in the air
A silent wish, a whispered prayer
Each note a ghost of Christmases past

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Bridge]
Time is a record, spinning slow
Every refrain, a soft afterglow
The world outside can rush and race
We've found our rhythm in this place

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Outro]
Just the brushes on the snare
And snowflakes melting in your hair
Fading...
</LYRICS>

<STYLE>Cool Jazz Christmas â€¢ 92 BPM â€¢ Tenor saxophone, piano, upright bass, brush drums, vibraphone â€¢ Mellow, urban nostalgia with a snowy afterhours vibe</STYLE>

<TITLE>Snowfall On The Vinyl</TITLE>

<LYRICS>
[Verse 1]
The needle drops, a soft hiss found
Outside the glass, the snow floats down
The tenor sax breathes a silver theme
Lost in a quiet, holiday dream
The streetlights wear a misty halo

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Verse 2]
Your shadow sways against the wall
I hear the distant church bells call
The piano chords hang in the air
A silent wish, a whispered prayer
Each note a ghost of Christmases past

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Bridge]
Time is a record, spinning slow
Every refrain, a soft afterglow
The world outside can rush and race
We've found our rhythm in this place

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Outro]
Just the brushes on the snare
And snowflakes melting in your hair
Fading...
</LYRICS>

<STYLE>Cool Jazz Christmas â€¢ 92 BPM â€¢ Tenor saxophone, piano, upright bass, brush drums, vibraphone â€¢ Mellow, urban nostalgia with a snowy afterhours vibe</STYLE>

<TITLE>Snowfall On The Vinyl</TITLE>

<LYRICS>
[Verse 1]
The needle drops, a soft hiss found
Outside the glass, the snow floats down
The tenor sax breathes a silver theme
Lost in a quiet, holiday dream
The streetlights wear a misty halo

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Verse 2]
Your shadow sways against the wall
I hear the distant church bells call
The piano chords hang in the air
A silent wish, a whispered prayer
Each note a ghost of Christmases past

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Bridge]
Time is a record, spinning slow
Every refrain, a soft afterglow
The world outside can rush and race
We've found our rhythm in this place

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Outro]
Just the brushes on the snare
And snowflakes melting in your hair
Fading...
</LYRICS>

<STYLE>Cool Jazz Christmas â€¢ 92 BPM â€¢ Tenor saxophone, piano, upright bass, brush drums, vibraphone â€¢ Mellow, urban nostalgia with a snowy afterhours vibe</STYLE>

<TITLE>Snowfall On The Vinyl</TITLE>

<LYRICS>
[Verse 1]
The needle drops, a soft hiss found
Outside the glass, the snow floats down
The tenor sax breathes a silver theme
Lost in a quiet, holiday dream
The streetlights wear a misty halo

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Verse 2]
Your shadow sways against the wall
I hear the distant church bells call
The piano chords hang in the air
A silent wish, a whispered prayer
Each note a ghost of Christmases past

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Bridge]
Time is a record, spinning slow
Every refrain, a soft afterglow
The world outside can rush and race
We've found our rhythm in this place

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Outro]
Just the brushes on the snare
And snowflakes melting in your hair
Fading...
</LYRICS>

<STYLE>Cool Jazz Christmas â€¢ 92 BPM â€¢ Tenor saxophone, piano, upright bass, brush drums, vibraphone â€¢ Mellow, urban nostalgia with a snowy afterhours vibe</STYLE>

<TITLE>Snowfall On The Vinyl</TITLE>

<LYRICS>
[Verse 1]
The needle drops, a soft hiss found
Outside the glass, the snow floats down
The tenor sax breathes a silver theme
Lost in a quiet, holiday dream
The streetlights wear a misty halo

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Verse 2]
Your shadow sways against the wall
I hear the distant church bells call
The piano chords hang in the air
A silent wish, a whispered prayer
Each note a ghost of Christmases past

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Bridge]
Time is a record, spinning slow
Every refrain, a soft afterglow
The world outside can rush and race
We've found our rhythm in this place

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Outro]
Just the brushes on the snare
And snowflakes melting in your hair
Fading...
</LYRICS>

<STYLE>Cool Jazz Christmas â€¢ 92 BPM â€¢ Tenor saxophone, piano, upright bass, brush drums, vibraphone â€¢ Mellow, urban nostalgia with a snowy afterhours vibe</STYLE>

<TITLE>Snowfall On The Vinyl</TITLE>

<LYRICS>
[Verse 1]
The needle drops, a soft hiss found
Outside the glass, the snow floats down
The tenor sax breathes a silver theme
Lost in a quiet, holiday dream
The streetlights wear a misty halo

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Verse 2]
Your shadow sways against the wall
I hear the distant church bells call
The piano chords hang in the air
A silent wish, a whispered prayer
Each note a ghost of Christmases past

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Bridge]
Time is a record, spinning slow
Every refrain, a soft afterglow
The world outside can rush and race
We've found our rhythm in this place

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Outro]
Just the brushes on the snare
And snowflakes melting in your hair
Fading...
</LYRICS>

<STYLE>Cool Jazz Christmas â€¢ 92 BPM â€¢ Tenor saxophone, piano, upright bass, brush drums, vibraphone â€¢ Mellow, urban nostalgia with a snowy afterhours vibe</STYLE>

<TITLE>Snowfall On The Vinyl</TITLE>

<LYRICS>
[Verse 1]
The needle drops, a soft hiss found
Outside the glass, the snow floats down
The tenor sax breathes a silver theme
Lost in a quiet, holiday dream
The streetlights wear a misty halo

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Verse 2]
Your shadow sways against the wall
I hear the distant church bells call
The piano chords hang in the air
A silent wish, a whispered prayer
Each note a ghost of Christmases past

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Bridge]
Time is a record, spinning slow
Every refrain, a soft afterglow
The world outside can rush and race
We've found our rhythm in this place

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Outro]
Just the brushes on the snare
And snowflakes melting in your hair
Fading...
</LYRICS>

<STYLE>Cool Jazz Christmas â€¢ 92 BPM â€¢ Tenor saxophone, piano, upright bass, brush drums, vibraphone â€¢ Mellow, urban nostalgia with a snowy afterhours vibe</STYLE>

<TITLE>Snowfall On The Vinyl</TITLE>

<LYRICS>
[Verse 1]
The needle drops, a soft hiss found
Outside the glass, the snow floats down
The tenor sax breathes a silver theme
Lost in a quiet, holiday dream
The streetlights wear a misty halo

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Verse 2]
Your shadow sways against the wall
I hear the distant church bells call
The piano chords hang in the air
A silent wish, a whispered prayer
Each note a ghost of Christmases past

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Bridge]
Time is a record, spinning slow
Every refrain, a soft afterglow
The world outside can rush and race
We've found our rhythm in this place

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Outro]
Just the brushes on the snare
And snowflakes melting in your hair
Fading...
</LYRICS>

<STYLE>Cool Jazz Christmas â€¢ 92 BPM â€¢ Tenor saxophone, piano, upright bass, brush drums, vibraphone â€¢ Mellow, urban nostalgia with a snowy afterhours vibe</STYLE>

<TITLE>Snowfall On The Vinyl</TITLE>

<LYRICS>
[Verse 1]
The needle drops, a soft hiss found
Outside the glass, the snow floats down
The tenor sax breathes a silver theme
Lost in a quiet, holiday dream
The streetlights wear a misty halo

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Verse 2]
Your shadow sways against the wall
I hear the distant church bells call
The piano chords hang in the air
A silent wish, a whispered prayer
Each note a ghost of Christmases past

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Bridge]
Time is a record, spinning slow
Every refrain, a soft afterglow
The world outside can rush and race
We've found our rhythm in this place

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Outro]
Just the brushes on the snare
And snowflakes melting in your hair
Fading...
</LYRICS>

<STYLE>Cool Jazz Christmas â€¢ 92 BPM â€¢ Tenor saxophone, piano, upright bass, brush drums, vibraphone â€¢ Mellow, urban nostalgia with a snowy afterhours vibe</STYLE>

<TITLE>Snowfall On The Vinyl</TITLE>

<LYRICS>
[Verse 1]
The needle drops, a soft hiss found
Outside the glass, the snow floats down
The tenor sax breathes a silver theme
Lost in a quiet, holiday dream
The streetlights wear a misty halo

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Verse 2]
Your shadow sways against the wall
I hear the distant church bells call
The piano chords hang in the air
A silent wish, a whispered prayer
Each note a ghost of Christmases past

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Bridge]
Time is a record, spinning slow
Every refrain, a soft afterglow
The world outside can rush and race
We've found our rhythm in this place

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Outro]
Just the brushes on the snare
And snowflakes melting in your hair
Fading...
</LYRICS>

<STYLE>Cool Jazz Christmas â€¢ 92 BPM â€¢ Tenor saxophone, piano, upright bass, brush drums, vibraphone â€¢ Mellow, urban nostalgia with a snowy afterhours vibe</STYLE>

<TITLE>Snowfall On The Vinyl</TITLE>

<LYRICS>
[Verse 1]
The needle drops, a soft hiss found
Outside the glass, the snow floats down
The tenor sax breathes a silver theme
Lost in a quiet, holiday dream
The streetlights wear a misty halo

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Verse 2]
Your shadow sways against the wall
I hear the distant church bells call
The piano chords hang in the air
A silent wish, a whispered prayer
Each note a ghost of Christmases past

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Bridge]
Time is a record, spinning slow
Every refrain, a soft afterglow
The world outside can rush and race
We've found our rhythm in this place

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Outro]
Just the brushes on the snare
And snowflakes melting in your hair
Fading...
</LYRICS>

<STYLE>Cool Jazz Christmas â€¢ 92 BPM â€¢ Tenor saxophone, piano, upright bass, brush drums, vibraphone â€¢ Mellow, urban nostalgia with a snowy afterhours vibe</STYLE>

<TITLE>Snowfall On The Vinyl</TITLE>

<LYRICS>
[Verse 1]
The needle drops, a soft hiss found
Outside the glass, the snow floats down
The tenor sax breathes a silver theme
Lost in a quiet, holiday dream
The streetlights wear a misty halo

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Verse 2]
Your shadow sways against the wall
I hear the distant church bells call
The piano chords hang in the air
A silent wish, a whispered prayer
Each note a ghost of Christmases past

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Bridge]
Time is a record, spinning slow
Every refrain, a soft afterglow
The world outside can rush and race
We've found our rhythm in this place

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Outro]
Just the brushes on the snare
And snowflakes melting in your hair
Fading...
</LYRICS>

<STYLE>Cool Jazz Christmas â€¢ 92 BPM â€¢ Tenor saxophone, piano, upright bass, brush drums, vibraphone â€¢ Mellow, urban nostalgia with a snowy afterhours vibe</STYLE>

<TITLE>Snowfall On The Vinyl</TITLE>

<LYRICS>
[Verse 1]
The needle drops, a soft hiss found
Outside the glass, the snow floats down
The tenor sax breathes a silver theme
Lost in a quiet, holiday dream
The streetlights wear a misty halo

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Verse 2]
Your shadow sways against the wall
I hear the distant church bells call
The piano chords hang in the air
A silent wish, a whispered prayer
Each note a ghost of Christmases past

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Bridge]
Time is a record, spinning slow
Every refrain, a soft afterglow
The world outside can rush and race
We've found our rhythm in this place

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Outro]
Just the brushes on the snare
And snowflakes melting in your hair
Fading...
</LYRICS>

<STYLE>Cool Jazz Christmas â€¢ 92 BPM â€¢ Tenor saxophone, piano, upright bass, brush drums, vibraphone â€¢ Mellow, urban nostalgia with a snowy afterhours vibe</STYLE>

<TITLE>Snowfall On The Vinyl</TITLE>

<LYRICS>
[Verse 1]
The needle drops, a soft hiss found
Outside the glass, the snow floats down
The tenor sax breathes a silver theme
Lost in a quiet, holiday dream
The streetlights wear a misty halo

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Verse 2]
Your shadow sways against the wall
I hear the distant church bells call
The piano chords hang in the air
A silent wish, a whispered prayer
Each note a ghost of Christmases past

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Bridge]
Time is a record, spinning slow
Every refrain, a soft afterglow
The world outside can rush and race
We've found our rhythm in this place

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Outro]
Just the brushes on the snare
And snowflakes melting in your hair
Fading...
</LYRICS>

<STYLE>Cool Jazz Christmas â€¢ 92 BPM â€¢ Tenor saxophone, piano, upright bass, brush drums, vibraphone â€¢ Mellow, urban nostalgia with a snowy afterhours vibe</STYLE>

<TITLE>Snowfall On The Vinyl</TITLE>

<LYRICS>
[Verse 1]
The needle drops, a soft hiss found
Outside the glass, the snow floats down
The tenor sax breathes a silver theme
Lost in a quiet, holiday dream
The streetlights wear a misty halo

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Verse 2]
Your shadow sways against the wall
I hear the distant church bells call
The piano chords hang in the air
A silent wish, a whispered prayer
Each note a ghost of Christmases past

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Bridge]
Time is a record, spinning slow
Every refrain, a soft afterglow
The world outside can rush and race
We've found our rhythm in this place

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Outro]
Just the brushes on the snare
And snowflakes melting in your hair
Fading...
</LYRICS>

<STYLE>Cool Jazz Christmas â€¢ 92 BPM â€¢ Tenor saxophone, piano, upright bass, brush drums, vibraphone â€¢ Mellow, urban nostalgia with a snowy afterhours vibe</STYLE>

<TITLE>Snowfall On The Vinyl</TITLE>

<LYRICS>
[Verse 1]
The needle drops, a soft hiss found
Outside the glass, the snow floats down
The tenor sax breathes a silver theme
Lost in a quiet, holiday dream
The streetlights wear a misty halo

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Verse 2]
Your shadow sways against the wall
I hear the distant church bells call
The piano chords hang in the air
A silent wish, a whispered prayer
Each note a ghost of Christmases past

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Bridge]
Time is a record, spinning slow
Every refrain, a soft afterglow
The world outside can rush and race
We've found our rhythm in this place

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Outro]
Just the brushes on the snare
And snowflakes melting in your hair
Fading...
</LYRICS>

<STYLE>Cool Jazz Christmas â€¢ 92 BPM â€¢ Tenor saxophone, piano, upright bass, brush drums, vibraphone â€¢ Mellow, urban nostalgia with a snowy afterhours vibe</STYLE>

<TITLE>Snowfall On The Vinyl</TITLE>

<LYRICS>
[Verse 1]
The needle drops, a soft hiss found
Outside the glass, the snow floats down
The tenor sax breathes a silver theme
Lost in a quiet, holiday dream
The streetlights wear a misty halo

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Verse 2]
Your shadow sways against the wall
I hear the distant church bells call
The piano chords hang in the air
A silent wish, a whispered prayer
Each note a ghost of Christmases past

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Bridge]
Time is a record, spinning slow
Every refrain, a soft afterglow
The world outside can rush and race
We've found our rhythm in this place

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Outro]
Just the brushes on the snare
And snowflakes melting in your hair
Fading...
</LYRICS>

<STYLE>Cool Jazz Christmas â€¢ 92 BPM â€¢ Tenor saxophone, piano, upright bass, brush drums, vibraphone â€¢ Mellow, urban nostalgia with a snowy afterhours vibe</STYLE>

<TITLE>Snowfall On The Vinyl</TITLE>

<LYRICS>
[Verse 1]
The needle drops, a soft hiss found
Outside the glass, the snow floats down
The tenor sax breathes a silver theme
Lost in a quiet, holiday dream
The streetlights wear a misty halo

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Verse 2]
Your shadow sways against the wall
I hear the distant church bells call
The piano chords hang in the air
A silent wish, a whispered prayer
Each note a ghost of Christmases past

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Bridge]
Time is a record, spinning slow
Every refrain, a soft afterglow
The world outside can rush and race
We've found our rhythm in this place

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Outro]
Just the brushes on the snare
And snowflakes melting in your hair
Fading...
</LYRICS>

<STYLE>Cool Jazz Christmas â€¢ 92 BPM â€¢ Tenor saxophone, piano, upright bass, brush drums, vibraphone â€¢ Mellow, urban nostalgia with a snowy afterhours vibe</STYLE>

<TITLE>Snowfall On The Vinyl</TITLE>

<LYRICS>
[Verse 1]
The needle drops, a soft hiss found
Outside the glass, the snow floats down
The tenor sax breathes a silver theme
Lost in a quiet, holiday dream
The streetlights wear a misty halo

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Verse 2]
Your shadow sways against the wall
I hear the distant church bells call
The piano chords hang in the air
A silent wish, a whispered prayer
Each note a ghost of Christmases past

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Bridge]
Time is a record, spinning slow
Every refrain, a soft afterglow
The world outside can rush and race
We've found our rhythm in this place

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Outro]
Just the brushes on the snare
And snowflakes melting in your hair
Fading...
</LYRICS>

<STYLE>Cool Jazz Christmas â€¢ 92 BPM â€¢ Tenor saxophone, piano, upright bass, brush drums, vibraphone â€¢ Mellow, urban nostalgia with a snowy afterhours vibe</STYLE>

<TITLE>Snowfall On The Vinyl</TITLE>

<LYRICS>
[Verse 1]
The needle drops, a soft hiss found
Outside the glass, the snow floats down
The tenor sax breathes a silver theme
Lost in a quiet, holiday dream
The streetlights wear a misty halo

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Verse 2]
Your shadow sways against the wall
I hear the distant church bells call
The piano chords hang in the air
A silent wish, a whispered prayer
Each note a ghost of Christmases past

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Bridge]
Time is a record, spinning slow
Every refrain, a soft afterglow
The world outside can rush and race
We've found our rhythm in this place

[Chorus]
This city sleeps in shades of blue
A cool jazz Christmas, me and you

[Outro]
Just the brushes on the snare
And snowflakes melting in your hair
Fading...
</LYRICS>

<STYLE>Cool Jazz Christmas â€¢ 92 BPM â€¢ Tenor saxophone, piano, upright bass, brush drums, vibraphone â€¢ Mellow, urban nostalgia with a snowy afterhours vibe</STYLE>
</file>

<file path="src/prompt/suno-prompt.xml">
<TITLE>lilies in the pond.</TITLE>

<LYRICS>
she said, darling how do i look tonight
through fogged glass lenses,
with a sigh, like doom waltzing into my life
you never have to try

     we go hand in hand
     we're both skeletons
     watch the lilies in the pond
     what a fine inheritance

          a bit of blood on the table
          bit of blood on your dress
          we should leave if we're able
          or we can drink to excess

it's a gold chain against your skin
it's all the things we'll never do or say again
it's a fire's roar of discontent
it's a start to know your heart's every dark intent

     we go hand in hand
     we're both skeletons
     watch the lilies in the pond
     what a fine inheritance

          a bit of blood on the table
          bit of blood on your dress
          we should leave if we're able
          or we can drink to excess

wear your true face
     please just wear your true face
through desperate straits
     can you ever know grace
wear your true face
     please just wear your true face
through desperate straits
     can you ever know grace

a bit of blood on the table
bit of blood on your dress
we should leave if we're able
or we can drink to excess

      i know your eyes
      seen your past lives
      but you don't know mine
      you don't know mine

i know your eyes
seen your past lives
but you don't know mine
well, you know, that's fine
</LYRICS>

<STYLE>indie, shoegaze, baroque pop, experimental, worldbeat, dreamy, cassette, strange, weird</STYLE>
</file>

<file path="src/ui/__init__.py">
"""
UI Package
"""
from __future__ import annotations

__all__ = ['MainWindow', 'run_app']


def __getattr__(name: str):
    if name == "MainWindow":
        from .main_window import MainWindow
        return MainWindow
    if name == "run_app":
        from .main_window import run_app
        return run_app
    raise AttributeError(f"module {__name__} has no attribute {name}")
</file>

<file path="src/ui/account_panel.py">
"""
Account Panel - Quáº£n lÃ½ tÃ i khoáº£n
"""
import customtkinter as ctk
from tkinter import messagebox
import threading
import time

from selenium.common.exceptions import WebDriverException

from src.core import AccountManager, SessionManager
from src.utils import format_datetime, logger


class AccountPanel(ctk.CTkFrame):
    """Panel quáº£n lÃ½ tÃ i khoáº£n"""
    
    def __init__(self, parent, account_manager: AccountManager, session_manager: SessionManager):
        super().__init__(parent)
        
        self.account_manager = account_manager
        self.session_manager = session_manager
        
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(1, weight=1)
        
        self.create_ui()
    
    def create_ui(self):
        """Create UI components"""
        
        # Header
        header_frame = ctk.CTkFrame(self)
        header_frame.grid(row=0, column=0, sticky="ew", pady=(0, 20))
        header_frame.grid_columnconfigure(0, weight=1)
        
        title = ctk.CTkLabel(
            header_frame,
            text="Quáº£n lÃ½ tÃ i khoáº£n",
            font=ctk.CTkFont(size=24, weight="bold")
        )
        title.grid(row=0, column=0, sticky="w", padx=20, pady=20)
        
        # Buttons
        btn_frame = ctk.CTkFrame(header_frame)
        btn_frame.grid(row=0, column=1, padx=20, pady=20)
        
        add_btn = ctk.CTkButton(
            btn_frame,
            text="ThÃªm tÃ i khoáº£n",
            command=self.add_account,
            width=150
        )
        add_btn.grid(row=0, column=0, padx=5)
        
        refresh_btn = ctk.CTkButton(
            btn_frame,
            text="LÃ m má»›i",
            command=self.refresh,
            width=120
        )
        refresh_btn.grid(row=0, column=1, padx=5)
        
        # Account list
        list_frame = ctk.CTkFrame(self)
        list_frame.grid(row=1, column=0, sticky="nsew", padx=20, pady=(0, 20))
        list_frame.grid_columnconfigure(0, weight=1)
        list_frame.grid_rowconfigure(0, weight=1)
        
        # Scrollable frame
        self.scrollable = ctk.CTkScrollableFrame(list_frame)
        self.scrollable.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)
        self.scrollable.grid_columnconfigure(0, weight=1)
    
    def refresh(self):
        """Refresh account list"""
        
        # Clear current list
        for widget in self.scrollable.winfo_children():
            widget.destroy()
        
        # Load accounts
        self.account_manager.load_accounts()
        accounts = self.account_manager.get_all_accounts()
        
        if not accounts:
            no_account_label = ctk.CTkLabel(
                self.scrollable,
                text="ChÆ°a cÃ³ tÃ i khoáº£n nÃ o\nHÃ£y thÃªm tÃ i khoáº£n má»›i!",
                font=ctk.CTkFont(size=16),
                text_color="gray"
            )
            no_account_label.grid(row=0, column=0, pady=100)
            return
        
        # Display accounts
        for idx, account in enumerate(accounts):
            self.create_account_card(account, idx)
    
    def create_account_card(self, account, row):
        """Create account card"""
        
        card = ctk.CTkFrame(self.scrollable, corner_radius=10)
        card.grid(row=row, column=0, sticky="ew", pady=6, padx=10)
        card.grid_columnconfigure(1, weight=1)
        
        # Account info
        name_label = ctk.CTkLabel(
            card,
            text=f"ðŸ“§ {account.name}",
            font=ctk.CTkFont(size=16, weight="bold")
        )
        name_label.grid(row=0, column=0, sticky="w", padx=20, pady=(15, 5))
        
        email_label = ctk.CTkLabel(
            card,
            text=f"Email: {account.email}",
            text_color="gray"
        )
        email_label.grid(row=1, column=0, sticky="w", padx=20, pady=2)
        
        created_label = ctk.CTkLabel(
            card,
            text=f"Táº¡o: {format_datetime(account.created_at)}",
            text_color="gray"
        )
        created_label.grid(row=2, column=0, sticky="w", padx=20, pady=2)
        
        if account.last_used:
            used_label = ctk.CTkLabel(
                card,
                text=f"DÃ¹ng: {format_datetime(account.last_used)}",
                text_color="gray"
            )
            used_label.grid(row=3, column=0, sticky="w", padx=20, pady=(2, 15))
        else:
            ctk.CTkLabel(card, text="").grid(row=3, column=0, pady=(2, 15))
        
        # Action buttons
        btn_frame = ctk.CTkFrame(card, fg_color="transparent")
        btn_frame.grid(row=0, column=1, rowspan=4, padx=20, pady=10)
        
        use_btn = ctk.CTkButton(
            btn_frame,
            text="ðŸŒ ÄÄƒng nháº­p",
            command=lambda: self.use_account(account.name),
            width=100
        )
        use_btn.grid(row=0, column=0, padx=5, pady=5)
        
        rename_btn = ctk.CTkButton(
            btn_frame,
            text="Äá»•i tÃªn",
            command=lambda: self.rename_account(account.name),
            width=100
        )
        rename_btn.grid(row=0, column=1, padx=5, pady=5)
        
        delete_btn = ctk.CTkButton(
            btn_frame,
            text="XÃ³a",
            command=lambda: self.delete_account(account.name),
            width=100,
            fg_color="red",
            hover_color="darkred"
        )
        delete_btn.grid(row=0, column=2, padx=5, pady=5)
    
    def add_account(self):
        """Add new account"""
        
        dialog = ctk.CTkInputDialog(
            text="Nháº­p tÃªn tÃ i khoáº£n:",
            title="ThÃªm tÃ i khoáº£n má»›i"
        )
        account_name = dialog.get_input()
        
        if not account_name:
            return
        
        dialog = ctk.CTkInputDialog(
            text="Nháº­p email:",
            title="ThÃªm tÃ i khoáº£n má»›i"
        )
        email = dialog.get_input()
        
        if not email:
            return
        
        # Add account
        if self.account_manager.add_account(account_name, email):
            messagebox.showinfo("ThÃ nh cÃ´ng", f"ÄÃ£ thÃªm tÃ i khoáº£n: {account_name}")
            
            # Launch browser for login
            if messagebox.askyesno("ÄÄƒng nháº­p", "Má»Ÿ trÃ¬nh duyá»‡t Ä‘á»ƒ Ä‘Äƒng nháº­p ngay?"):
                self.use_account(account_name)
            
            self.refresh()
        else:
            messagebox.showerror("Lá»—i", "KhÃ´ng thá»ƒ thÃªm tÃ i khoáº£n. TÃªn Ä‘Ã£ tá»“n táº¡i!")
    
    def use_account(self, account_name: str):
        """Use account - launch browser"""
        
        def launch():
            driver = self.session_manager.launch_browser(account_name)
            if driver:
                self.account_manager.update_last_used(account_name)
                self.after(0, self.refresh)
                self.after(0, lambda: self._monitor_browser_session(driver, account_name))
            else:
                self.after(0, lambda: messagebox.showerror("Lá»—i", "KhÃ´ng thá»ƒ má»Ÿ trÃ¬nh duyá»‡t!"))
        
        # Launch in thread to avoid blocking UI
        thread = threading.Thread(target=launch, daemon=True)
        thread.start()

    def _monitor_browser_session(self, driver, account_name: str):
        """Show success toast once the browser closes."""
        def wait_for_exit():
            while True:
                try:
                    _ = driver.title
                except WebDriverException:
                    break
                except Exception:
                    break
                time.sleep(1)

            try:
                driver.quit()
            except Exception:
                pass

            self.after(0, lambda: messagebox.showinfo(
                "ThÃ nh cÃ´ng",
                "ÄÃ£ lÆ°u thÃ´ng tin tÃ i khoáº£n thÃ nh cÃ´ng."
            ))

        monitor = threading.Thread(target=wait_for_exit, daemon=True)
        monitor.start()
    
    def rename_account(self, old_name: str):
        """Rename account"""
        
        dialog = ctk.CTkInputDialog(
            text=f"Nháº­p tÃªn má»›i cho '{old_name}':",
            title="Äá»•i tÃªn tÃ i khoáº£n"
        )
        new_name = dialog.get_input()
        
        if not new_name or new_name == old_name:
            return
        
        if self.account_manager.rename_account(old_name, new_name):
            messagebox.showinfo("ThÃ nh cÃ´ng", f"ÄÃ£ Ä‘á»•i tÃªn: {old_name} â†’ {new_name}")
            self.refresh()
        else:
            messagebox.showerror("Lá»—i", "KhÃ´ng thá»ƒ Ä‘á»•i tÃªn tÃ i khoáº£n!")
    
    def delete_account(self, account_name: str):
        """Delete account"""
        
        if not messagebox.askyesno(
            "XÃ¡c nháº­n xÃ³a",
            f"Báº¡n cÃ³ cháº¯c muá»‘n xÃ³a tÃ i khoáº£n '{account_name}'?"
        ):
            return
        
        delete_profile = messagebox.askyesno(
            "XÃ³a dá»¯ liá»‡u",
            "XÃ³a cáº£ dá»¯ liá»‡u profile (session, cookies)?"
        )
        
        if self.account_manager.delete_account(account_name, delete_profile):
            messagebox.showinfo("ThÃ nh cÃ´ng", f"ÄÃ£ xÃ³a tÃ i khoáº£n: {account_name}")
            self.refresh()
        else:
            messagebox.showerror("Lá»—i", "KhÃ´ng thá»ƒ xÃ³a tÃ i khoáº£n!")
</file>

<file path="src/ui/AGENTS.md">
# AGENTS.md

**Audience:** AI coding agents, frontend developers  
**Applies to:** `src/ui/**/*.py`  
**Scope:** Panel patterns, component structure, threading model, CustomTkinter conventions  
**Last reviewed:** 2025-11-10  
**Owners:** UI team, frontend developers

---

## Component Structure

### Panel Hierarchy

```
MainWindow (CTk root)
â”œâ”€â”€ Title Bar
â”œâ”€â”€ Navigation (CTkSegmentedButton)
â””â”€â”€ Content Frame (switches panels)
    â”œâ”€â”€ AccountPanel
    â”œâ”€â”€ MultipleSongsPanel (Queue)
    â”œâ”€â”€ CreateMusicPanel (Simple)
    â”œâ”€â”€ DownloadPanel
    â”œâ”€â”€ HistoryPanel
    â””â”€â”€ SongCreationHistoryPanel
```

See `memory-bank/FLOW_DIAGRAMS.md#ui-component-hierarchy` for full diagram.

### Panel Pattern

All panels inherit from `ctk.CTkFrame`:

```python
class YourPanel(ctk.CTkFrame):
    def __init__(
        self,
        parent: ctk.CTkFrame,
        # Inject managers (never create inside panel!)
        account_manager: AccountManager,
        session_manager: SessionManager,
        **kwargs
    ):
        super().__init__(parent, **kwargs)
        
        # Store manager references
        self.account_manager = account_manager
        self.session_manager = session_manager
        
        # Build UI
        self._create_widgets()
        self._layout_widgets()
        
        # Load initial state
        self._refresh_data()
    
    def _create_widgets(self):
        """Create all widgets (buttons, labels, etc)"""
        self.button = ctk.CTkButton(self, text="Click", command=self.on_click)
    
    def _layout_widgets(self):
        """Arrange widgets with grid/pack"""
        self.button.pack(pady=10)
    
    def _refresh_data(self):
        """Load data from managers and update UI"""
        accounts = self.account_manager.get_all_accounts()
        # Update dropdown, labels, etc.
```

**Why this pattern?**
- Clear separation: creation â†’ layout â†’ data
- Testable: mock managers in constructor
- Maintainable: easy to find where widgets are created/placed

---

## Panel Patterns

### Dependency Injection

**âœ… CORRECT:**
```python
# main_window.py
class MainWindow(ctk.CTk):
    def __init__(self):
        # Create managers ONCE
        self.account_manager = AccountManager()
        self.session_manager = SessionManager()
        self.queue_manager = QueueManager()
        
        # Inject into panels
        self.account_panel = AccountPanel(
            parent=self.content_frame,
            account_manager=self.account_manager,
            session_manager=self.session_manager
        )
```

**âŒ WRONG:**
```python
class AccountPanel(ctk.CTkFrame):
    def __init__(self, parent):
        # Creates duplicate manager instance!
        self.account_manager = AccountManager()
```

### Progress Callbacks

Long operations (download, batch create) run in background threads and update UI via callbacks:

```python
class DownloadPanel(ctk.CTkFrame):
    def start_download(self):
        """Spawn background thread for download"""
        thread = threading.Thread(
            target=self.download_thread,
            args=(account, limit, output_path),
            daemon=True  # CRITICAL: Dies with main thread
        )
        thread.start()
    
    def download_thread(self, account: str, limit: int, output_path: Path):
        """Worker thread - does NOT touch UI directly"""
        try:
            # Do work...
            self.download_manager.batch_download(
                clips=clips,
                progress_callback=self.update_progress  # Pass callback
            )
        except Exception as e:
            # Update UI from thread (CustomTkinter allows this)
            self.show_error(str(e))
    
    def update_progress(self, message: str, percentage: int):
        """
        Called from worker thread.
        CustomTkinter widgets are thread-safe for configure().
        """
        self.progress_label.configure(text=message)
        self.progress_bar.set(percentage / 100)
```

**Why daemon=True?**
- Background threads die when main thread exits
- Prevents app hanging on close
- No zombie processes

---

## Threading Model

### Main Thread vs Background Threads

```
Main Thread (UI Event Loop)
â”œâ”€â”€ Render UI
â”œâ”€â”€ Handle clicks
â”œâ”€â”€ Spawn background threads
â””â”€â”€ Receive callbacks from workers

Background Thread 1 (Download)
â”œâ”€â”€ Open Chrome
â”œâ”€â”€ Extract token
â”œâ”€â”€ Call API
â”œâ”€â”€ Download files
â””â”€â”€ Call UI callback â”€â”€â”
                       â”‚
Background Thread 2    â”‚
(Batch Create)         â”‚
â”œâ”€â”€ Open Chrome        â”‚
â”œâ”€â”€ Fill forms         â”‚
â”œâ”€â”€ Wait for creation  â”‚
â””â”€â”€ Call UI callback â”€â”€â”´â”€â†’ Main Thread updates UI
```

**Rules:**
1. **Never block main thread** with long operations (I/O, browser launch)
2. **Always use `daemon=True`** for background threads
3. **CustomTkinter is thread-safe** for `configure()` calls
4. **Never create widgets** from background threads (only update existing ones)

### Example: Download Panel Threading

```python
def start_download(self):
    # Validate on main thread
    if not self.account_var.get():
        messagebox.showerror("Lá»—i", "Vui lÃ²ng chá»n tÃ i khoáº£n")
        return
    
    # Disable button (prevent double-click)
    self.download_button.configure(state="disabled")
    
    # Spawn worker
    thread = threading.Thread(
        target=self.download_thread,
        args=(self.account_var.get(), int(self.limit_var.get())),
        daemon=True
    )
    thread.start()

def download_thread(self, account: str, limit: int):
    try:
        # Long operation in background
        clips = self.download_manager.fetch_clips(account, limit)
        
        for i, clip in enumerate(clips):
            # Download work...
            
            # Update UI from worker (thread-safe)
            self.update_progress(f"Downloading {i+1}/{len(clips)}", (i+1)/len(clips)*100)
    
    except Exception as e:
        logger.error(f"Download failed: {e}", exc_info=True)
        self.show_error(str(e))
    
    finally:
        # Re-enable button
        self.download_button.configure(state="normal")
```

---

## CustomTkinter Conventions

### Widget Naming

```python
# Suffix by widget type
self.account_dropdown = ctk.CTkOptionMenu(...)
self.limit_entry = ctk.CTkEntry(...)
self.download_button = ctk.CTkButton(...)
self.progress_label = ctk.CTkLabel(...)
self.progress_bar = ctk.CTkProgressBar(...)

# StringVar/IntVar for input binding
self.account_var = ctk.StringVar()
self.limit_var = ctk.StringVar(value="10")
```

### Layout Patterns

**Grid Layout** (structured forms):
```python
def _layout_widgets(self):
    # Label-input pairs in 2 columns
    self.account_label.grid(row=0, column=0, sticky="w", padx=10, pady=5)
    self.account_dropdown.grid(row=0, column=1, sticky="ew", padx=10, pady=5)
    
    self.limit_label.grid(row=1, column=0, sticky="w", padx=10, pady=5)
    self.limit_entry.grid(row=1, column=1, sticky="ew", padx=10, pady=5)
    
    # Configure column weights for resize
    self.columnconfigure(1, weight=1)
```

**Pack Layout** (vertical stacks):
```python
def _layout_widgets(self):
    # Stack vertically with padding
    self.title_label.pack(pady=10, padx=20, anchor="w")
    self.description_label.pack(pady=5, padx=20, anchor="w")
    self.button_frame.pack(pady=10, padx=20, fill="x")
```

**Frames for Grouping**:
```python
# Create logical sections
self.config_frame = ctk.CTkFrame(self)
self.config_frame.pack(pady=10, padx=20, fill="x")

# Widgets inside frame
self.option1_checkbox = ctk.CTkCheckBox(self.config_frame, text="Option 1")
self.option1_checkbox.pack(pady=5, anchor="w")
```

### Colors & Styling

Use centralized style config:

```python
from config.style_config import COLORS, FONTS

# Buttons
self.primary_button = ctk.CTkButton(
    self,
    text="Báº¯t Ä‘áº§u",
    fg_color=COLORS["primary"],
    hover_color=COLORS["primary_hover"],
    font=FONTS["button"]
)

# Success/Warning/Danger states
self.status_label.configure(
    text="âœ… ThÃ nh cÃ´ng",
    text_color=COLORS["success"]
)
```

### ScrollableFrame Pattern

For long content (lists, logs):

```python
class HistoryPanel(ctk.CTkFrame):
    def _create_widgets(self):
        # Scrollable area
        self.scrollable_frame = ctk.CTkScrollableFrame(
            self,
            width=600,
            height=400
        )
        self.scrollable_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        # Add items dynamically
        for item in self.history:
            item_frame = self._create_history_item(item)
            item_frame.pack(fill="x", pady=5)
    
    def _create_history_item(self, item: dict) -> ctk.CTkFrame:
        frame = ctk.CTkFrame(self.scrollable_frame)
        
        title_label = ctk.CTkLabel(frame, text=item["title"], font=("Arial", 14, "bold"))
        title_label.pack(anchor="w", padx=10, pady=5)
        
        date_label = ctk.CTkLabel(frame, text=item["date"], font=("Arial", 10))
        date_label.pack(anchor="w", padx=10, pady=2)
        
        return frame
```

---

## Reusable Components

Components in `src/ui/components/`:

### AdvancedOptionsWidget

Collapsible advanced options for song creation:

```python
from src.ui.components.advanced_options_widget import AdvancedOptionsWidget

class CreateMusicPanel(ctk.CTkFrame):
    def _create_widgets(self):
        self.advanced_options = AdvancedOptionsWidget(
            parent=self,
            on_change_callback=self.on_options_changed
        )
        self.advanced_options.pack(fill="x", pady=10)
    
    def on_options_changed(self, options: dict):
        """Called when any option changes"""
        self.current_options = options
        print(f"Options updated: {options}")
```

### PreviewWidget

Display generated XML prompts:

```python
from src.ui.components.preview_widget import PreviewWidget

class CreateMusicPanel(ctk.CTkFrame):
    def _create_widgets(self):
        self.preview = PreviewWidget(parent=self)
        self.preview.pack(fill="both", expand=True, pady=10)
    
    def show_preview(self, xml_content: str):
        self.preview.set_content(xml_content)
```

### SunoSelectors

CSS selectors for Suno.com automation:

```python
from src.ui.components.suno_selectors import SunoSelectors

# Use in form automation
lyrics_input = driver.find_element(By.CSS_SELECTOR, SunoSelectors.LYRICS_TEXTAREA)
```

---

## Panel-Specific Patterns

### AccountPanel

**Responsibility**: Account CRUD, profile management

```python
class AccountPanel(ctk.CTkFrame):
    def add_account(self):
        """
        Flow:
        1. Show dialog for name input
        2. Validate (no duplicates)
        3. Spawn background thread
        4. Launch Chrome for manual login
        5. Wait for user to close browser
        6. Save account to JSON
        7. Refresh dropdown
        """
        name = simpledialog.askstring("ThÃªm tÃ i khoáº£n", "Nháº­p tÃªn:")
        if not name:
            return
        
        if self.account_manager.account_exists(name):
            messagebox.showerror("Lá»—i", "TÃªn tÃ i khoáº£n Ä‘Ã£ tá»“n táº¡i")
            return
        
        thread = threading.Thread(
            target=self.add_account_thread,
            args=(name,),
            daemon=True
        )
        thread.start()
```

### MultipleSongsPanel (Queue)

**Responsibility**: Queue management, batch creation

```python
class MultipleSongsPanel(ctk.CTkFrame):
    def upload_prompts(self):
        """
        1. Open file dialog (.xml)
        2. Parse with SunoPromptParser
        3. Display count in UI
        4. Enable "Add Queue" button
        """
        filepath = filedialog.askopenfilename(filetypes=[("XML files", "*.xml")])
        if not filepath:
            return
        
        parser = SunoPromptParser()
        self.prompts = parser.parse_file(filepath)
        self.prompts_label.configure(text=f"ÄÃ£ load {len(self.prompts)} prompts")
        self.add_queue_button.configure(state="normal")
    
    def add_queue(self):
        """
        1. Validate inputs
        2. Call queue_manager.add_queue_entry()
        3. Refresh queue list
        4. Show success message
        """
        try:
            queue_id = self.queue_manager.add_queue_entry(
                account_name=self.account_var.get(),
                song_count=int(self.song_count_var.get()),
                batch_size=int(self.batch_size_var.get()),
                prompts=self.prompts
            )
            self.refresh_queue_list()
            messagebox.showinfo("ThÃ nh cÃ´ng", f"ÄÃ£ thÃªm queue: {queue_id[:8]}")
        except QueueValidationError as e:
            messagebox.showerror("Lá»—i", str(e))
```

### CreateMusicPanel (Simple)

**Responsibility**: Single song creation with preview

```python
class CreateMusicPanel(ctk.CTkFrame):
    def __init__(self, parent, **managers):
        super().__init__(parent)
        # 2-column layout
        self.left_column = ctk.CTkScrollableFrame(self, width=500)
        self.left_column.pack(side="left", fill="both", expand=True, padx=10, pady=10)
        
        self.right_column = ctk.CTkFrame(self, width=400)
        self.right_column.pack(side="right", fill="both", expand=True, padx=10, pady=10)
        
        # Left: Input form
        # Right: Preview + actions
```

### DownloadPanel

**Responsibility**: Download orchestration with progress

```python
class DownloadPanel(ctk.CTkFrame):
    def start_download(self):
        """
        Threading pattern:
        1. Validate inputs on main thread
        2. Disable button
        3. Spawn download_thread
        4. Thread calls progress_callback
        5. Finally: re-enable button
        """
        # See Threading Model section above
```

---

## Error Handling

### User-Facing Errors

Use `messagebox` for errors:

```python
from tkinter import messagebox

# Error
messagebox.showerror("Lá»—i", "Vui lÃ²ng chá»n tÃ i khoáº£n")

# Warning
messagebox.showwarning("Cáº£nh bÃ¡o", "Profile Ä‘ang Ä‘Æ°á»£c sá»­ dá»¥ng")

# Info
messagebox.showinfo("ThÃ nh cÃ´ng", "Táº£i xuá»‘ng hoÃ n táº¥t")

# Question
result = messagebox.askyesno("XÃ¡c nháº­n", "Báº¡n cÃ³ cháº¯c muá»‘n xÃ³a?")
if result:
    # User clicked Yes
```

### Status Messages

Use labels with color coding:

```python
def show_status(self, message: str, status_type: str = "info"):
    """
    status_type: "info" | "success" | "warning" | "error"
    """
    colors = {
        "info": COLORS["info"],
        "success": COLORS["success"],
        "warning": COLORS["warning"],
        "error": COLORS["danger"]
    }
    
    self.status_label.configure(
        text=message,
        text_color=colors.get(status_type, COLORS["info"])
    )
```

---

## Tab Navigation

Implemented in `MainWindow`:

```python
class MainWindow(ctk.CTk):
    def __init__(self):
        # Segmented button for tab switching
        self.nav_bar = ctk.CTkSegmentedButton(
            self,
            values=["ðŸŽµ TÃ i khoáº£n", "ðŸŽ¼ Táº¡o Nhiá»u", "ðŸŽµ Táº¡o Nháº¡c", "ðŸ“¥ Download", "ðŸ“œ Lá»‹ch sá»­"],
            command=self.on_tab_change
        )
        self.nav_bar.set("ðŸŽµ TÃ i khoáº£n")  # Default tab
    
    def on_tab_change(self, value: str):
        """Hide all panels, show selected one"""
        panels = {
            "ðŸŽµ TÃ i khoáº£n": self.account_panel,
            "ðŸŽ¼ Táº¡o Nhiá»u": self.multiple_songs_panel,
            "ðŸŽµ Táº¡o Nháº¡c": self.create_music_panel,
            "ðŸ“¥ Download": self.download_panel,
            "ðŸ“œ Lá»‹ch sá»­": self.history_panel
        }
        
        # Hide all
        for panel in panels.values():
            panel.pack_forget()
        
        # Show selected
        panels[value].pack(fill="both", expand=True)
```

---

## Testing UI Components

Mock managers and test logic without launching GUI:

```python
from unittest.mock import MagicMock
import pytest

def test_account_panel_add_validation():
    # Mock managers
    mock_account_manager = MagicMock()
    mock_account_manager.account_exists.return_value = True
    
    # Create panel (won't render in test)
    panel = AccountPanel(
        parent=MagicMock(),  # Mock parent
        account_manager=mock_account_manager,
        session_manager=MagicMock()
    )
    
    # Test validation logic
    # (avoid testing actual GUI rendering)
    assert panel.account_manager.account_exists("test")
```

For full UI testing, see `tests/AGENTS.md#ui-testing`.

---

## Entry Points

| File | Panel Class | Responsibility |
|------|------------|----------------|
| `main_window.py` | `MainWindow` | Root window, manager init, tab navigation |
| `account_panel.py` | `AccountPanel` | Account CRUD, profile management |
| `multiple_songs_panel.py` | `MultipleSongsPanel` | Queue management, batch creation |
| `create_music_panel.py` | `CreateMusicPanel` | Single song creation with preview |
| `download_panel.py` | `DownloadPanel` | Download orchestration |
| `history_panel.py` | `HistoryPanel` | Download history display |
| `song_creation_history_panel.py` | `SongCreationHistoryPanel` | Creation history, CSV export |

---

## Cross-References

- **Manager patterns**: See `src/core/AGENTS.md#manager-lifecycle`
- **Configuration**: See `config/AGENTS.md#path-constants`
- **Architecture**: See `memory-bank/FLOW_DIAGRAMS.md#ui-component-hierarchy`
- **Threading**: See this file's [Threading Model](#threading-model) section

---

**Questions?** Check root `AGENTS.md` for general guidelines.
</file>

<file path="src/ui/components/__init__.py">
"""
UI Components Package
"""
from .suno_selectors import SunoSelectors
from .advanced_options_widget import AdvancedOptionsWidget
from .preview_widget import PreviewWidget

__all__ = [
    'SunoSelectors',
    'AdvancedOptionsWidget',
    'PreviewWidget'
]
</file>

<file path="src/ui/components/advanced_options_widget.py">
"""
Advanced Options Widget - Reusable component cho Suno Advanced Settings
"""
import customtkinter as ctk
from typing import Dict, Any


class AdvancedOptionsWidget(ctk.CTkFrame):
    """
    Reusable widget cho Advanced Options
    
    Features:
    - Exclude Styles
    - Vocal Gender (Male/Female)
    - Lyrics Mode (Manual/Auto)
    - Weirdness Slider (0-100%)
    - Style Influence Slider (0-100%)
    - Persona Name
    """
    
    def __init__(self, parent, **kwargs):
        super().__init__(parent, **kwargs)
        
        # Variables
        self.use_advanced_var = ctk.BooleanVar(value=False)
        self.exclude_styles_var = ctk.StringVar(value="")
        self.vocal_gender_var = ctk.StringVar(value="")
        self.lyrics_mode_var = ctk.StringVar(value="")
        self.weirdness_var = ctk.IntVar(value=50)
        self.style_influence_var = ctk.IntVar(value=50)
        self.persona_name_var = ctk.StringVar(value="")
        
        self.setup_ui()
    
    def setup_ui(self):
        """Thiáº¿t láº­p giao diá»‡n"""
        # Header with checkbox
        header_frame = ctk.CTkFrame(self)
        header_frame.pack(fill="x", padx=10, pady=5)
        
        use_advanced_check = ctk.CTkCheckBox(
            header_frame,
            text="Sá»­ dá»¥ng Advanced Options",
            variable=self.use_advanced_var,
            font=("Arial", 13, "bold"),
            command=self._toggle_advanced_options
        )
        use_advanced_check.pack(side="left", padx=10)
        
        # Options container
        self.options_container = ctk.CTkFrame(self)
        self.options_container.pack(fill="x", padx=10, pady=5)
        
        # Row 1: Exclude Styles
        ctk.CTkLabel(
            self.options_container,
            text="Exclude Styles:",
            font=("Arial", 11)
        ).grid(row=0, column=0, padx=10, pady=5, sticky="w")
        
        self.exclude_styles_entry = ctk.CTkEntry(
            self.options_container,
            textvariable=self.exclude_styles_var,
            width=300,
            placeholder_text="rock, metal, edm..."
        )
        self.exclude_styles_entry.grid(row=0, column=1, padx=10, pady=5, sticky="w")
        
        # Row 2: Vocal Gender
        ctk.CTkLabel(
            self.options_container,
            text="Vocal Gender:",
            font=("Arial", 11)
        ).grid(row=1, column=0, padx=10, pady=5, sticky="w")
        
        gender_frame = ctk.CTkFrame(self.options_container)
        gender_frame.grid(row=1, column=1, padx=10, pady=5, sticky="w")
        
        ctk.CTkRadioButton(
            gender_frame,
            text="Male",
            variable=self.vocal_gender_var,
            value="Male"
        ).pack(side="left", padx=5)
        
        ctk.CTkRadioButton(
            gender_frame,
            text="Female",
            variable=self.vocal_gender_var,
            value="Female"
        ).pack(side="left", padx=5)
        
        ctk.CTkRadioButton(
            gender_frame,
            text="None",
            variable=self.vocal_gender_var,
            value=""
        ).pack(side="left", padx=5)
        
        # Row 3: Lyrics Mode
        ctk.CTkLabel(
            self.options_container,
            text="Lyrics Mode:",
            font=("Arial", 11)
        ).grid(row=2, column=0, padx=10, pady=5, sticky="w")
        
        lyrics_mode_frame = ctk.CTkFrame(self.options_container)
        lyrics_mode_frame.grid(row=2, column=1, padx=10, pady=5, sticky="w")
        
        ctk.CTkRadioButton(
            lyrics_mode_frame,
            text="Manual",
            variable=self.lyrics_mode_var,
            value="Manual"
        ).pack(side="left", padx=5)
        
        ctk.CTkRadioButton(
            lyrics_mode_frame,
            text="Auto",
            variable=self.lyrics_mode_var,
            value="Auto"
        ).pack(side="left", padx=5)
        
        ctk.CTkRadioButton(
            lyrics_mode_frame,
            text="None",
            variable=self.lyrics_mode_var,
            value=""
        ).pack(side="left", padx=5)
        
        # Row 4: Weirdness Slider
        ctk.CTkLabel(
            self.options_container,
            text="Weirdness:",
            font=("Arial", 11)
        ).grid(row=3, column=0, padx=10, pady=5, sticky="w")
        
        weirdness_frame = ctk.CTkFrame(self.options_container)
        weirdness_frame.grid(row=3, column=1, padx=10, pady=5, sticky="w")
        
        self.weirdness_slider = ctk.CTkSlider(
            weirdness_frame,
            from_=0,
            to=100,
            variable=self.weirdness_var,
            width=250
        )
        self.weirdness_slider.pack(side="left", padx=5)
        
        self.weirdness_label = ctk.CTkLabel(
            weirdness_frame,
            text="50%",
            font=("Arial", 11, "bold"),
            width=50
        )
        self.weirdness_label.pack(side="left", padx=5)
        
        self.weirdness_slider.configure(
            command=lambda v: self.weirdness_label.configure(text=f"{int(v)}%")
        )
        
        # Row 5: Style Influence Slider
        ctk.CTkLabel(
            self.options_container,
            text="Style Influence:",
            font=("Arial", 11)
        ).grid(row=4, column=0, padx=10, pady=5, sticky="w")
        
        style_influence_frame = ctk.CTkFrame(self.options_container)
        style_influence_frame.grid(row=4, column=1, padx=10, pady=5, sticky="w")
        
        self.style_influence_slider = ctk.CTkSlider(
            style_influence_frame,
            from_=0,
            to=100,
            variable=self.style_influence_var,
            width=250
        )
        self.style_influence_slider.pack(side="left", padx=5)
        
        self.style_influence_label = ctk.CTkLabel(
            style_influence_frame,
            text="50%",
            font=("Arial", 11, "bold"),
            width=50
        )
        self.style_influence_label.pack(side="left", padx=5)
        
        self.style_influence_slider.configure(
            command=lambda v: self.style_influence_label.configure(text=f"{int(v)}%")
        )
        
        # Row 6: Persona Name
        ctk.CTkLabel(
            self.options_container,
            text="Persona:",
            font=("Arial", 11)
        ).grid(row=5, column=0, padx=10, pady=5, sticky="w")
        
        persona_frame = ctk.CTkFrame(self.options_container)
        persona_frame.grid(row=5, column=1, padx=10, pady=5, sticky="w")
        
        self.persona_entry = ctk.CTkEntry(
            persona_frame,
            textvariable=self.persona_name_var,
            width=250,
            placeholder_text="Minh Chien, John Doe..."
        )
        self.persona_entry.pack(side="left", padx=5)
        
        ctk.CTkLabel(
            persona_frame,
            text="TÃ¬m vÃ  chá»n persona theo tÃªn",
            font=("Arial", 9),
            text_color="gray"
        ).pack(side="left", padx=5)
        
        # Disable by default
        self._toggle_advanced_options()
    
    def _toggle_advanced_options(self):
        """Enable/disable advanced options controls"""
        state = "normal" if self.use_advanced_var.get() else "disabled"
        
        # Disable/enable all widgets
        for widget in self.options_container.winfo_children():
            if isinstance(widget, (ctk.CTkEntry, ctk.CTkSlider)):
                widget.configure(state=state)
            elif isinstance(widget, ctk.CTkFrame):
                for child in widget.winfo_children():
                    if isinstance(child, (ctk.CTkRadioButton, ctk.CTkSlider)):
                        child.configure(state=state)
    
    def get_settings(self) -> Dict[str, Any]:
        """
        Láº¥y táº¥t cáº£ settings
        
        Returns:
            Dict chá»©a táº¥t cáº£ settings
        """
        return {
            'enabled': self.use_advanced_var.get(),
            'exclude_styles': self.exclude_styles_var.get().strip(),
            'vocal_gender': self.vocal_gender_var.get(),
            'lyrics_mode': self.lyrics_mode_var.get(),
            'weirdness': self.weirdness_var.get(),
            'style_influence': self.style_influence_var.get(),
            'persona_name': self.persona_name_var.get().strip()
        }
    
    def reset(self):
        """Reset vá» giÃ¡ trá»‹ máº·c Ä‘á»‹nh"""
        self.use_advanced_var.set(False)
        self.exclude_styles_var.set("")
        self.vocal_gender_var.set("")
        self.lyrics_mode_var.set("")
        self.weirdness_var.set(50)
        self.style_influence_var.set(50)
        self.persona_name_var.set("")
        self._toggle_advanced_options()
</file>

<file path="src/ui/components/preview_widget.py">
"""
Preview Widget - Hiá»ƒn thá»‹ danh sÃ¡ch bÃ i hÃ¡t tá»« XML
"""
import customtkinter as ctk
from typing import List
from src.utils.prompt_parser import SunoPrompt


class PreviewWidget(ctk.CTkFrame):
    """
    Widget hiá»ƒn thá»‹ preview danh sÃ¡ch bÃ i hÃ¡t
    
    Features:
    - Hiá»ƒn thá»‹ sá»‘ lÆ°á»£ng bÃ i
    - Preview title, style, lyrics cá»§a tá»«ng bÃ i
    - Tá»± Ä‘á»™ng scroll
    """
    
    def __init__(self, parent, **kwargs):
        super().__init__(parent, **kwargs)
        self.setup_ui()
    
    def setup_ui(self):
        """Thiáº¿t láº­p giao diá»‡n"""
        # Title
        ctk.CTkLabel(
            self,
            text="ðŸ“‹ Danh SÃ¡ch BÃ i HÃ¡t:",
            font=("Arial", 14, "bold")
        ).pack(padx=10, pady=5, anchor="w")
        
        # Textbox
        self.preview_text = ctk.CTkTextbox(self, width=650, height=200)
        self.preview_text.pack(padx=10, pady=5)
        self.preview_text.insert("1.0", "ChÆ°a parse file nÃ o. Click 'Parse' Ä‘á»ƒ báº¯t Ä‘áº§u.")
    
    def display_prompts(self, prompts: List[SunoPrompt]):
        """
        Hiá»ƒn thá»‹ danh sÃ¡ch prompts
        
        Args:
            prompts: List of SunoPrompt objects
        """
        self.preview_text.delete("1.0", "end")
        
        if not prompts:
            self.preview_text.insert("1.0", "âŒ KhÃ´ng parse Ä‘Æ°á»£c prompt nÃ o tá»« file!")
            return
        
        output = f"âœ… TÃ¬m tháº¥y {len(prompts)} bÃ i hÃ¡t:\n\n"
        
        for i, prompt in enumerate(prompts, 1):
            output += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            output += f"BÃ i {i}: {prompt.title}\n"
            output += f"Style: {prompt.style[:60]}...\n"
            output += f"Lyrics: {len(prompt.lyrics)} kÃ½ tá»±\n"
            output += f"Preview: {prompt.lyrics[:80].replace(chr(10), ' ')}...\n\n"
        
        self.preview_text.insert("1.0", output)
    
    def show_error(self, message: str):
        """Hiá»ƒn thá»‹ lá»—i"""
        self.preview_text.delete("1.0", "end")
        self.preview_text.insert("1.0", f"âŒ {message}")
    
    def clear(self):
        """XÃ³a ná»™i dung"""
        self.preview_text.delete("1.0", "end")
        self.preview_text.insert("1.0", "ChÆ°a parse file nÃ o. Click 'Parse' Ä‘á»ƒ báº¯t Ä‘áº§u.")
</file>

<file path="src/ui/components/suno_selectors.py">
"""
Suno Selectors - XPath selectors cho táº¥t cáº£ cÃ¡c thÃ nh pháº§n Suno.com
"""


class SunoSelectors:
    """XPath selectors cho Suno.com interface"""
    
    # Form Mode
    CUSTOM_BUTTON = "//button[normalize-space(.)='Custom']"
    
    # Basic Input Fields
    LYRICS_TEXTAREA = "//textarea[contains(@placeholder, 'Write some lyrics')]"
    STYLES_TEXTAREA = "//textarea[contains(@placeholder, 'indie, electronic')]"
    CREATE_BUTTON = "//button[@aria-label='Create song']"
    # Title input - chÃ­nh xÃ¡c vá»›i placeholder "Song Title (Optional)"
    TITLE_INPUT = "//input[@placeholder='Song Title (Optional)']"
    # Fallback náº¿u placeholder thay Ä‘á»•i
    TITLE_INPUT_ALT = "//input[contains(@placeholder, 'Song Title') and contains(@placeholder, 'Optional')]"
    
    # Advanced Options
    ADVANCED_OPTIONS_BUTTON = "//div[@role='button']//div[contains(text(), 'Advanced Options')]"
    EXCLUDE_STYLES_INPUT = "//input[contains(@placeholder, 'Exclude styles')]"
    
    # Gender Selection
    MALE_BUTTON = "//button[normalize-space(.)='Male']"
    FEMALE_BUTTON = "//button[normalize-space(.)='Female']"
    
    # Lyrics Mode
    MANUAL_LYRICS_BUTTON = "//button[normalize-space(.)='Manual']"
    AUTO_LYRICS_BUTTON = "//button[normalize-space(.)='Auto']"
    
    # Sliders
    WEIRDNESS_SLIDER = "//div[@role='slider' and @aria-label='Weirdness']"
    STYLE_INFLUENCE_SLIDER = "//div[@role='slider' and @aria-label='Style Influence']"
    
    # Persona
    PERSONA_BUTTON = "//button[contains(., 'Persona') or contains(., 'Add Persona')]"
    PERSONA_MODAL_SEARCH = "//div[contains(@class, 'chakra-modal__content')]//input[@placeholder='Search']"
    PERSONA_CONTAINER = "//div[contains(@class, 'group flex w-full cursor-pointer items-center gap-4')]"
</file>

<file path="src/ui/create_music_panel.py">
"""
Create Music Panel - UI Ä‘á»ƒ táº¡o nháº¡c tá»± Ä‘á»™ng trÃªn Suno
"""
import customtkinter as ctk
import threading
from typing import Optional
from pathlib import Path

# Import tá»« core
from src.core.account_manager import AccountManager
from src.core.session_manager import SessionManager
from legacy_modules import SunoMusicCreator, SunoCreateConfig
from config.style_config import FONT_LABEL, FONT_TITLE, FONT_SUBTITLE


class CreateMusicPanel(ctk.CTkFrame):
    """
    Panel táº¡o nháº¡c tá»± Ä‘á»™ng vá»›i Suno Custom Mode
    
    Features:
    - Chá»n account Ä‘Ã£ lÆ°u
    - Nháº­p Persona, Lyrics, Styles, Title
    - Cáº¥u hÃ¬nh Advanced Options
    - Progress bar hiá»ƒn thá»‹ tiáº¿n trÃ¬nh
    - Hiá»ƒn thá»‹ káº¿t quáº£ (URLs bÃ i hÃ¡t)
    """
    
    def __init__(self, parent, account_manager: AccountManager, session_manager: SessionManager):
        super().__init__(parent)
        
        self.account_manager = account_manager
        self.session_manager = session_manager
        self.music_creator = SunoMusicCreator(
            session_manager=session_manager,
            progress_callback=self._update_progress
        )
        
        # Storage cho created songs
        self.created_songs = []  # List of {title, prompt_xml, urls}
        
        self.setup_ui()
        
    def setup_ui(self):
        """Thiáº¿t láº­p giao diá»‡n 2 cá»™t: Form (trÃ¡i) vÃ  Káº¿t quáº£ (pháº£i)"""
        
        # Configure grid weights Ä‘á»ƒ 2 cá»™t co giÃ£n
        self.grid_columnconfigure(0, weight=1)  # Cá»™t trÃ¡i
        self.grid_columnconfigure(1, weight=1)  # Cá»™t pháº£i
        self.grid_rowconfigure(1, weight=1)     # Cho phÃ©p row 1 expand
        
        # Title (full width)
        title_label = ctk.CTkLabel(
            self, 
            text="Táº¡o Nháº¡c Tá»± Äá»™ng",
            font=FONT_TITLE
        )
        title_label.grid(row=0, column=0, columnspan=2, pady=20)
        
        # ============================================
        # Cá»˜T TRÃI: FORM INPUT
        # ============================================
        left_container = ctk.CTkScrollableFrame(self, width=700, height=650)
        left_container.grid(row=1, column=0, padx=10, pady=10, sticky="nsew")
        left_container.grid_columnconfigure(0, weight=1)
        
        # 1ï¸âƒ£ PHáº¦N 1: CHá»ŒN ACCOUNT
        account_frame = ctk.CTkFrame(left_container)
        account_frame.grid(row=0, column=0, sticky="ew", padx=10, pady=5)
        account_frame.grid_columnconfigure(1, weight=1)
        
        ctk.CTkLabel(account_frame, text="Account:", font=FONT_LABEL).grid(
            row=0, column=0, padx=10, pady=10, sticky="w"
        )
        
        self.account_var = ctk.StringVar()
        self.account_dropdown = ctk.CTkComboBox(
            account_frame,
            variable=self.account_var,
            values=self._get_account_list(),
            width=250
        )
        self.account_dropdown.grid(row=0, column=1, padx=10, pady=10, sticky="w")
        
        # 2ï¸âƒ£ PHáº¦N 2: PERSONA (Optional)
        persona_frame = ctk.CTkFrame(left_container)
        persona_frame.grid(row=1, column=0, sticky="ew", padx=10, pady=5)
        persona_frame.grid_columnconfigure(1, weight=1)
        
        ctk.CTkLabel(persona_frame, text="Persona (optional):", font=FONT_LABEL).grid(
            row=0, column=0, padx=10, pady=10, sticky="w"
        )
        
        self.persona_var = ctk.StringVar()
        self.persona_entry = ctk.CTkEntry(
            persona_frame,
            textvariable=self.persona_var,
            placeholder_text="Nháº­p tÃªn Persona hoáº·c Ä‘á»ƒ trá»‘ng"
        )
        self.persona_entry.grid(row=0, column=1, padx=10, pady=10, sticky="ew")
        
        # 3ï¸âƒ£ PHáº¦N 3: Ná»˜I DUNG CHÃNH
        content_frame = ctk.CTkFrame(left_container)
        content_frame.grid(row=2, column=0, sticky="ew", padx=10, pady=5)
        content_frame.grid_columnconfigure(1, weight=1)
        
        # Lyrics
        ctk.CTkLabel(content_frame, text="Lyrics:", font=FONT_LABEL).grid(
            row=0, column=0, padx=10, pady=5, sticky="nw"
        )
        
        self.lyrics_text = ctk.CTkTextbox(content_frame, height=150)
        self.lyrics_text.grid(row=0, column=1, padx=10, pady=5, sticky="ew")
        self.lyrics_text.insert("1.0", "[Verse 1]\nLá»i bÃ i hÃ¡t...\n\n[Chorus]\n...")
        
        # Styles
        ctk.CTkLabel(content_frame, text="Styles:", font=FONT_LABEL).grid(
            row=1, column=0, padx=10, pady=5, sticky="w"
        )
        
        self.styles_var = ctk.StringVar()
        self.styles_entry = ctk.CTkEntry(
            content_frame,
            textvariable=self.styles_var,
            placeholder_text="Pop, upbeat, 120bpm, piano, guitar..."
        )
        self.styles_entry.grid(row=1, column=1, padx=10, pady=5, sticky="ew")
        
        # Title
        ctk.CTkLabel(content_frame, text="Title (optional):", font=FONT_LABEL).grid(
            row=2, column=0, padx=10, pady=5, sticky="w"
        )
        
        self.title_var = ctk.StringVar()
        self.title_entry = ctk.CTkEntry(
            content_frame,
            textvariable=self.title_var,
            placeholder_text="TÃªn bÃ i hÃ¡t (Ä‘á»ƒ trá»‘ng Ä‘á»ƒ AI tá»± Ä‘áº·t)"
        )
        self.title_entry.grid(row=2, column=1, padx=10, pady=5, sticky="ew")
        
        # 4ï¸âƒ£ PHáº¦N 4: ADVANCED OPTIONS
        advanced_frame = ctk.CTkFrame(left_container)
        advanced_frame.grid(row=3, column=0, sticky="ew", padx=10, pady=5)
        advanced_frame.grid_columnconfigure(1, weight=1)
        
        ctk.CTkLabel(advanced_frame, text="Advanced Options", font=FONT_LABEL).grid(
            row=0, column=0, columnspan=3, padx=10, pady=10, sticky="w"
        )
        
        # Vocal Gender
        ctk.CTkLabel(advanced_frame, text="Vocal Gender:").grid(row=1, column=0, padx=10, pady=5, sticky="w")
        self.vocal_gender_var = ctk.StringVar(value="Auto")
        vocal_gender_dropdown = ctk.CTkComboBox(
            advanced_frame,
            variable=self.vocal_gender_var,
            values=["Auto", "Male", "Female"],
            width=200
        )
        vocal_gender_dropdown.grid(row=1, column=1, padx=10, pady=5, sticky="w")
        
        # Lyrics Mode
        ctk.CTkLabel(advanced_frame, text="Lyrics Mode:").grid(row=2, column=0, padx=10, pady=5, sticky="w")
        self.lyrics_mode_var = ctk.StringVar(value="Auto")
        lyrics_mode_dropdown = ctk.CTkComboBox(
            advanced_frame,
            variable=self.lyrics_mode_var,
            values=["Auto", "Manual"],
            width=200
        )
        lyrics_mode_dropdown.grid(row=2, column=1, padx=10, pady=5, sticky="w")
        
        # Weirdness
        ctk.CTkLabel(advanced_frame, text="Weirdness:").grid(row=3, column=0, padx=10, pady=5, sticky="w")
        self.weirdness_var = ctk.IntVar(value=50)
        self.weirdness_slider = ctk.CTkSlider(
            advanced_frame,
            from_=0,
            to=100,
            variable=self.weirdness_var,
            width=200
        )
        self.weirdness_slider.grid(row=3, column=1, padx=10, pady=5, sticky="w")
        self.weirdness_label = ctk.CTkLabel(advanced_frame, text="50%")
        self.weirdness_label.grid(row=3, column=2, padx=5, pady=5)
        self.weirdness_slider.configure(command=self._update_weirdness_label)
        
        # Style Influence
        ctk.CTkLabel(advanced_frame, text="Style Influence:").grid(row=4, column=0, padx=10, pady=5, sticky="w")
        self.style_influence_var = ctk.IntVar(value=50)
        self.style_influence_slider = ctk.CTkSlider(
            advanced_frame,
            from_=0,
            to=100,
            variable=self.style_influence_var,
            width=200
        )
        self.style_influence_slider.grid(row=4, column=1, padx=10, pady=5, sticky="w")
        self.style_influence_label = ctk.CTkLabel(advanced_frame, text="50%")
        self.style_influence_label.grid(row=4, column=2, padx=5, pady=5)
        self.style_influence_slider.configure(command=self._update_style_influence_label)
        
        # 5ï¸âƒ£ PHáº¦N 5: PROGRESS & ACTIONS
        progress_frame = ctk.CTkFrame(left_container)
        progress_frame.grid(row=4, column=0, sticky="ew", padx=10, pady=5)
        progress_frame.grid_columnconfigure(0, weight=1)
        
        # Progress bar
        self.progress_bar = ctk.CTkProgressBar(progress_frame)
        self.progress_bar.grid(row=0, column=0, padx=10, pady=5, sticky="ew")
        self.progress_bar.set(0)
        
        # Progress label
        self.progress_label = ctk.CTkLabel(progress_frame, text="ChÆ°a báº¯t Ä‘áº§u")
        self.progress_label.grid(row=1, column=0, padx=10, pady=5)
        
        # Buttons
        button_frame = ctk.CTkFrame(progress_frame)
        button_frame.grid(row=2, column=0, pady=10)
        
        self.create_button = ctk.CTkButton(
            button_frame,
            text="Táº¡o BÃ i HÃ¡t",
            command=self._on_create_click,
            width=200,
            height=40,
            font=("Arial", 14, "bold")
        )
        self.create_button.grid(row=0, column=0, padx=10)
        
        self.clear_button = ctk.CTkButton(
            button_frame,
            text="XÃ³a Form",
            command=self._clear_form,
            width=150,
            height=40
        )
        self.clear_button.grid(row=0, column=1, padx=10)
        
        # ============================================
        # Cá»˜T PHáº¢I: Káº¾T QUáº¢ BÃ€I HÃT ÄÃƒ Táº O
        # ============================================
        right_container = ctk.CTkFrame(self, width=600)
        right_container.grid(row=1, column=1, padx=10, pady=10, sticky="nsew")
        
        # Title cá»™t pháº£i
        ctk.CTkLabel(
            right_container,
            text="ðŸŽ¤ BÃ i HÃ¡t ÄÃ£ Táº¡o",
            font=("Arial", 18, "bold")
        ).pack(pady=10)
        
        # Scrollable frame cho danh sÃ¡ch bÃ i hÃ¡t
        self.songs_list_frame = ctk.CTkScrollableFrame(right_container, width=550, height=650)
        self.songs_list_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Message khi chÆ°a cÃ³ bÃ i nÃ o
        self.empty_label = ctk.CTkLabel(
            self.songs_list_frame,
            text="ChÆ°a cÃ³ bÃ i hÃ¡t nÃ o.\nNháº¥n 'Táº¡o BÃ i HÃ¡t' Ä‘á»ƒ báº¯t Ä‘áº§u!",
            font=("Arial", 12),
            text_color="gray"
        )
        self.empty_label.pack(pady=50)
        
    def _get_account_list(self):
        """Láº¥y danh sÃ¡ch accounts tá»« AccountManager"""
        accounts = self.account_manager.get_all_accounts()
        if not accounts:
            return ["ChÆ°a cÃ³ account nÃ o"]
        return [acc.name for acc in accounts]
    
    def _update_weirdness_label(self, value):
        """Cáº­p nháº­t label Weirdness slider"""
        self.weirdness_label.configure(text=f"{int(float(value))}%")
    
    def _update_style_influence_label(self, value):
        """Cáº­p nháº­t label Style Influence slider"""
        self.style_influence_label.configure(text=f"{int(float(value))}%")
    
    def _clear_form(self):
        """XÃ³a toÃ n bá»™ form"""
        self.persona_var.set("")
        self.lyrics_text.delete("1.0", "end")
        self.styles_var.set("")
        self.title_var.set("")
        self.vocal_gender_var.set("Auto")
        self.lyrics_mode_var.set("Auto")
        self.weirdness_var.set(50)
        self.style_influence_var.set(50)
        self.progress_bar.set(0)
        self.progress_label.configure(text="ChÆ°a báº¯t Ä‘áº§u")
    
    def _update_progress(self, message: str, progress: int):
        """
        Callback tá»« SunoMusicCreator Ä‘á»ƒ cáº­p nháº­t progress
        
        Args:
            message: ThÃ´ng Ä‘iá»‡p hiá»ƒn thá»‹
            progress: % hoÃ n thÃ nh (0-100)
        """
        self.progress_label.configure(text=message)
        self.progress_bar.set(progress / 100)
    
    def _on_create_click(self):
        """Xá»­ lÃ½ khi click nÃºt Táº¡o BÃ i HÃ¡t"""
        # Validate
        account_name = self.account_var.get()
        if not account_name or account_name == "ChÆ°a cÃ³ account nÃ o":
            self._update_progress("âŒ Vui lÃ²ng chá»n account!", 0)
            return
        
        styles = self.styles_var.get().strip()
        if not styles:
            self._update_progress("âŒ Vui lÃ²ng nháº­p Styles!", 0)
            return
        
        # Disable button
        self.create_button.configure(state="disabled", text="Äang táº¡o...")
        
        # Cháº¡y trong thread riÃªng Ä‘á»ƒ khÃ´ng block UI
        thread = threading.Thread(
            target=self._create_music_thread,
            args=(account_name,),
            daemon=True
        )
        thread.start()
    
    def _create_music_thread(self, account_name: str):
        """Thread worker Ä‘á»ƒ táº¡o nháº¡c"""
        try:
            # Táº¡o config
            config = SunoCreateConfig(
                persona_name=self.persona_var.get().strip() or None,
                lyrics=self.lyrics_text.get("1.0", "end").strip(),
                styles=self.styles_var.get().strip(),
                title=self.title_var.get().strip() or None,
                vocal_gender=None if self.vocal_gender_var.get() == "Auto" else self.vocal_gender_var.get(),
                lyrics_mode=None if self.lyrics_mode_var.get() == "Auto" else self.lyrics_mode_var.get(),
                weirdness=self.weirdness_var.get(),
                style_influence=self.style_influence_var.get(),
                wait_for_generation=True,
                timeout=120
            )
            
            # Táº¡o nháº¡c
            result = self.music_creator.create_song(account_name, config)
            
            # Hiá»ƒn thá»‹ káº¿t quáº£
            if result["success"]:
                # Táº¡o XML prompt
                prompt_xml = self._generate_prompt_xml(config)
                
                # ThÃªm vÃ o danh sÃ¡ch
                song_title = config.title or "Untitled Song"
                for url in result["song_urls"]:
                    self._add_song_to_list(song_title, prompt_xml, url)
                
                self._update_progress(f"âœ… ÄÃ£ táº¡o {len(result['song_urls'])} bÃ i hÃ¡t!", 100)
            else:
                self._update_progress(f"âŒ Lá»—i: {result['error']}", 0)
                
        except Exception as e:
            self._update_progress(f"âŒ Exception: {str(e)}", 0)
        finally:
            # Re-enable button
            self.create_button.configure(state="normal", text="Táº¡o BÃ i HÃ¡t")
    
    def refresh(self):
        """Refresh panel - gá»i khi panel Ä‘Æ°á»£c hiá»ƒn thá»‹"""
        # Cáº­p nháº­t danh sÃ¡ch accounts
        accounts = self._get_account_list()
        self.account_dropdown.configure(values=accounts)
        if accounts and accounts[0] != "ChÆ°a cÃ³ account nÃ o":
            self.account_var.set(accounts[0])
    
    def _generate_prompt_xml(self, config: SunoCreateConfig) -> str:
        """Táº¡o XML prompt tá»« config"""
        import xml.etree.ElementTree as ET
        from xml.dom import minidom
        
        root = ET.Element("suno_prompt")
        
        if config.persona_name:
            ET.SubElement(root, "persona").text = config.persona_name
        
        ET.SubElement(root, "lyrics").text = config.lyrics or ""
        ET.SubElement(root, "styles").text = config.styles or ""
        
        if config.title:
            ET.SubElement(root, "title").text = config.title
        
        # Advanced options
        if config.vocal_gender:
            ET.SubElement(root, "vocal_gender").text = config.vocal_gender
        if config.lyrics_mode:
            ET.SubElement(root, "lyrics_mode").text = config.lyrics_mode
        if config.weirdness and config.weirdness != 50:
            ET.SubElement(root, "weirdness").text = str(config.weirdness)
        if config.style_influence and config.style_influence != 50:
            ET.SubElement(root, "style_influence").text = str(config.style_influence)
        
        # Pretty print XML
        xml_str = ET.tostring(root, encoding='unicode')
        dom = minidom.parseString(xml_str)
        return dom.toprettyxml(indent="  ")
    
    def _add_song_to_list(self, title: str, prompt_xml: str, url: str):
        """ThÃªm bÃ i hÃ¡t vÃ o danh sÃ¡ch káº¿t quáº£"""
        # áº¨n empty label náº¿u Ä‘Ã¢y lÃ  bÃ i Ä‘áº§u tiÃªn
        if len(self.created_songs) == 0:
            self.empty_label.pack_forget()
        
        # ThÃªm vÃ o storage
        song_data = {
            "title": title,
            "prompt_xml": prompt_xml,
            "url": url
        }
        self.created_songs.append(song_data)
        
        # Táº¡o song card
        song_card = ctk.CTkFrame(self.songs_list_frame)
        song_card.pack(fill="x", padx=5, pady=5)
        
        # Title
        title_label = ctk.CTkLabel(
            song_card,
            text=f"{title}",
            font=("Arial", 13, "bold"),
            anchor="w"
        )
        title_label.pack(fill="x", padx=10, pady=(10, 5))
        
        # URL (clickable)
        url_label = ctk.CTkLabel(
            song_card,
            text=f"ðŸ”— {url[:60]}...",
            font=("Arial", 10),
            text_color="blue",
            anchor="w",
            cursor="hand2"
        )
        url_label.pack(fill="x", padx=10, pady=5)
        
        # Bind click Ä‘á»ƒ copy URL
        url_label.bind("<Button-1>", lambda e: self._copy_to_clipboard(url))
        
        # Button frame
        btn_frame = ctk.CTkFrame(song_card)
        btn_frame.pack(fill="x", padx=10, pady=(5, 10))
        
        # Copy XML button
        copy_btn = ctk.CTkButton(
            btn_frame,
            text="ðŸ“‹ Copy XML Prompt",
            command=lambda: self._copy_to_clipboard(prompt_xml),
            width=150,
            height=30,
            font=("Arial", 11)
        )
        copy_btn.pack(side="left", padx=5)
        
        # Copy URL button
        copy_url_btn = ctk.CTkButton(
            btn_frame,
            text="ðŸ”— Copy URL",
            command=lambda: self._copy_to_clipboard(url),
            width=120,
            height=30,
            font=("Arial", 11),
            fg_color="gray40"
        )
        copy_url_btn.pack(side="left", padx=5)
    
    def _copy_to_clipboard(self, text: str):
        """Copy text vÃ o clipboard"""
        import pyperclip
        try:
            pyperclip.copy(text)
            # Show temporary notification
            self._update_progress("âœ… ÄÃ£ copy vÃ o clipboard!", 100)
        except:
            self._update_progress("âŒ KhÃ´ng thá»ƒ copy", 0)
</file>

<file path="src/ui/create_music_panel.py.backup">
"""
Create Music Panel - UI Ä‘á»ƒ táº¡o nháº¡c tá»± Ä‘á»™ng trÃªn Suno
"""
import customtkinter as ctk
import threading
from typing import Optional
from pathlib import Path

# Import tá»« core
from src.core.account_manager import AccountManager
from src.core.session_manager import SessionManager
from suno_auto_create import SunoMusicCreator, SunoCreateConfig


class CreateMusicPanel(ctk.CTkFrame):
    """
    Panel táº¡o nháº¡c tá»± Ä‘á»™ng vá»›i Suno Custom Mode
    
    Features:
    - Chá»n account Ä‘Ã£ lÆ°u
    - Nháº­p Persona, Lyrics, Styles, Title
    - Cáº¥u hÃ¬nh Advanced Options
    - Progress bar hiá»ƒn thá»‹ tiáº¿n trÃ¬nh
    - Hiá»ƒn thá»‹ káº¿t quáº£ (URLs bÃ i hÃ¡t)
    """
    
    def __init__(self, parent, account_manager: AccountManager, session_manager: SessionManager):
        super().__init__(parent)
        
        self.account_manager = account_manager
        self.session_manager = session_manager
        self.music_creator = SunoMusicCreator(
            session_manager=session_manager,
            progress_callback=self._update_progress
        )
        
        # Storage cho created songs
        self.created_songs = []  # List of {title, prompt_xml, urls}
        
        self.setup_ui()
        
    def setup_ui(self):
        """Thiáº¿t láº­p giao diá»‡n 2 cá»™t: Form (trÃ¡i) vÃ  Káº¿t quáº£ (pháº£i)"""
        
        # Configure grid weights Ä‘á»ƒ 2 cá»™t co giÃ£n
        self.grid_columnconfigure(0, weight=1)  # Cá»™t trÃ¡i
        self.grid_columnconfigure(1, weight=1)  # Cá»™t pháº£i
        
        # Title (full width)
        title_label = ctk.CTkLabel(
            self, 
            text="ðŸŽµ Táº¡o Nháº¡c Tá»± Äá»™ng",
            font=("Arial", 24, "bold")
        )
        title_label.grid(row=0, column=0, columnspan=2, pady=20)
        
        # ============================================
        # Cá»˜T TRÃI: FORM INPUT
        # ============================================
        left_container = ctk.CTkScrollableFrame(self, width=700)
        left_container.grid(row=1, column=0, padx=10, pady=10, sticky="nsew")
        
        # PHáº¦N 1: CHá»ŒN ACCOUNT
        # PHáº¦N 1: CHá»ŒN ACCOUNT
        account_frame = ctk.CTkFrame(left_container)
        account_frame.pack(fill="x", padx=10, pady=10)
        
        ctk.CTkLabel(account_frame, text="Account:", font=("Arial", 14, "bold")).grid(
            row=0, column=0, padx=10, pady=10, sticky="w"
        )
        
        self.account_var = ctk.StringVar()
        self.account_dropdown = ctk.CTkComboBox(
            account_frame,
            variable=self.account_var,
            values=self._get_account_list(),
            width=300
        )
        self.account_dropdown.grid(row=0, column=1, padx=10, pady=10)
        
        # PHáº¦N 2: PERSONA (Optional)
        persona_frame = ctk.CTkFrame(left_container)
        persona_frame.pack(fill="x", padx=10, pady=10)
        
        ctk.CTkLabel(persona_frame, text="Persona (optional):", font=("Arial", 14, "bold")).grid(
            row=0, column=0, padx=10, pady=10, sticky="w"
        )
        
        self.persona_var = ctk.StringVar()
        self.persona_entry = ctk.CTkEntry(
            persona_frame,
            textvariable=self.persona_var,
            placeholder_text="Nháº­p tÃªn Persona hoáº·c Ä‘á»ƒ trá»‘ng",
            width=300
        )
        self.persona_entry.grid(row=0, column=1, padx=10, pady=10)
        
        # PHáº¦N 3: Ná»˜I DUNG CHÃNH
        content_frame = ctk.CTkFrame(left_container)
        content_frame.pack(fill="x", padx=10, pady=10)
        
        # Lyrics
        ctk.CTkLabel(content_frame, text="Lyrics:", font=("Arial", 14, "bold")).grid(
            row=0, column=0, padx=10, pady=5, sticky="nw"
        )
        
        self.lyrics_text = ctk.CTkTextbox(content_frame, width=600, height=150)
        self.lyrics_text.grid(row=0, column=1, padx=10, pady=5)
        self.lyrics_text.insert("1.0", "[Verse 1]\nLá»i bÃ i hÃ¡t...\n\n[Chorus]\n...")
        
        # Styles
        ctk.CTkLabel(content_frame, text="Styles:", font=("Arial", 14, "bold")).grid(
            row=1, column=0, padx=10, pady=5, sticky="w"
        )
        
        self.styles_var = ctk.StringVar()
        self.styles_entry = ctk.CTkEntry(
            content_frame,
            textvariable=self.styles_var,
            placeholder_text="Pop, upbeat, 120bpm, piano, guitar...",
            width=600
        )
        self.styles_entry.grid(row=1, column=1, padx=10, pady=5)
        
        # Title
        ctk.CTkLabel(content_frame, text="Title (optional):", font=("Arial", 14, "bold")).grid(
            row=2, column=0, padx=10, pady=5, sticky="w"
        )
        
        self.title_var = ctk.StringVar()
        self.title_entry = ctk.CTkEntry(
            content_frame,
            textvariable=self.title_var,
            placeholder_text="TÃªn bÃ i hÃ¡t (Ä‘á»ƒ trá»‘ng Ä‘á»ƒ AI tá»± Ä‘áº·t)",
            width=600
        )
        self.title_entry.grid(row=2, column=1, padx=10, pady=5)
        
        # ============================================
        # PHáº¦N 4: ADVANCED OPTIONS
        # ============================================
        advanced_frame = ctk.CTkFrame(self)
        advanced_frame.grid(row=4, column=0, columnspan=2, padx=20, pady=10, sticky="ew")
        
        ctk.CTkLabel(advanced_frame, text="Advanced Options", font=("Arial", 14, "bold")).grid(
            row=0, column=0, columnspan=2, padx=10, pady=10
        )
        
        # Vocal Gender
        ctk.CTkLabel(advanced_frame, text="Vocal Gender:").grid(row=1, column=0, padx=10, pady=5, sticky="w")
        self.vocal_gender_var = ctk.StringVar(value="Auto")
        vocal_gender_dropdown = ctk.CTkComboBox(
            advanced_frame,
            variable=self.vocal_gender_var,
            values=["Auto", "Male", "Female"],
            width=200
        )
        vocal_gender_dropdown.grid(row=1, column=1, padx=10, pady=5, sticky="w")
        
        # Lyrics Mode
        ctk.CTkLabel(advanced_frame, text="Lyrics Mode:").grid(row=2, column=0, padx=10, pady=5, sticky="w")
        self.lyrics_mode_var = ctk.StringVar(value="Auto")
        lyrics_mode_dropdown = ctk.CTkComboBox(
            advanced_frame,
            variable=self.lyrics_mode_var,
            values=["Auto", "Manual"],
            width=200
        )
        lyrics_mode_dropdown.grid(row=2, column=1, padx=10, pady=5, sticky="w")
        
        # Weirdness
        ctk.CTkLabel(advanced_frame, text="Weirdness:").grid(row=3, column=0, padx=10, pady=5, sticky="w")
        self.weirdness_var = ctk.IntVar(value=50)
        self.weirdness_slider = ctk.CTkSlider(
            advanced_frame,
            from_=0,
            to=100,
            variable=self.weirdness_var,
            width=200
        )
        self.weirdness_slider.grid(row=3, column=1, padx=10, pady=5, sticky="w")
        self.weirdness_label = ctk.CTkLabel(advanced_frame, text="50%")
        self.weirdness_label.grid(row=3, column=2, padx=5, pady=5)
        self.weirdness_slider.configure(command=self._update_weirdness_label)
        
        # Style Influence
        ctk.CTkLabel(advanced_frame, text="Style Influence:").grid(row=4, column=0, padx=10, pady=5, sticky="w")
        self.style_influence_var = ctk.IntVar(value=50)
        self.style_influence_slider = ctk.CTkSlider(
            advanced_frame,
            from_=0,
            to=100,
            variable=self.style_influence_var,
            width=200
        )
        self.style_influence_slider.grid(row=4, column=1, padx=10, pady=5, sticky="w")
        self.style_influence_label = ctk.CTkLabel(advanced_frame, text="50%")
        self.style_influence_label.grid(row=4, column=2, padx=5, pady=5)
        self.style_influence_slider.configure(command=self._update_style_influence_label)
        
        # ============================================
        # PHáº¦N 5: PROGRESS & ACTIONS
        # ============================================
        progress_frame = ctk.CTkFrame(self)
        progress_frame.grid(row=5, column=0, columnspan=2, padx=20, pady=10, sticky="ew")
        
        # Progress bar
        self.progress_bar = ctk.CTkProgressBar(progress_frame, width=600)
        self.progress_bar.grid(row=0, column=0, columnspan=2, padx=10, pady=5)
        self.progress_bar.set(0)
        
        # Progress label
        self.progress_label = ctk.CTkLabel(progress_frame, text="ChÆ°a báº¯t Ä‘áº§u")
        self.progress_label.grid(row=1, column=0, columnspan=2, padx=10, pady=5)
        
        # Buttons
        button_frame = ctk.CTkFrame(progress_frame)
        button_frame.grid(row=2, column=0, columnspan=2, pady=10)
        
        self.create_button = ctk.CTkButton(
            button_frame,
            text="ðŸŽ¼ Táº¡o BÃ i HÃ¡t",
            command=self._on_create_click,
            width=200,
            height=40,
            font=("Arial", 14, "bold")
        )
        self.create_button.pack(side="left", padx=10)
        
        self.clear_button = ctk.CTkButton(
            button_frame,
            text="ðŸ—‘ï¸ XÃ³a Form",
            command=self._clear_form,
            width=150,
            height=40
        )
        self.clear_button.pack(side="left", padx=10)
        
        # ============================================
        # PHáº¦N 6: Káº¾T QUáº¢
        # ============================================
        result_frame = ctk.CTkFrame(self)
        result_frame.grid(row=6, column=0, columnspan=2, padx=20, pady=10, sticky="ew")
        
        ctk.CTkLabel(result_frame, text="Káº¿t quáº£:", font=("Arial", 14, "bold")).grid(
            row=0, column=0, padx=10, pady=5, sticky="w"
        )
        
        self.result_text = ctk.CTkTextbox(result_frame, width=600, height=100)
        self.result_text.grid(row=1, column=0, padx=10, pady=5)
        
    def _get_account_list(self):
        """Láº¥y danh sÃ¡ch accounts tá»« AccountManager"""
        accounts = self.account_manager.get_all_accounts()
        if not accounts:
            return ["ChÆ°a cÃ³ account nÃ o"]
        return [acc.name for acc in accounts]
    
    def _update_weirdness_label(self, value):
        """Cáº­p nháº­t label Weirdness slider"""
        self.weirdness_label.configure(text=f"{int(float(value))}%")
    
    def _update_style_influence_label(self, value):
        """Cáº­p nháº­t label Style Influence slider"""
        self.style_influence_label.configure(text=f"{int(float(value))}%")
    
    def _clear_form(self):
        """XÃ³a toÃ n bá»™ form"""
        self.persona_var.set("")
        self.lyrics_text.delete("1.0", "end")
        self.styles_var.set("")
        self.title_var.set("")
        self.vocal_gender_var.set("Auto")
        self.lyrics_mode_var.set("Auto")
        self.weirdness_var.set(50)
        self.style_influence_var.set(50)
        self.progress_bar.set(0)
        self.progress_label.configure(text="ChÆ°a báº¯t Ä‘áº§u")
        self.result_text.delete("1.0", "end")
    
    def _update_progress(self, message: str, progress: int):
        """
        Callback tá»« SunoMusicCreator Ä‘á»ƒ cáº­p nháº­t progress
        
        Args:
            message: ThÃ´ng Ä‘iá»‡p hiá»ƒn thá»‹
            progress: % hoÃ n thÃ nh (0-100)
        """
        self.progress_label.configure(text=message)
        self.progress_bar.set(progress / 100)
    
    def _on_create_click(self):
        """Xá»­ lÃ½ khi click nÃºt Táº¡o BÃ i HÃ¡t"""
        # Validate
        account_name = self.account_var.get()
        if not account_name or account_name == "ChÆ°a cÃ³ account nÃ o":
            self.result_text.delete("1.0", "end")
            self.result_text.insert("1.0", "âŒ Vui lÃ²ng chá»n account!")
            return
        
        styles = self.styles_var.get().strip()
        if not styles:
            self.result_text.delete("1.0", "end")
            self.result_text.insert("1.0", "âŒ Vui lÃ²ng nháº­p Styles!")
            return
        
        # Disable button
        self.create_button.configure(state="disabled", text="â³ Äang táº¡o...")
        
        # Cháº¡y trong thread riÃªng Ä‘á»ƒ khÃ´ng block UI
        thread = threading.Thread(
            target=self._create_music_thread,
            args=(account_name,),
            daemon=True
        )
        thread.start()
    
    def _create_music_thread(self, account_name: str):
        """Thread worker Ä‘á»ƒ táº¡o nháº¡c"""
        try:
            # Táº¡o config
            config = SunoCreateConfig(
                persona_name=self.persona_var.get().strip() or None,
                lyrics=self.lyrics_text.get("1.0", "end").strip(),
                styles=self.styles_var.get().strip(),
                title=self.title_var.get().strip() or None,
                vocal_gender=None if self.vocal_gender_var.get() == "Auto" else self.vocal_gender_var.get(),
                lyrics_mode=None if self.lyrics_mode_var.get() == "Auto" else self.lyrics_mode_var.get(),
                weirdness=self.weirdness_var.get(),
                style_influence=self.style_influence_var.get(),
                wait_for_generation=True,
                timeout=120
            )
            
            # Táº¡o nháº¡c
            result = self.music_creator.create_song(account_name, config)
            
            # Hiá»ƒn thá»‹ káº¿t quáº£
            self.result_text.delete("1.0", "end")
            
            if result["success"]:
                output = f"âœ… Táº¡o nháº¡c thÃ nh cÃ´ng!\n\n"
                output += f"Steps: {', '.join(result['steps_completed'])}\n\n"
                output += f"ÄÃ£ táº¡o {len(result['song_urls'])} bÃ i hÃ¡t:\n"
                for url in result["song_urls"]:
                    output += f"  ðŸŽµ {url}\n"
                self.result_text.insert("1.0", output)
            else:
                output = f"âŒ Lá»—i: {result['error']}\n\n"
                output += f"Steps completed: {', '.join(result['steps_completed'])}"
                self.result_text.insert("1.0", output)
                
        except Exception as e:
            self.result_text.delete("1.0", "end")
            self.result_text.insert("1.0", f"âŒ Exception: {str(e)}")
        finally:
            # Re-enable button
            self.create_button.configure(state="normal", text="ðŸŽ¼ Táº¡o BÃ i HÃ¡t")
    
    def refresh(self):
        """Refresh panel - gá»i khi panel Ä‘Æ°á»£c hiá»ƒn thá»‹"""
        # Cáº­p nháº­t danh sÃ¡ch accounts
        accounts = self._get_account_list()
        self.account_dropdown.configure(values=accounts)
        if accounts and accounts[0] != "ChÆ°a cÃ³ account nÃ o":
            self.account_var.set(accounts[0])
</file>

<file path="src/ui/download_panel.py">
"""
Download Panel - Táº£i bÃ i hÃ¡t
"""
import threading
from pathlib import Path
from urllib.parse import urlparse

import customtkinter as ctk
from tkinter import filedialog, messagebox

from config.settings import DOWNLOADS_DIR
from src.core import AccountManager, DownloadManager, SessionManager
from src.utils import logger, validate_profile_name


class DownloadPanel(ctk.CTkFrame):
    """Panel download bÃ i hÃ¡t"""

    def __init__(
        self,
        parent,
        account_manager: AccountManager,
        session_manager: SessionManager,
        download_manager: DownloadManager,
    ):
        super().__init__(parent)

        self.account_manager = account_manager
        self.session_manager = session_manager
        self.download_manager = download_manager

        self.selected_account = None
        self.downloading = False

        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(1, weight=1)

        self.create_ui()

    def create_ui(self):
        """Create UI components"""

        # Header
        header = ctk.CTkLabel(
            self,
            text="Download bÃ i hÃ¡t",
            font=ctk.CTkFont(size=24, weight="bold"),
        )
        header.grid(row=0, column=0, sticky="w", pady=(0, 20))

        # Main content
        content = ctk.CTkFrame(self)
        content.grid(row=1, column=0, sticky="nsew")
        content.grid_columnconfigure(0, weight=1)

        # Account selection
        account_frame = ctk.CTkFrame(content)
        account_frame.grid(row=0, column=0, sticky="ew", padx=20, pady=10)
        account_frame.grid_columnconfigure(1, weight=1)

        ctk.CTkLabel(
            account_frame,
            text="TÃ i khoáº£n:",
            font=ctk.CTkFont(size=14, weight="bold"),
        ).grid(row=0, column=0, padx=20, pady=15, sticky="w")

        self.account_menu = ctk.CTkOptionMenu(
            account_frame,
            values=["Chá»n tÃ i khoáº£n..."],
            command=self.on_account_selected,
            width=300,
        )
        self.account_menu.grid(row=0, column=1, padx=20, pady=15, sticky="w")

        # Profile input
        profile_frame = ctk.CTkFrame(content)
        profile_frame.grid(row=1, column=0, sticky="ew", padx=20, pady=10)
        profile_frame.grid_columnconfigure(1, weight=1)

        ctk.CTkLabel(
            profile_frame,
            text="Download tá»«:",
            font=ctk.CTkFont(size=14, weight="bold"),
        ).grid(row=0, column=0, padx=20, pady=15, sticky="w")

        # Checkbox Ä‘á»ƒ chá»n download tá»« /create
        self.use_my_songs = ctk.BooleanVar(value=True)
        my_songs_check = ctk.CTkCheckBox(
            profile_frame,
            text="BÃ i hÃ¡t cá»§a tÃ´i (/create)",
            variable=self.use_my_songs,
            command=self.toggle_profile_input,
        )
        my_songs_check.grid(row=0, column=1, padx=20, pady=15, sticky="w")

        # Profile entry (disabled khi dÃ¹ng /create)
        self.profile_entry = ctk.CTkEntry(
            profile_frame,
            placeholder_text="@username hoáº·c link profile",
            width=300,
            state="disabled",
        )
        self.profile_entry.grid(row=0, column=2, padx=20, pady=15, sticky="w")

        # Download options
        options_frame = ctk.CTkFrame(content)
        options_frame.grid(row=2, column=0, sticky="ew", padx=20, pady=10)

        ctk.CTkLabel(
            options_frame,
            text="TÃ¹y chá»n:",
            font=ctk.CTkFont(size=14, weight="bold"),
        ).grid(row=0, column=0, padx=20, pady=(15, 5), sticky="w")

        # Limit
        limit_frame = ctk.CTkFrame(options_frame, fg_color="transparent")
        limit_frame.grid(row=1, column=0, sticky="ew", padx=20, pady=5)

        ctk.CTkLabel(limit_frame, text="Sá»‘ bÃ i táº£i:").grid(
            row=0, column=0, sticky="w"
        )
        self.limit_entry = ctk.CTkEntry(limit_frame, width=100, placeholder_text="Táº¥t cáº£")
        self.limit_entry.grid(row=0, column=1, padx=10)

        # Thumbnail
        self.thumbnail_var = ctk.BooleanVar(value=True)
        thumbnail_check = ctk.CTkCheckBox(
            options_frame,
            text="Táº£i thumbnail & metadata",
            variable=self.thumbnail_var,
        )
        thumbnail_check.grid(row=2, column=0, padx=20, pady=5, sticky="w")

        # UUID
        self.uuid_var = ctk.BooleanVar(value=True)
        uuid_check = ctk.CTkCheckBox(
            options_frame,
            text="ThÃªm UUID vÃ o tÃªn file",
            variable=self.uuid_var,
        )
        uuid_check.grid(row=3, column=0, padx=20, pady=5, sticky="w")

        # Resume download
        self.resume_var = ctk.BooleanVar(value=True)
        resume_check = ctk.CTkCheckBox(
            options_frame,
            text="Tiáº¿p tá»¥c táº£i tá»« trang Ä‘Ã£ lÆ°u",
            variable=self.resume_var,
        )
        resume_check.grid(row=4, column=0, padx=20, pady=5, sticky="w")

        # Output directory
        dir_frame = ctk.CTkFrame(options_frame, fg_color="transparent")
        dir_frame.grid(row=5, column=0, sticky="ew", padx=20, pady=(5, 15))
        dir_frame.grid_columnconfigure(1, weight=1)

        ctk.CTkLabel(dir_frame, text="ThÆ° má»¥c:").grid(row=0, column=0, sticky="w")

        self.dir_entry = ctk.CTkEntry(dir_frame, placeholder_text="Máº·c Ä‘á»‹nh")
        self.dir_entry.grid(row=0, column=1, padx=10, sticky="ew")

        browse_btn = ctk.CTkButton(
            dir_frame,
            text="Chá»n",
            command=self.browse_directory,
            width=40,
        )
        browse_btn.grid(row=0, column=2)

        # Download button
        self.download_btn = ctk.CTkButton(
            content,
            text="Báº¯t Ä‘áº§u táº£i",
            command=self.start_download,
            height=50,
            font=ctk.CTkFont(size=16, weight="bold"),
        )
        self.download_btn.grid(row=3, column=0, padx=20, pady=20, sticky="ew")

        # Progress
        self.progress_frame = ctk.CTkFrame(content)
        self.progress_frame.grid(row=4, column=0, sticky="ew", padx=20, pady=(0, 20))
        self.progress_frame.grid_columnconfigure(0, weight=1)

        self.progress_label = ctk.CTkLabel(
            self.progress_frame,
            text="",
            font=ctk.CTkFont(size=12),
        )
        self.progress_label.grid(row=0, column=0, padx=20, pady=(15, 5), sticky="w")

        self.progress_bar = ctk.CTkProgressBar(self.progress_frame)
        self.progress_bar.grid(row=1, column=0, padx=20, pady=(0, 15), sticky="ew")
        self.progress_bar.set(0)

        self.progress_frame.grid_remove()

    def toggle_profile_input(self):
        """Toggle profile input based on checkbox"""
        if self.use_my_songs.get():
            self.profile_entry.configure(state="disabled")
        else:
            self.profile_entry.configure(state="normal")

    def refresh(self):
        """Refresh account list"""
        accounts = self.account_manager.get_all_accounts()

        if accounts:
            account_names = [acc.name for acc in accounts]
            self.account_menu.configure(values=account_names)
            if account_names:
                self.account_menu.set(account_names[0])
                self.selected_account = account_names[0]
        else:
            self.account_menu.configure(values=["ChÆ°a cÃ³ tÃ i khoáº£n"])
            self.account_menu.set("ChÆ°a cÃ³ tÃ i khoáº£n")
            self.selected_account = None

    def on_account_selected(self, account_name: str):
        """Handle account selection"""
        self.selected_account = account_name

        # Auto-fill profile if email available
        account = self.account_manager.get_account(account_name)
        if account and account.email:
            username = account.email.split("@")[0]
            self.profile_entry.delete(0, "end")
            self.profile_entry.insert(0, f"@{username}")

    def browse_directory(self):
        """Browse for output directory"""
        directory = filedialog.askdirectory()
        if directory:
            self.dir_entry.delete(0, "end")
            self.dir_entry.insert(0, directory)

    def start_download(self):
        """Start download process"""

        if self.downloading:
            messagebox.showwarning("Cáº£nh bÃ¡o", "Äang táº£i, vui lÃ²ng Ä‘á»£i!")
            return

        if not self.selected_account:
            messagebox.showerror("Lá»—i", "Vui lÃ²ng chá»n tÃ i khoáº£n!")
            return

        # Determine source
        use_my_songs = self.use_my_songs.get()
        profile_name: str | None = None

        if not use_my_songs:
            raw_profile = self.profile_entry.get().strip()
            if not raw_profile:
                messagebox.showerror(
                    "Lá»—i",
                    "Vui lÃ²ng nháº­p tÃªn profile hoáº·c chá»n 'BÃ i hÃ¡t cá»§a tÃ´i'!",
                )
                return

            profile_name = self._normalize_profile_input(raw_profile)
            if not profile_name or not validate_profile_name(profile_name):
                messagebox.showerror(
                    "Lá»—i",
                    "TÃªn profile khÃ´ng há»£p lá»‡!\nVD: @username hoáº·c https://suno.com/@username",
                )
                return

        # Get limit
        limit_str = self.limit_entry.get().strip()
        limit: int | None = None
        if limit_str:
            try:
                limit = int(limit_str)
                if limit <= 0:
                    messagebox.showerror("Lá»—i", "Sá»‘ bÃ i pháº£i > 0!")
                    return
            except ValueError:
                messagebox.showerror("Lá»—i", "Sá»‘ bÃ i khÃ´ng há»£p lá»‡!")
                return

        # Output directory
        output_dir = self.dir_entry.get().strip()
        if not output_dir:
            output_dir = str(DOWNLOADS_DIR / self.selected_account)

        output_path = Path(output_dir)
        try:
            output_path.mkdir(parents=True, exist_ok=True)
        except Exception as exc:
            messagebox.showerror("Lá»—i", f"KhÃ´ng táº¡o Ä‘Æ°á»£c thÆ° má»¥c:\n{exc}")
            return

        source_text = "BÃ i hÃ¡t cá»§a tÃ´i (/create)" if use_my_songs else profile_name
        if not messagebox.askyesno(
            "XÃ¡c nháº­n",
            f"Táº£i bÃ i hÃ¡t tá»«: {source_text}\n"
            f"TÃ i khoáº£n: {self.selected_account}\n"
            f"Sá»‘ bÃ i: {limit if limit else 'Táº¥t cáº£'}\n"
            f"ThÆ° má»¥c: {output_path}\n\n"
            "Tiáº¿p tá»¥c?",
        ):
            return

        thread = threading.Thread(
            target=self.download_thread,
            args=(use_my_songs, profile_name, limit, output_path),
            daemon=True,
        )
        thread.start()

    def download_thread(
        self,
        use_my_songs: bool,
        profile_name: str | None,
        limit: int | None,
        output_path: Path,
    ):
        """Download in background thread"""

        self.downloading = True
        self.download_btn.configure(state="disabled", text="Äang táº£i...")
        self.progress_frame.grid()

        driver = None

        try:
            self.update_progress("Äang má»Ÿ trÃ¬nh duyá»‡t...", 0)

            if use_my_songs:
                session_token, driver = self.session_manager.get_session_token_from_me_page(
                    self.selected_account
                )

                if not session_token:
                    messagebox.showerror(
                        "Lá»—i",
                        "KhÃ´ng láº¥y Ä‘Æ°á»£c session token!\n\n"
                        "NguyÃªn nhÃ¢n cÃ³ thá»ƒ:\n"
                        "1. Profile Ä‘ang Ä‘Æ°á»£c sá»­ dá»¥ng - Ä‘Ã³ng táº¥t cáº£ cá»­a sá»• Chrome\n"
                        "2. ChÆ°a Ä‘Äƒng nháº­p - dÃ¹ng 'Sá»­ dá»¥ng tÃ i khoáº£n' Ä‘á»ƒ Ä‘Äƒng nháº­p\n"
                        "3. Session háº¿t háº¡n - Ä‘Äƒng nháº­p láº¡i",
                    )
                    return
            else:
                session_token = self.session_manager.get_session_token(self.selected_account)

                if not session_token:
                    messagebox.showerror(
                        "Lá»—i",
                        "KhÃ´ng láº¥y Ä‘Æ°á»£c session token!\n"
                        "HÃ£y Ä‘Äƒng nháº­p láº¡i tÃ i khoáº£n.",
                    )
                    return

            output_path.mkdir(parents=True, exist_ok=True)

            # Use paginated streaming download to save memory
            self.update_progress("Äang chuáº©n bá»‹ táº£i...", 10)

            start_page = 0
            if self.resume_var.get():
                # History loader ensures skipped clips are tracked properly
                self.download_manager.get_history(self.selected_account)

            stats = self.download_manager.batch_download_paginated(
                account_name=self.selected_account,
                session_token=session_token,
                output_dir=output_path,
                profile_name=profile_name,
                use_create_page=use_my_songs,
                start_page=start_page,
                max_pages=None,
                max_clips=limit,
                with_thumbnail=self.thumbnail_var.get(),
                append_uuid=self.uuid_var.get(),
                progress_callback=self.update_progress,
                delay=2,
            )

            message = (
                f"âœ… ThÃ nh cÃ´ng: {stats.get('success', 0)}\n"
                f"âŒ Tháº¥t báº¡i: {stats.get('failed', 0)}\n"
                f"â­ï¸  ÄÃ£ bá» qua: {stats.get('skipped', 0)}\n"
                f"ðŸ“„ Tá»•ng sá»‘ trang: {stats.get('total_pages', 0)}\n"
                f"ðŸ“Š Tá»•ng Ä‘Ã£ táº£i: {stats.get('success', 0) + stats.get('skipped', 0)} bÃ i\n\n"
                f"ðŸ“ ThÆ° má»¥c: {output_path}"
            )
            messagebox.showinfo("HoÃ n thÃ nh!", message)

        except Exception as exc:
            logger.error(f"Download error: {exc}")
            messagebox.showerror("Lá»—i", f"Lá»—i khi táº£i:\n{exc}")

        finally:
            if driver:
                try:
                    driver.quit()
                    logger.info("Browser closed after download")
                except Exception:
                    pass

            self.downloading = False
            self.download_btn.configure(state="normal", text="Báº¯t Ä‘áº§u táº£i")
            self.progress_frame.grid_remove()
            self.update_progress("", 0)

    def _normalize_profile_input(self, text: str) -> str | None:
        """
        Normalize user input into @username form.
        Supports raw usernames, @user, and full Suno profile links.
        """
        if not text:
            return None

        cleaned = text.strip()
        if not cleaned:
            return None

        if cleaned.startswith("@"):
            return cleaned

        if cleaned.startswith("http"):
            parsed = urlparse(cleaned)
            path = (parsed.path or "").strip("/")
            if not path:
                return None

            if "@" in path:
                username = path[path.find("@") :]
                username = username.split("/")[0]
                if not username.startswith("@"):
                    username = f"@{username}"
                return username

            last_segment = path.split("/")[-1]
            if last_segment:
                return f"@{last_segment}"
            return None

        cleaned = cleaned.lstrip("@")
        return f"@{cleaned}" if cleaned else None

    def update_progress(self, message: str, progress: int):
        """Update progress UI"""
        self.progress_label.configure(text=message)
        self.progress_bar.set(progress / 100)
</file>

<file path="src/ui/history_panel.py">
"""
History Panel - Lá»‹ch sá»­ download
"""
import customtkinter as ctk
from tkinter import messagebox

from src.core import AccountManager, DownloadManager
from src.utils import format_datetime


class HistoryPanel(ctk.CTkFrame):
    """Panel lá»‹ch sá»­ download"""
    
    def __init__(self, parent, account_manager: AccountManager, download_manager: DownloadManager):
        super().__init__(parent)
        
        self.account_manager = account_manager
        self.download_manager = download_manager
        
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(1, weight=1)
        
        self.create_ui()
    
    def create_ui(self):
        """Create UI components"""
        
        # Header
        header_frame = ctk.CTkFrame(self)
        header_frame.grid(row=0, column=0, sticky="ew", pady=(0, 20))
        header_frame.grid_columnconfigure(0, weight=1)
        
        title = ctk.CTkLabel(
            header_frame,
            text="Lá»‹ch sá»­ Download",
            font=ctk.CTkFont(size=24, weight="bold")
        )
        title.grid(row=0, column=0, sticky="w", padx=20, pady=20)
        
        refresh_btn = ctk.CTkButton(
            header_frame,
            text="LÃ m má»›i",
            command=self.refresh,
            width=120
        )
        refresh_btn.grid(row=0, column=1, padx=20, pady=20)
        
        # History list
        list_frame = ctk.CTkFrame(self)
        list_frame.grid(row=1, column=0, sticky="nsew")
        list_frame.grid_columnconfigure(0, weight=1)
        list_frame.grid_rowconfigure(0, weight=1)
        
        self.scrollable = ctk.CTkScrollableFrame(list_frame)
        self.scrollable.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)
        self.scrollable.grid_columnconfigure(0, weight=1)
    
    def refresh(self):
        """Refresh history list"""
        
        # Clear current list
        for widget in self.scrollable.winfo_children():
            widget.destroy()
        
        # Load accounts and histories
        self.download_manager.load_histories()
        accounts = self.account_manager.get_all_accounts()
        
        if not accounts:
            no_data_label = ctk.CTkLabel(
                self.scrollable,
                text="ChÆ°a cÃ³ dá»¯ liá»‡u",
                font=ctk.CTkFont(size=16),
                text_color="gray"
            )
            no_data_label.grid(row=0, column=0, pady=100)
            return
        
        # Calculate total
        total_downloads = 0
        
        # Display histories
        for idx, account in enumerate(accounts):
            history = self.download_manager.get_history(account.name)
            total_downloads += history.total_downloaded
            self.create_history_card(account, history, idx)
        
        # Summary at top
        summary = ctk.CTkFrame(self.scrollable, corner_radius=10, fg_color="#1f538d")
        summary.grid(row=0, column=0, sticky="ew", pady=(0, 20), padx=5)
        
        summary_label = ctk.CTkLabel(
            summary,
            text=f"Tá»•ng cá»™ng: {total_downloads} bÃ i Ä‘Ã£ táº£i tá»« {len(accounts)} tÃ i khoáº£n",
            font=ctk.CTkFont(size=16, weight="bold")
        )
        summary_label.pack(pady=15, padx=20)
        
        # Move summary to top
        summary.tkraise()
    
    def create_history_card(self, account, history, row):
        """Create history card for account"""
        
        card = ctk.CTkFrame(self.scrollable, corner_radius=10)
        card.grid(row=row+1, column=0, sticky="ew", pady=5, padx=5)
        card.grid_columnconfigure(1, weight=1)
        
        # Account info
        name_label = ctk.CTkLabel(
            card,
            text=f"ðŸ“§ {account.name}",
            font=ctk.CTkFont(size=16, weight="bold")
        )
        name_label.grid(row=0, column=0, sticky="w", padx=20, pady=(15, 5))
        
        email_label = ctk.CTkLabel(
            card,
            text=f"Email: {account.email}",
            text_color="gray"
        )
        email_label.grid(row=1, column=0, sticky="w", padx=20, pady=2)
        
        # Download stats
        stats_frame = ctk.CTkFrame(card, fg_color="transparent")
        stats_frame.grid(row=2, column=0, sticky="w", padx=20, pady=5)
        
        downloaded_label = ctk.CTkLabel(
            stats_frame,
            text=f"ÄÃ£ táº£i: {history.total_downloaded} bÃ i",
            font=ctk.CTkFont(weight="bold")
        )
        downloaded_label.grid(row=0, column=0, sticky="w", pady=2)
        
        if history.last_download:
            last_label = ctk.CTkLabel(
                stats_frame,
                text=f"ðŸ• Láº§n cuá»‘i: {format_datetime(history.last_download)}",
                text_color="gray"
            )
            last_label.grid(row=1, column=0, sticky="w", pady=2)
        
        # Clear button
        clear_btn = ctk.CTkButton(
            card,
            text="XÃ³a lá»‹ch sá»­",
            command=lambda: self.clear_history(account.name),
            width=120,
            fg_color="red",
            hover_color="darkred"
        )
        clear_btn.grid(row=0, column=1, rowspan=3, padx=20, pady=10)
        
        # Spacing
        ctk.CTkLabel(card, text="").grid(row=3, column=0, pady=(0, 10))
    
    def clear_history(self, account_name: str):
        """Clear history for account"""
        
        if not messagebox.askyesno(
            "XÃ¡c nháº­n",
            f"XÃ³a lá»‹ch sá»­ download cá»§a '{account_name}'?\n\n"
            "CÃ¡c bÃ i Ä‘Ã£ táº£i sáº½ cÃ³ thá»ƒ táº£i láº¡i."
        ):
            return
        
        if self.download_manager.clear_history(account_name):
            messagebox.showinfo("ThÃ nh cÃ´ng", f"ÄÃ£ xÃ³a lá»‹ch sá»­ cá»§a {account_name}")
            self.refresh()
        else:
            messagebox.showerror("Lá»—i", "KhÃ´ng thá»ƒ xÃ³a lá»‹ch sá»­!")
</file>

<file path="src/ui/main_window.py">
"""
Main Application Window
"""
import customtkinter as ctk
from typing import Optional

from config.settings import APP_NAME, APP_VERSION, APP_WIDTH, APP_HEIGHT, THEME, APPEARANCE_MODE
from src.core import (
    AccountManager,
    QueueManager,
    SessionManager,
    DownloadManager,
    SongCreationHistoryManager
)
from src.ui.account_panel import AccountPanel
from src.ui.download_panel import DownloadPanel
from src.ui.history_panel import HistoryPanel
from src.ui.create_music_panel import CreateMusicPanel
from src.ui.multiple_songs_panel import MultipleSongsPanel
from src.ui.song_creation_history_panel import SongCreationHistoryPanel
from src.utils import logger


class MainWindow(ctk.CTk):
    """Main application window"""
    
    def __init__(self):
        super().__init__()
        
        # Set theme
        ctk.set_appearance_mode(APPEARANCE_MODE)
        ctk.set_default_color_theme(THEME)
        
        # Window configuration
        self.title(f"{APP_NAME} v{APP_VERSION}")
        self.window_width = APP_WIDTH
        self.window_height = 750
        self.geometry(f"{self.window_width}x{self.window_height}")
        self.minsize(APP_WIDTH, self.window_height)  # Minimum size
        
        # Center window
        self.center_window()
        
        # Initialize managers
        self.account_manager = AccountManager()
        self.session_manager = SessionManager()
        self.download_manager = DownloadManager()
        self.queue_manager = QueueManager()
        self.song_creation_history_manager = SongCreationHistoryManager()
        
        # Create UI
        self.create_ui()
        
        logger.info("Application started")
    
    def center_window(self):
        """Center window on screen"""
        self.update_idletasks()
        x = (self.winfo_screenwidth() // 2) - (self.window_width // 2)
        y = (self.winfo_screenheight() // 2) - (self.window_height // 2)
        self.geometry(f'{self.window_width}x{self.window_height}+{x}+{y}')
    
    def create_ui(self):
        """Create main UI"""

        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(0, weight=0)
        self.grid_rowconfigure(1, weight=1)

        self.create_tabbar()
        self.content_frame = ctk.CTkFrame(self, fg_color="transparent")
        self.content_frame.grid(row=1, column=0, sticky="nsew")
        self.content_frame.grid_columnconfigure(0, weight=1)
        self.content_frame.grid_rowconfigure(0, weight=1)
        self.panels = {}
        self.active_tab = "accounts"
        self.create_panels()
        self.tab_buttons.set(self.key_to_label[self.active_tab])
        self._show_current_tab()
    
    def create_tabbar(self):
        self.tab_map = [
            ("accounts", "TÃ i khoáº£n"),
            ("create_music", "Táº¡o nháº¡c"),
            ("multiple_songs", "Táº¡o nhiá»u bÃ i"),
            ("download", "Download"),
            ("history", "Lá»‹ch sá»­ Download"),
            ("song_creation_history", "Lá»‹ch sá»­ Táº¡o bÃ i hÃ¡t"),
        ]
        self.key_to_label = {key: label for key, label in self.tab_map}
        self.label_to_key = {label: key for key, label in self.tab_map}
        labels = [label for _, label in self.tab_map]

        self.tab_buttons = ctk.CTkSegmentedButton(
            self,
            values=labels,
            command=self._on_tab_click,
            font=ctk.CTkFont(size=14, weight="bold")
        )
        self.tab_buttons.grid(row=0, column=0, sticky="ew", padx=20, pady=(10, 5))

    def create_panels(self):
        """Create all content panels"""

        self.panels["accounts"] = AccountPanel(
            self.content_frame,
            self.account_manager,
            self.session_manager
        )

        self.panels["create_music"] = CreateMusicPanel(
            self.content_frame,
            self.account_manager,
            self.session_manager
        )

        self.panels["multiple_songs"] = MultipleSongsPanel(
            self.content_frame,
            self.account_manager,
            self.queue_manager,
            self.session_manager,
            self.song_creation_history_manager
        )

        self.panels["download"] = DownloadPanel(
            self.content_frame,
            self.account_manager,
            self.session_manager,
            self.download_manager
        )

        self.panels["history"] = HistoryPanel(
            self.content_frame,
            self.account_manager,
            self.download_manager
        )
        self.panels["song_creation_history"] = SongCreationHistoryPanel(
            self.content_frame,
            self.account_manager,
            self.song_creation_history_manager
        )

    def _show_current_tab(self):
        for panel in self.panels.values():
            panel.grid_remove()
        current = self.active_tab
        if current in self.panels:
            self.panels[current].grid(row=0, column=0, sticky="nsew", padx=20, pady=(0, 20))
            self.panels[current].refresh()

    def _on_tab_click(self, label: str):
        key = self.label_to_key.get(label)
        if not key or key == self.active_tab:
            return
        self.active_tab = key
        self._show_current_tab()
    
    def change_appearance_mode(self, mode: str):
        """Change appearance mode"""
        ctk.set_appearance_mode(mode.lower())
        logger.info(f"Appearance mode changed to: {mode}")


def run_app():
    """Run the application"""
    app = MainWindow()
    app.mainloop()


if __name__ == "__main__":
    run_app()
</file>

<file path="src/ui/multiple_songs_panel.py">
"""
Multiple Songs Panel - UI táº¡o nhiá»u bÃ i hÃ¡t (refactored)

ÄÃƒ TÃCH toÃ n bá»™ Selenium & batching logic sang core: `BatchSongCreator`.
UI chá»‰ cÃ²n nhiá»‡m vá»¥:
 - Thu tháº­p input
 - Gá»i BatchSongCreator vá»›i callback progress
 - Hiá»ƒn thá»‹ káº¿t quáº£

Æ¯u Ä‘iá»ƒm:
 - Dá»… test Ä‘Æ¡n vá»‹ cho `BatchSongCreator`
 - UI má»ng, trÃ¡nh thao tÃ¡c trá»±c tiáº¿p WebDriver
 - CÃ³ thá»ƒ thay Ä‘á»•i engine (Selenium â†’ API) mÃ  khÃ´ng sá»­a UI
"""
import customtkinter as ctk
import threading
import math
from collections import defaultdict
from datetime import datetime
from typing import List, Dict, Any, Set, Optional

from src.core import AccountManager, QueueManager, SongCreationHistoryManager
from src.core.batch_song_creator import BatchSongCreator
from src.core.queue_manager import QueueValidationError
from src.core.session_manager import SessionManager
from src.core.suno_api_client import SunoApiClient
from src.utils.prompt_parser import SunoPromptParser, SunoPrompt
from config.settings import PROFILES_DIR
from src.utils import logger
from src.models import QueueEntry


class MultipleSongsPanel(ctk.CTkFrame):
    """Panel táº¡o nhiá»u bÃ i hÃ¡t tá»« file XML sá»­ dá»¥ng core BatchSongCreator"""

    STATUS_ICONS = {
        "waiting": "â³",
        "pending": "â³",
        "success": "âœ…",
        "failed": "âŒ"
    }

    def __init__(
        self,
        parent,
        account_manager: AccountManager,
        queue_manager: QueueManager,
        session_manager: SessionManager,
        history_manager: SongCreationHistoryManager
    ):
        super().__init__(parent)
        self.account_manager = account_manager
        self.queue_manager = queue_manager
        self.session_manager = session_manager
        self.history_manager = history_manager
        self.prompts: List[SunoPrompt] = []
        self.results: List[Dict[str, Any]] = []
        self.creator: BatchSongCreator | None = None
        self.queue_checkvars: Dict[str, ctk.BooleanVar] = {}
        self.queue_selection_state: Dict[str, bool] = {}
        self.selected_queue_ids: Set[str] = set()
        self.pending_songs: List[Dict[str, Any]] = []
        self.matched_song_ids: Set[str] = set()
        self.preview_entries: List[Dict[str, Any]] = []
        self._stop_requested = False
        self._build_ui()

    # ================== UI BUILD ==================
    def _build_ui(self):
        # 2-column layout: Settings (left) | Results (right)
        self.grid_columnconfigure(0, weight=1)  # Left: settings
        self.grid_columnconfigure(1, weight=2)  # Right: results (wider)
        self.grid_rowconfigure(0, weight=0)     # Title row
        self.grid_rowconfigure(1, weight=1)     # Content row

        title_label = ctk.CTkLabel(
            self,
            text="Táº¡o Nhiá»u BÃ i HÃ¡t CÃ¹ng LÃºc",
            font=("Arial", 24, "bold")
        )
        title_label.grid(row=0, column=0, columnspan=2, pady=20)

        # LEFT COLUMN: Settings
        left_container = ctk.CTkScrollableFrame(self, width=450)
        left_container.grid(row=1, column=0, padx=(10, 5), pady=10, sticky="nsew")

        input_frame = ctk.CTkFrame(left_container)
        input_frame.pack(fill="x", padx=10, pady=10)

        ctk.CTkLabel(input_frame, text="Account:", font=("Arial", 14, "bold")).grid(
            row=0, column=0, padx=10, pady=10, sticky="w"
        )
        self.account_var = ctk.StringVar()
        self.account_dropdown = ctk.CTkComboBox(
            input_frame,
            variable=self.account_var,
            values=self._get_account_list(),
            width=300
        )
        self.account_dropdown.grid(row=0, column=1, padx=10, pady=10, sticky="w")

        ctk.CTkLabel(input_frame, text="XML File:", font=("Arial", 14, "bold")).grid(
            row=1, column=0, padx=10, pady=10, sticky="w"
        )
        file_frame = ctk.CTkFrame(input_frame)
        file_frame.grid(row=1, column=1, padx=10, pady=10, sticky="w")
        self.file_path_var = ctk.StringVar(value="src/prompt/multiple-suno-prompt.xml")
        self.file_entry = ctk.CTkEntry(file_frame, textvariable=self.file_path_var, width=250)
        self.file_entry.pack(side="left", padx=5)
        self.browse_button = ctk.CTkButton(file_frame, text="ðŸ“", command=self._browse_file, width=40)
        self.browse_button.pack(side="left", padx=2)
        self.parse_button = ctk.CTkButton(file_frame, text="Parse", command=self._parse_xml, width=70)
        self.parse_button.pack(side="left", padx=2)
        self.clear_prompts_button = ctk.CTkButton(file_frame, text="Clear", width=60, command=self._clear_parsed_data)
        self.clear_prompts_button.pack(side="left", padx=2)

        # Advanced options toggle
        advanced_header = ctk.CTkFrame(left_container)
        advanced_header.pack(fill="x", padx=10, pady=(5, 0))
        self.use_advanced_var = ctk.BooleanVar(value=False)
        ctk.CTkCheckBox(
            advanced_header,
            text="Sá»­ dá»¥ng Advanced Options",
            variable=self.use_advanced_var,
            command=self._toggle_advanced
        ).pack(side="left", padx=10, pady=5)

        # Advanced container
        self.advanced_container = ctk.CTkFrame(left_container)
        self.advanced_container.pack(fill="x", padx=10, pady=5)
        self._build_advanced_options()
        self._toggle_advanced()

        # Queue controls
        queue_section = ctk.CTkFrame(left_container)
        queue_section.pack(fill="x", padx=10, pady=(10, 5))
        ctk.CTkLabel(
            queue_section,
            text="HÃ ng chá» táº¡o bÃ i hÃ¡t",
            font=("Arial", 16, "bold")
        ).pack(anchor="w", padx=5, pady=(0, 5))

        queue_input_frame = ctk.CTkFrame(queue_section)
        queue_input_frame.pack(fill="x", padx=5, pady=(0, 5))

        ctk.CTkLabel(queue_input_frame, text="Tá»•ng sá»‘ bÃ i:", font=("Arial", 13)).grid(
            row=0, column=0, padx=5, pady=5, sticky="w"
        )
        self.total_songs_entry = ctk.CTkEntry(queue_input_frame, width=100)
        self.total_songs_entry.grid(row=0, column=1, padx=5, pady=5, sticky="w")

        self.add_queue_button = ctk.CTkButton(
            queue_input_frame,
            text="ThÃªm vÃ o hÃ ng chá»",
            command=self._on_add_queue_click
        )
        self.add_queue_button.grid(row=2, column=0, columnspan=2, padx=5, pady=(5, 10))

        self.queue_status_label = ctk.CTkLabel(
            queue_section,
            text="ChÆ°a cÃ³ hÃ ng chá» nÃ o",
            font=("Arial", 12),
            text_color="gray"
        )
        self.queue_status_label.pack(anchor="w", padx=5, pady=(0, 5))

        self.queue_list_container = ctk.CTkScrollableFrame(
            queue_section,
            height=180
        )
        self.queue_list_container.pack(fill="both", padx=5, pady=(0, 5))
        self._render_queue_list()

        self.status_log = ctk.CTkTextbox(
            queue_section,
            height=120,
            state="disabled"
        )
        self.status_log.pack(fill="both", padx=5, pady=(5, 0))

        self.refresh_status_button = ctk.CTkButton(
            queue_section,
            text="Cáº­p nháº­t tráº¡ng thÃ¡i",
            command=self._refresh_pending_status
        )
        self.refresh_status_button.pack(fill="x", padx=5, pady=(5, 10))

        # Buttons (at bottom of left column)
        button_frame = ctk.CTkFrame(left_container)
        button_frame.pack(fill="x", padx=10, pady=15)
        self.start_button = ctk.CTkButton(
            button_frame,
            text="Báº¯t Äáº§u",
            command=self._on_start_click,
            width=200,
            height=45,
            font=("Arial", 16, "bold"),
            fg_color="green",
            state="disabled"
        )
        self.start_button.pack(side="left", padx=5)
        self.stop_button = ctk.CTkButton(
            button_frame,
            text="Dá»«ng",
            command=self._on_stop_click,
            width=100,
            height=45,
            font=("Arial", 14),
            fg_color="red",
            state="disabled"
        )
        self.stop_button.pack(side="left", padx=5)

        # RIGHT COLUMN: Results
        right_container = ctk.CTkFrame(self)
        right_container.grid(row=1, column=1, padx=(5, 10), pady=10, sticky="nsew")
        right_container.grid_rowconfigure(1, weight=1)  # Preview area
        right_container.grid_rowconfigure(3, weight=1)  # Result area
        right_container.grid_columnconfigure(0, weight=1)

        # Preview section
        ctk.CTkLabel(
            right_container, 
            text="Danh SÃ¡ch BÃ i HÃ¡t", 
            font=("Arial", 16, "bold")
        ).grid(row=0, column=0, padx=10, pady=(10, 5), sticky="w")
        
        self.preview_text = ctk.CTkTextbox(right_container, height=250)
        self.preview_text.grid(row=1, column=0, padx=10, pady=5, sticky="nsew")
        self.preview_text.insert("1.0", "ChÆ°a parse file nÃ o. Click 'Parse' Ä‘á»ƒ báº¯t Ä‘áº§u.")

        # Progress section
        progress_frame = ctk.CTkFrame(right_container)
        progress_frame.grid(row=2, column=0, padx=10, pady=10, sticky="ew")
        
        self.progress_label = ctk.CTkLabel(
            progress_frame, 
            text="Sáºµn sÃ ng táº¡o bÃ i hÃ¡t", 
            font=("Arial", 12)
        )
        self.progress_label.pack(pady=(5, 2))
        
        self.progress_bar = ctk.CTkProgressBar(progress_frame)
        self.progress_bar.pack(fill="x", padx=10, pady=(2, 5))
        self.progress_bar.set(0)

        # Results section
        ctk.CTkLabel(
            right_container, 
            text="Káº¿t Quáº£", 
            font=("Arial", 16, "bold")
        ).grid(row=3, column=0, padx=10, pady=(10, 5), sticky="nw")
        
        self.result_text = ctk.CTkTextbox(right_container, height=200)
        self.result_text.grid(row=4, column=0, padx=10, pady=5, sticky="nsew")
        right_container.grid_rowconfigure(4, weight=1)  # Make results expandable

    def _build_advanced_options(self):
        """Táº¡o cÃ¡c control cho Advanced Options"""
        self.advanced_container.grid_columnconfigure(1, weight=1)
        # Exclude Styles
        ctk.CTkLabel(self.advanced_container, text="Exclude Styles:").grid(row=0, column=0, padx=10, pady=5, sticky="w")
        self.exclude_styles_var = ctk.StringVar()
        ctk.CTkEntry(self.advanced_container, textvariable=self.exclude_styles_var, width=300, placeholder_text="rock, metal...").grid(row=0, column=1, padx=10, pady=5, sticky="w")
        # Vocal Gender
        ctk.CTkLabel(self.advanced_container, text="Vocal Gender:").grid(row=1, column=0, padx=10, pady=5, sticky="w")
        self.vocal_gender_var = ctk.StringVar(value="")
        gender_frame = ctk.CTkFrame(self.advanced_container)
        gender_frame.grid(row=1, column=1, padx=10, pady=5, sticky="w")
        for v in ["Male", "Female", ""]:
            ctk.CTkRadioButton(gender_frame, text=v or "None", variable=self.vocal_gender_var, value=v).pack(side="left", padx=5)
        # Lyrics Mode
        ctk.CTkLabel(self.advanced_container, text="Lyrics Mode:").grid(row=2, column=0, padx=10, pady=5, sticky="w")
        self.lyrics_mode_var = ctk.StringVar(value="")
        lyrics_frame = ctk.CTkFrame(self.advanced_container)
        lyrics_frame.grid(row=2, column=1, padx=10, pady=5, sticky="w")
        for v in ["Manual", "Auto", ""]:
            ctk.CTkRadioButton(lyrics_frame, text=v or "None", variable=self.lyrics_mode_var, value=v).pack(side="left", padx=5)
        # Weirdness
        ctk.CTkLabel(self.advanced_container, text="Weirdness:").grid(row=3, column=0, padx=10, pady=5, sticky="w")
        self.weirdness_var = ctk.IntVar(value=50)
        weird_frame = ctk.CTkFrame(self.advanced_container)
        weird_frame.grid(row=3, column=1, padx=10, pady=5, sticky="w")
        self.weirdness_slider = ctk.CTkSlider(weird_frame, from_=0, to=100, variable=self.weirdness_var, width=250, command=lambda v: self.weirdness_label.configure(text=f"{int(float(v))}%"))
        self.weirdness_slider.pack(side="left")
        self.weirdness_label = ctk.CTkLabel(weird_frame, text="50%")
        self.weirdness_label.pack(side="left", padx=5)
        # Style Influence
        ctk.CTkLabel(self.advanced_container, text="Style Influence:").grid(row=4, column=0, padx=10, pady=5, sticky="w")
        self.style_influence_var = ctk.IntVar(value=50)
        style_frame = ctk.CTkFrame(self.advanced_container)
        style_frame.grid(row=4, column=1, padx=10, pady=5, sticky="w")
        self.style_influence_slider = ctk.CTkSlider(style_frame, from_=0, to=100, variable=self.style_influence_var, width=250, command=lambda v: self.style_influence_label.configure(text=f"{int(float(v))}%"))
        self.style_influence_slider.pack(side="left")
        self.style_influence_label = ctk.CTkLabel(style_frame, text="50%")
        self.style_influence_label.pack(side="left", padx=5)
        # Persona
        ctk.CTkLabel(self.advanced_container, text="Persona:").grid(row=5, column=0, padx=10, pady=5, sticky="w")
        self.persona_name_var = ctk.StringVar()
        ctk.CTkEntry(self.advanced_container, textvariable=self.persona_name_var, width=300, placeholder_text="TÃªn persona...").grid(row=5, column=1, padx=10, pady=5, sticky="w")

    def _toggle_advanced(self):
        state = "normal" if self.use_advanced_var.get() else "disabled"
        for w in self.advanced_container.winfo_children():
            try:
                w.configure(state=state)
            except Exception:
                pass

    # ================== HELPERS ==================
    def _get_account_list(self):
        accounts = self.account_manager.get_all_accounts()
        if not accounts:
            return ["ChÆ°a cÃ³ account nÃ o"]
        return [acc.name for acc in accounts]

    def _set_result_message(self, message: str) -> None:
        """Show a brief message in the results box."""
        self.result_text.delete("1.0", "end")
        self.result_text.insert("1.0", message)

    def _on_add_queue_click(self):
        account_name = self.account_var.get()
        if not account_name or account_name == "ChÆ°a cÃ³ account nÃ o":
            self._set_result_message("âŒ Vui lÃ²ng chá»n account trÆ°á»›c khi thÃªm hÃ ng chá»")
            return
        if not self.prompts:
            self._set_result_message("âŒ ChÆ°a parse prompts! Click 'Parse' trÆ°á»›c.")
            return

        total_value = self.total_songs_entry.get().strip()
        try:
            total_songs = int(total_value)
        except ValueError:
            self._set_result_message("âŒ Tá»•ng sá»‘ bÃ i pháº£i lÃ  sá»‘ nguyÃªn")
            return
        if total_songs <= 0:
            self._set_result_message("âŒ Tá»•ng sá»‘ bÃ i pháº£i lá»›n hÆ¡n 0")
            return

        per_batch = self._default_songs_per_session(total_songs)

        try:
            entry = self.queue_manager.add_queue_entry(
                account_name,
                total_songs,
                per_batch,
                self.prompts
            )
        except QueueValidationError as exc:
            self._set_result_message(f"âŒ {exc}")
            return

        self.queue_selection_state[entry.id] = False
        self.queue_checkvars.pop(entry.id, None)
        self.selected_queue_ids.discard(entry.id)
        self._render_queue_list()
        self._set_result_message(
            f"âœ… ÄÃ£ thÃªm {entry.total_songs} bÃ i cho account {entry.account_name}"
        )

    def _render_queue_list(self):
        for child in self.queue_list_container.winfo_children():
            child.destroy()

        entries = self.queue_manager.get_all_queues()
        if not entries:
            placeholder = ctk.CTkLabel(
                self.queue_list_container,
                text="HÃ ng chá» trá»‘ng. ThÃªm queue lÃªn Ä‘á»ƒ báº¯t Ä‘áº§u.",
                font=("Arial", 12),
                text_color="gray"
            )
            placeholder.pack(padx=10, pady=30)
            self.selected_queue_ids.clear()
            self.queue_checkvars.clear()
        else:
            valid_ids = set()
            for entry in entries:
                valid_ids.add(entry.id)
                row = ctk.CTkFrame(self.queue_list_container)
                row.pack(fill="x", padx=5, pady=3)

                var = ctk.BooleanVar(value=self.queue_selection_state.get(entry.id, False))
                self.queue_checkvars[entry.id] = var
                checkbox = ctk.CTkCheckBox(
                    row,
                    text=self._format_queue_label(entry),
                    variable=var,
                    command=lambda qid=entry.id: self._on_queue_checkbox_changed(qid)
                )
                checkbox.pack(side="left", padx=5, pady=5, anchor="w")

                delete_btn = ctk.CTkButton(
                    row,
                    text="XÃ³a",
                    width=50,
                    command=lambda qid=entry.id: self._on_queue_remove(qid),
                    fg_color="transparent",
                    hover_color="#444"
                )
                delete_btn.pack(side="right", padx=5)

                status_text = f"{entry.status.title()} Â· {entry.completed_count}/{entry.total_songs}"
                status_label = ctk.CTkLabel(
                    row,
                    text=status_text,
                    font=("Arial", 12),
                    text_color="gray"
                )
                status_label.pack(side="right", padx=5)

                if var.get():
                    self.selected_queue_ids.add(entry.id)

            self.selected_queue_ids &= valid_ids

        self._update_queue_status_text()
        self._refresh_start_button_state()

    def _on_queue_checkbox_changed(self, queue_id: str):
        var = self.queue_checkvars.get(queue_id)
        if var is None:
            return
        selected = var.get()
        self.queue_selection_state[queue_id] = selected
        if selected:
            self.selected_queue_ids.add(queue_id)
        else:
            self.selected_queue_ids.discard(queue_id)
        self._refresh_start_button_state()

    def _refresh_start_button_state(self):
        if not hasattr(self, "start_button"):
            return
        state = "normal" if self.selected_queue_ids else "disabled"
        self.start_button.configure(state=state)

    def _refresh_pending_status(self):
        if not self.pending_songs:
            self._set_result_message("KhÃ´ng cÃ³ bÃ i nÃ o Ä‘ang chá» ID.")
            return

        grouped = defaultdict(list)
        for pending in self.pending_songs:
            grouped[pending["account_name"]].append(pending)

        updated = 0
        for account_name, items in grouped.items():
            token = self.session_manager.get_session_token(account_name)
            if not token:
                logger.warning(f"KhÃ´ng láº¥y Ä‘Æ°á»£c session token cho {account_name}")
                continue
            client = SunoApiClient(session_token=token)
            clips = client.fetch_my_clips()
            if not clips:
                continue
            for pending_entry in items:
                clip = self._find_clip_for_pending(pending_entry, clips)
                if clip:
                    updated += 1
                    pending_entry["completed"] = True
                    song_id = clip.get("id")
                    self._mark_pending_complete(pending_entry, song_id)

        self.pending_songs = [p for p in self.pending_songs if not p.get("completed")]

        if updated:
            self._set_result_message(f"âœ… ÄÃ£ cáº­p nháº­t {updated} bÃ i chá» ID")
        else:
            self._set_result_message("â³ ChÆ°a tÃ¬m tháº¥y ID má»›i, thá»­ láº¡i sau")

    def _find_clip_for_pending(self, pending_entry: Dict[str, Any], clips: List[Dict[str, Any]]) -> Optional[Dict[str, Any]]:
        title = pending_entry["title"]
        for clip in clips:
            clip_id = clip.get("id")
            clip_title = clip.get("title")
            if not clip_id or clip_id in self.matched_song_ids:
                continue
            if clip_title and clip_title.strip().lower() == title.strip().lower():
                return clip
        return None

    def _mark_pending_complete(self, pending_entry: Dict[str, Any], song_id: str | None):
        title = pending_entry["title"]
        icon = self.STATUS_ICONS["success"]
        msg = f"{icon} Cáº­p nháº­t: {title}"
        if song_id:
            msg += f" â†’ {song_id}"
            self.matched_song_ids.add(song_id)
        self.status_log.configure(state="normal")
        self.status_log.insert("1.0", msg + "\n")
        self.status_log.configure(state="disabled")
        self._update_preview_entry(title, "success", song_id)

    def _calculate_session_count(self, total_prompts: int) -> int:
        if total_prompts > 30:
            return 4
        if total_prompts > 20:
            return 3
        if total_prompts > 10:
            return 2
        return 1

    def _default_songs_per_session(self, total_songs: int) -> int:
        sessions = self._calculate_session_count(total_songs)
        return math.ceil(total_songs / sessions)

    @staticmethod
    def _format_queue_label(entry: QueueEntry) -> str:
        start, end = entry.prompts_range
        return (
            f"{entry.account_name}: {entry.total_songs} bÃ i "
            f"(~{entry.songs_per_batch}/láº§n) Â· Prompt {start + 1}-{end}"
        )

    def _update_queue_status_text(self):
        total = len(self.prompts)
        if total == 0:
            text = "ChÆ°a parse prompt nÃ o"
        else:
            if self.queue_manager.prompts:
                available = self.queue_manager.available_prompt_slots
            else:
                available = total
            text = f"Parsed {total} prompts Â· {available} cÃ²n láº¡i trong hÃ ng chá»"
        self.queue_status_label.configure(text=text)

    def _browse_file(self):
        from tkinter import filedialog
        filename = filedialog.askopenfilename(
            title="Chá»n XML file",
            filetypes=[("XML files", "*.xml"), ("All files", "*.*")]
        )
        if filename:
            self.file_path_var.set(filename)
            self._parse_xml()

    def _parse_xml(self):
        file_path = self.file_path_var.get()
        if not file_path:
            self.preview_text.delete("1.0", "end")
            self.preview_text.insert("1.0", "âŒ ChÆ°a chá»n file!")
            return
        self.prompts = SunoPromptParser.parse_all_from_file(file_path)
        self.pending_songs.clear()
        self.matched_song_ids.clear()
        self.preview_entries = []
        self.preview_text.configure(state="normal")
        self.preview_text.delete("1.0", "end")
        if not self.prompts:
            self.preview_text.insert("1.0", "âŒ KhÃ´ng parse Ä‘Æ°á»£c prompt nÃ o tá»« file!")
            self.preview_text.configure(state="disabled")
            return

        self.preview_entries = [
            {"title": prompt.title, "status": "waiting", "text": f"â³ {prompt.title}"}
            for prompt in self.prompts
        ]
        self._refresh_preview_text()
        logger.info(f"Parsed {len(self.prompts)} prompts from {file_path}")
        self._update_queue_status_text()

    def _clear_parsed_data(self):
        self.prompts = []
        self.preview_entries = []
        self.pending_songs.clear()
        self.matched_song_ids.clear()
        self.queue_manager.clear()
        self._render_queue_list()
        self.selected_queue_ids.clear()
        self.queue_selection_state.clear()
        self.status_log.configure(state="normal")
        self.status_log.delete("1.0", "end")
        self.status_log.configure(state="disabled")
        self.preview_text.configure(state="normal")
        self.preview_text.delete("1.0", "end")
        self.preview_text.insert("1.0", "ÄÃ£ xÃ³a danh sÃ¡ch prompt. Parse láº¡i file Ä‘á»ƒ tiáº¿p tá»¥c.")
        self.preview_text.configure(state="disabled")
        self.result_text.delete("1.0", "end")
        self._update_queue_status_text()
        self._set_result_message("ÄÃ£ xÃ³a log & danh sÃ¡ch prompt")

    # ================== ACTIONS ==================
    def _on_start_click(self):
        if not self.selected_queue_ids:
            self._set_result_message("âŒ ChÆ°a chá»n hÃ ng chá» nÃ o Ä‘á»ƒ báº¯t Ä‘áº§u")
            return
        if not self.prompts:
            self._set_result_message("âŒ ChÆ°a parse prompts! Click 'Parse' trÆ°á»›c.")
            return

        self._stop_requested = False
        self.start_button.configure(state="disabled")
        self.stop_button.configure(state="normal")
        self.result_text.delete("1.0", "end")
        thread = threading.Thread(target=self._run_queue_thread, daemon=True)
        thread.start()

    def _on_stop_click(self):
        self._stop_requested = True
        if self.creator:
            self.creator.stop()
        self.stop_button.configure(state="disabled")
        self._set_progress("âŒ ÄÃ£ dá»«ng", 0)
        self._refresh_start_button_state()

    def _run_queue_thread(self):
        aggregated_results: List[Dict[str, Any]] = []
        advanced = self._collect_advanced_options()
        auto_submit = True
        queue_ids = list(self.selected_queue_ids)

        for queue_id in queue_ids:
            if self._stop_requested:
                break

            entry = self.queue_manager.get_queue(queue_id)
            if not entry:
                continue

            start, end = entry.prompts_range
            queue_prompts = self.queue_manager.prompts[start:end]
            if not queue_prompts:
                self._set_result_message(f"âŒ Queue {entry.account_name} khÃ´ng cÃ³ prompt nÃ o")
                self.queue_manager.update_queue_progress(queue_id, status="failed")
                continue

            profile_path = PROFILES_DIR / entry.account_name
            if not profile_path.exists():
                self._set_result_message(f"âŒ Profile khÃ´ng tá»“n táº¡i: {profile_path}")
                self.queue_manager.update_queue_progress(queue_id, status="failed")
                continue

            self.queue_manager.update_queue_progress(queue_id, status="in_progress")
            self._render_queue_list()
            self._set_progress(
                f"Queue {entry.account_name}: {entry.total_songs} bÃ i",
                0
            )

            self.creator = BatchSongCreator(profile_path=profile_path)
            session_count = self._calculate_session_count(len(queue_prompts))
            songs_per_session = math.ceil(len(queue_prompts) / session_count)
            def progress_adapter(msg, prog, song_id, status_label, prompt_title):
                self._handle_prompt_progress(
                    queue_id=queue_id,
                    account_name=entry.account_name,
                    prompt_title=prompt_title,
                    message=msg,
                    progress=prog,
                    song_id=song_id,
                    status=status_label
                )
            try:
                batch_results = self.creator.create_songs_batch(
                    prompts=queue_prompts,
                    songs_per_session=songs_per_session,
                    advanced_options=advanced,
                    auto_submit=auto_submit,
                    progress_callback=progress_adapter,
                    account_name=entry.account_name,
                    history_manager=self.history_manager
                )
            except Exception as exc:
                logger.error(f"Queue run error: {exc}")
                batch_results = [{'title': 'ERROR', 'success': False, 'error': str(exc)}]

            aggregated_results.extend(batch_results)
            successful = sum(1 for r in batch_results if r.get('success'))
            status = "completed" if successful >= entry.total_songs else "failed"
            self.queue_manager.update_queue_progress(
                queue_id,
                completed_count=successful,
                status=status
            )
            self.queue_selection_state[queue_id] = False
            self.selected_queue_ids.discard(queue_id)
            self._render_queue_list()

        if aggregated_results:
            self._show_results(aggregated_results)
        elif not self._stop_requested:
            self._set_result_message("âŒ KhÃ´ng cÃ³ káº¿t quáº£ nÃ o Ä‘Æ°á»£c táº¡o ra")

        self.start_button.configure(state="normal")
        self.stop_button.configure(state="disabled")
        self._stop_requested = False
        self._refresh_start_button_state()

    def _on_queue_remove(self, queue_id: str) -> None:
        removed = self.queue_manager.remove_queue_entry(queue_id)
        self.queue_selection_state.pop(queue_id, None)
        self.selected_queue_ids.discard(queue_id)
        if removed:
            self._set_result_message("ÄÃ£ xÃ³a queue")
        self.pending_songs = [p for p in self.pending_songs if p["queue_id"] != queue_id]
        self.after(10, self._render_queue_list)
    # ================== ADVANCED OPTIONS ==================
    def _collect_advanced_options(self) -> Dict[str, Any]:
        return {
            'enabled': self.use_advanced_var.get(),
            'exclude_styles': self.exclude_styles_var.get().strip(),
            'vocal_gender': self.vocal_gender_var.get() or None,
            'lyrics_mode': self.lyrics_mode_var.get() or None,
            'weirdness': self.weirdness_var.get(),
            'style_influence': self.style_influence_var.get(),
            'persona_name': self.persona_name_var.get().strip() or None
        }

    # ================== UI CALLBACKS ==================
    def _set_progress(self, message: str, progress: int = 0):
        self.progress_label.configure(text=message)
        self.progress_bar.set(progress / 100 if progress <= 100 else 1)

    def _handle_prompt_progress(
        self,
        queue_id: str,
        account_name: str,
        prompt_title: str,
        message: str,
        progress: int,
        song_id: str | None,
        status: str
    ):
        self._set_progress(message, progress)
        self._update_song_status(queue_id, account_name, prompt_title, message, song_id, status)

    def _refresh_preview_text(self):
        self.preview_text.configure(state="normal")
        self.preview_text.delete("1.0", "end")
        if not self.preview_entries:
            self.preview_text.insert("1.0", "ChÆ°a parse file nÃ o. Click 'Parse' Ä‘á»ƒ báº¯t Ä‘áº§u.")
        else:
            lines = [entry["text"] for entry in self.preview_entries]
            self.preview_text.insert("1.0", "\n".join(lines))
        self.preview_text.configure(state="disabled")

    def _update_song_status(
        self,
        queue_id: str,
        account_name: str,
        prompt_title: str,
        message: str,
        song_id: str | None,
        status: str
    ):
        icon = self.STATUS_ICONS.get(status, "âŒ")
        line = f"{icon} {message}"
        if song_id:
            line += f" â†’ {song_id}"
        elif status == "pending":
            line += " (Ä‘ang chá» ID)"
        self.status_log.configure(state="normal")
        self.status_log.insert("1.0", line + "\n")
        self.status_log.configure(state="disabled")

        self._update_preview_entry(prompt_title, status, song_id)

        if status == "pending":
            self.pending_songs.append({
                "queue_id": queue_id,
                "account_name": account_name,
                "title": prompt_title,
                "created_at": datetime.now()
            })
        elif status == "success" and song_id:
            self.matched_song_ids.add(song_id)

    def _update_preview_entry(self, title: str, status: str, song_id: str | None):
        icon = self.STATUS_ICONS.get(status, "âŒ")
        updated = False
        for entry in self.preview_entries:
            if entry["title"] == title and entry["status"] in {"waiting", "pending"}:
                entry["status"] = status
                if song_id:
                    entry["text"] = f"{icon} {title} â†’ {song_id}"
                elif status == "pending":
                    entry["text"] = f"{icon} {title} (Ä‘ang chá» ID)"
                else:
                    entry["text"] = f"{icon} {title} (khÃ´ng thÃ nh cÃ´ng)"
                updated = True
                break
        if not updated:
            # fallback: append new line if not found
            note = f"{icon} {title}"
            if song_id:
                note += f" â†’ {song_id}"
            self.preview_entries.append({"title": title, "status": status, "text": note})
        self._refresh_preview_text()

    def _show_results(self, results: List[Dict[str, Any]]):
        self.result_text.delete("1.0", "end")
        successful = [r for r in results if r['success'] and not r.get('pending')]
        output = "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        output += f"Káº¾T QUáº¢: {len(successful)}/{len(results)} bÃ i thÃ nh cÃ´ng\n"
        output += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        for r in results:
            if r.get('pending'):
                status = "â³"
            else:
                status = "âœ…" if r['success'] else "âŒ"
            output += f"{status} {r['title']}\n"
            if r.get('error'):
                output += f"   â†³ Lá»—i: {r['error']}\n"
        self.result_text.insert("1.0", output)

    def refresh(self):
        accounts = self._get_account_list()
        self.account_dropdown.configure(values=accounts)
        if accounts and accounts[0] != "ChÆ°a cÃ³ account nÃ o":
            self.account_var.set(accounts[0])
        self._render_queue_list()
</file>

<file path="src/ui/song_creation_history_panel.py">
"""
Song Creation History Panel
"""
import math
from datetime import datetime
from pathlib import Path
from tkinter import filedialog, messagebox

import customtkinter as ctk

from config.settings import DOWNLOADS_DIR
from src.core import AccountManager
from src.core.song_creation_history_manager import SongCreationHistoryManager
from src.utils import format_datetime, logger


class SongCreationHistoryPanel(ctk.CTkFrame):
    """Panel hiá»ƒn thá»‹ lá»‹ch sá»­ táº¡o bÃ i hÃ¡t."""

    PAGE_SIZE = 20
    STATUS_ICONS = {
        "success": "âœ…",
        "pending": "â³",
        "failed": "âŒ"
    }

    def __init__(
        self,
        parent,
        account_manager: AccountManager,
        history_manager: SongCreationHistoryManager,
    ):
        super().__init__(parent)
        self.account_manager = account_manager
        self.history_manager = history_manager
        self.filtered_records = []
        self.current_page = 1
        self._copy_feedback_id = None

        self._build_ui()
        self.refresh()

    def _build_ui(self):
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(2, weight=1)

        header_frame = ctk.CTkFrame(self)
        header_frame.grid(row=0, column=0, sticky="ew", padx=20, pady=(0, 10))
        header_frame.grid_columnconfigure(1, weight=1)

        title = ctk.CTkLabel(
            header_frame,
            text="Lá»‹ch sá»­ Táº¡o BÃ i HÃ¡t",
            font=ctk.CTkFont(size=24, weight="bold")
        )
        title.grid(row=0, column=0, sticky="w")

        refresh_btn = ctk.CTkButton(
            header_frame,
            text="LÃ m má»›i",
            command=self.refresh,
            width=120
        )
        refresh_btn.grid(row=0, column=2, sticky="e")

        filter_frame = ctk.CTkFrame(self)
        filter_frame.grid(row=1, column=0, sticky="ew", padx=20, pady=(0, 5))
        filter_frame.grid_columnconfigure(2, weight=1)

        ctk.CTkLabel(filter_frame, text="Account:").grid(row=0, column=0, padx=5, pady=5, sticky="w")
        self.account_var = ctk.StringVar(value="Táº¥t cáº£")
        self.account_menu = ctk.CTkOptionMenu(
            filter_frame,
            values=["Táº¥t cáº£"],
            variable=self.account_var,
            command=self._on_filter_change,
            width=150
        )
        self.account_menu.grid(row=0, column=1, padx=5, pady=5, sticky="w")

        ctk.CTkLabel(filter_frame, text="TÃ¬m kiáº¿m:").grid(row=0, column=2, padx=5, pady=5, sticky="w")
        self.search_var = ctk.StringVar()
        search_entry = ctk.CTkEntry(filter_frame, textvariable=self.search_var, placeholder_text="TÃªn bÃ i hoáº·c ID")
        search_entry.grid(row=0, column=3, padx=5, pady=5, sticky="ew")
        search_entry.bind("<Return>", lambda _: self._apply_filters(reset_page=True))

        search_btn = ctk.CTkButton(
            filter_frame,
            text="TÃ¬m",
            command=lambda: self._apply_filters(reset_page=True),
            width=70
        )
        search_btn.grid(row=0, column=4, padx=5, pady=5)

        export_btn = ctk.CTkButton(
            filter_frame,
            text="Export CSV",
            command=self._export_csv,
            width=120
        )
        export_btn.grid(row=0, column=5, padx=5, pady=5, sticky="e")

        self.copy_feedback_label = ctk.CTkLabel(
            filter_frame,
            text="",
            text_color="gray"
        )
        self.copy_feedback_label.grid(row=1, column=0, columnspan=6, sticky="w", padx=5, pady=(0, 5))

        table_frame = ctk.CTkFrame(self)
        table_frame.grid(row=2, column=0, sticky="nsew", padx=20, pady=(0, 10))
        table_frame.grid_columnconfigure(0, weight=1)
        table_frame.grid_rowconfigure(1, weight=1)

        header_labels = ["Thá»i Gian", "Account", "TÃªn BÃ i", "Song ID", "Tráº¡ng ThÃ¡i"]
        header_row = ctk.CTkFrame(table_frame, fg_color="transparent")
        header_row.grid(row=0, column=0, sticky="ew", pady=(0, 5))
        for idx, text in enumerate(header_labels):
            ctk.CTkLabel(
                header_row,
                text=text,
                font=ctk.CTkFont(size=12, weight="bold")
            ).grid(row=0, column=idx, padx=10, sticky="w")

        self.table_body = ctk.CTkScrollableFrame(table_frame, corner_radius=10)
        self.table_body.grid(row=1, column=0, sticky="nsew")
        self.table_body.grid_columnconfigure(0, weight=1)

        pagination_frame = ctk.CTkFrame(self)
        pagination_frame.grid(row=3, column=0, sticky="ew", padx=20, pady=(0, 10))
        pagination_frame.grid_columnconfigure(1, weight=1)

        self.prev_btn = ctk.CTkButton(
            pagination_frame,
            text="â€¹ TrÆ°á»›c",
            command=self._prev_page,
            width=120
        )
        self.prev_btn.grid(row=0, column=0, padx=5, pady=5, sticky="w")

        self.page_label = ctk.CTkLabel(pagination_frame, text="")
        self.page_label.grid(row=0, column=1, padx=5, pady=5)

        self.next_btn = ctk.CTkButton(
            pagination_frame,
            text="Tiáº¿p â€º",
            command=self._next_page,
            width=120
        )
        self.next_btn.grid(row=0, column=2, padx=5, pady=5, sticky="e")

    def refresh(self):
        """Reload data and reapply filters."""
        self.history_manager.load_records()
        self._update_account_menu()
        self._apply_filters(reset_page=True)

    def _update_account_menu(self):
        accounts = self.account_manager.get_all_accounts()
        options = ["Táº¥t cáº£"] + [account.name for account in accounts]
        self.account_menu.configure(values=options)
        if self.account_var.get() not in options:
            self.account_var.set("Táº¥t cáº£")

    def _on_filter_change(self, _=None):
        self._apply_filters(reset_page=True)

    def _apply_filters(self, reset_page: bool = False):
        if reset_page:
            self.current_page = 1
        records = self.history_manager.get_all_records()

        account_filter = self.account_var.get()
        if account_filter and account_filter != "Táº¥t cáº£":
            records = [rec for rec in records if rec.account_name == account_filter]

        query = self.search_var.get().strip()
        if query:
            lower = query.lower()
            records = [
                rec for rec in records
                if lower in rec.title.lower() or lower in rec.song_id.lower()
                or lower in rec.status.lower()
            ]

        self.filtered_records = records
        self._render_table()

    def _render_table(self):
        for widget in self.table_body.winfo_children():
            widget.destroy()

        total = len(self.filtered_records)
        total_pages = max(1, math.ceil(total / self.PAGE_SIZE))
        self.current_page = min(self.current_page, total_pages)
        self.current_page = max(1, self.current_page)
        start = (self.current_page - 1) * self.PAGE_SIZE
        end = start + self.PAGE_SIZE
        page_records = self.filtered_records[start:end]

        if not page_records:
            empty_label = ctk.CTkLabel(
                self.table_body,
                text="ChÆ°a cÃ³ báº£n ghi nÃ o.",
                text_color="gray"
            )
            empty_label.grid(row=0, column=0, pady=20)
        else:
            for row_idx, record in enumerate(page_records):
                row_frame = ctk.CTkFrame(self.table_body, corner_radius=10, fg_color="#1f1f1f")
                row_frame.grid(row=row_idx, column=0, sticky="ew", pady=2, padx=2)
                row_frame.grid_columnconfigure(4, weight=1)
                row_frame.bind("<Button-1>", lambda event, rec=record: self._copy_song_id(rec.song_id))

                formatted_time = format_datetime(record.created_at)
                values = [
                    formatted_time,
                    record.account_name,
                    record.title,
                    record.song_id,
                    f"{self.STATUS_ICONS.get(record.status, '')} {record.status.capitalize()}"
                ]

                for col_idx, value in enumerate(values):
                    label = ctk.CTkLabel(row_frame, text=value, wraplength=180 if col_idx == 2 else None)
                    label.grid(row=0, column=col_idx, padx=8, pady=10, sticky="w")
                    label.bind("<Button-1>", lambda event, rec=record: self._copy_song_id(rec.song_id))

        self.page_label.configure(text=f"Trang {self.current_page}/{total_pages}")
        self.prev_btn.configure(state="disabled" if self.current_page <= 1 else "normal")
        self.next_btn.configure(state="disabled" if self.current_page >= total_pages else "normal")

    def _prev_page(self):
        if self.current_page > 1:
            self.current_page -= 1
            self._render_table()

    def _next_page(self):
        total = len(self.filtered_records)
        total_pages = max(1, math.ceil(total / self.PAGE_SIZE))
        if self.current_page < total_pages:
            self.current_page += 1
            self._render_table()

    def _copy_song_id(self, song_id: str):
        if not song_id:
            return

        self.clipboard_clear()
        self.clipboard_append(song_id)
        self.copy_feedback_label.configure(text=f"ÄÃ£ copy: {song_id}")
        if self._copy_feedback_id:
            self.after_cancel(self._copy_feedback_id)
        self._copy_feedback_id = self.after(2500, lambda: self.copy_feedback_label.configure(text=""))

    def _export_csv(self):
        now = datetime.now().strftime("%Y%m%d_%H%M%S")
        default_name = f"song-creation-history-{now}.csv"
        path = filedialog.asksaveasfilename(
            defaultextension=".csv",
            filetypes=[("CSV files", "*.csv")],
            initialfile=default_name,
            initialdir=DOWNLOADS_DIR
        )
        if not path:
            return

        try:
            output_path = Path(path)
            self.history_manager.export_to_csv(output_path)
            messagebox.showinfo("Export CSV", f"ÄÃ£ xuáº¥t {output_path}")
        except Exception as exc:
            logger.error(f"CSV export failed: {exc}")
            messagebox.showerror("Lá»—i", "KhÃ´ng thá»ƒ xuáº¥t lá»‹ch sá»­ sang CSV.")
</file>

<file path="src/utils/__init__.py">
"""
Utils package
"""
from .helpers import (
    atomic_write_json, load_json, save_json, sanitize_filename,
    format_filesize, format_duration, format_datetime,
    validate_profile_name, get_file_extension,
    ensure_dir, get_unique_filename
)
from .logger import logger
__all__ = [
    'atomic_write_json', 'load_json', 'save_json', 'sanitize_filename',
    'format_filesize', 'format_duration', 'format_datetime',
    'validate_profile_name', 'get_file_extension',
    'ensure_dir', 'get_unique_filename', 'logger',
]
</file>

<file path="src/utils/file_downloader.py">
"""
File Downloader Utility for Suno
Extracted from legacy_modules/suno_batch_download.py

Handles downloading audio files and thumbnails with progress tracking
"""
import os
import re
import time
import requests
from typing import Optional, List, Dict, Any
from pathlib import Path

from src.utils.logger import logger


class SunoFileDownloader:
    """
    Handles downloading files from Suno (audio and thumbnails)

    Responsibilities:
    - Download audio files with progress tracking
    - Download thumbnail images
    - Handle filename sanitization and uniqueness
    - Proxy support for downloads
    """

    def __init__(self, proxy_list: Optional[List[str]] = None):
        """
        Initialize file downloader

        Args:
            proxy_list: List of proxy URLs for requests
        """
        self.proxy_list = proxy_list or []

    def _get_random_proxy(self) -> Optional[Dict[str, str]]:
        """Get a random proxy from the proxy list"""
        if not self.proxy_list:
            return None
        proxy_url = self.proxy_list[len(self.proxy_list) % len(self.proxy_list)]
        return {'http': proxy_url, 'https': proxy_url}

    def sanitize_filename(self, name: str) -> str:
        """
        Sanitize filename by removing invalid characters

        Args:
            name: Original filename

        Returns:
            Sanitized filename
        """
        # Remove invalid characters
        invalid_chars = r'<>:"/\\|?*'
        for char in invalid_chars:
            name = name.replace(char, '')

        # Remove control characters
        name = re.sub(r'[\x00-\x1f\x7f]', '', name)

        # Trim spaces and dots at end
        name = name.strip().rstrip('.')

        return name

    def ensure_unique_filename(self, directory: str, base_name: str,
                              extension: str = '.mp3') -> str:
        """
        Ensure filename is unique in directory

        Args:
            directory: Target directory
            base_name: Base filename (without extension)
            extension: File extension

        Returns:
            Unique filepath
        """
        directory = Path(directory)
        directory.mkdir(parents=True, exist_ok=True)

        filepath = directory / f"{base_name}{extension}"
        counter = 1

        while filepath.exists():
            filepath = directory / f"{base_name}_{counter}{extension}"
            counter += 1

        return str(filepath)

    def download_audio(self, clip_info: Dict[str, Any], directory: str,
                      append_uuid: bool = False) -> Optional[str]:
        """
        Download audio file from clip info

        Args:
            clip_info: Clip information dictionary
            directory: Download directory
            append_uuid: Whether to append UUID to filename

        Returns:
            Path to downloaded file or None if failed
        """
        title = clip_info.get('title', 'Untitled')
        clip_id = clip_info.get('id', 'unknown')
        audio_url = clip_info.get('audio_url')

        if not audio_url:
            logger.warning(f"No audio URL for: {title}")
            return None

        # Create filename
        safe_title = self.sanitize_filename(title)
        if append_uuid:
            base_name = f"{safe_title}__ID__{clip_id}"
        else:
            base_name = safe_title

        file_path = self.ensure_unique_filename(directory, base_name, '.mp3')

        try:
            proxies = self._get_random_proxy()
            response = requests.get(audio_url, proxies=proxies, stream=True, timeout=60)
            response.raise_for_status()

            # Download with progress
            total_size = int(response.headers.get('content-length', 0))
            downloaded = 0

            with open(file_path, 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192):
                    f.write(chunk)
                    downloaded += len(chunk)

                    # Log progress for large files
                    if total_size > 1024 * 1024:  # > 1MB
                        progress = (downloaded / total_size) * 100 if total_size else 0
                        logger.debug(f"Download progress: {progress:.1f}%")

            file_size = os.path.getsize(file_path)
            size_mb = file_size / (1024 * 1024)
            logger.info(f"âœ“ Downloaded: {Path(file_path).name} ({size_mb:.2f} MB)")

            return file_path

        except Exception as e:
            logger.error(f"âŒ Failed to download {title}: {e}")
            if os.path.exists(file_path):
                os.remove(file_path)
            return None

    def download_thumbnail(self, clip_info: Dict[str, Any], directory: str) -> Optional[str]:
        """
        Download thumbnail/cover art

        Args:
            clip_info: Clip information dictionary
            directory: Download directory

        Returns:
            Path to downloaded thumbnail or None if failed
        """
        image_url = clip_info.get('image_url')
        if not image_url:
            return None

        clip_id = clip_info.get('id', 'unknown')
        filename = f"{clip_id}_cover.jpg"
        file_path = Path(directory) / filename

        try:
            proxies = self._get_random_proxy()
            response = requests.get(image_url, proxies=proxies, timeout=30)
            response.raise_for_status()

            with open(file_path, 'wb') as f:
                f.write(response.content)

            logger.info(f"âœ“ Downloaded thumbnail: {filename}")
            return str(file_path)

        except Exception as e:
            logger.warning(f"âš ï¸ Failed to download thumbnail: {e}")
            return None

    def download_batch(self, clips: List[Dict[str, Any]], directory: str,
                      with_thumbnails: bool = False, append_uuid: bool = False,
                      delay_between_downloads: float = 2.0) -> Dict[str, Any]:
        """
        Download multiple clips in batch

        Args:
            clips: List of clip info dictionaries
            directory: Download directory
            with_thumbnails: Whether to download thumbnails
            append_uuid: Whether to append UUID to filenames
            delay_between_downloads: Delay between downloads in seconds

        Returns:
            Statistics dictionary
        """
        logger.info(f"Starting batch download of {len(clips)} clips")

        # Create directory
        Path(directory).mkdir(parents=True, exist_ok=True)

        stats = {
            'total': len(clips),
            'successful': 0,
            'failed': 0,
            'downloaded_files': []
        }

        for idx, clip in enumerate(clips, 1):
            title = clip.get('title', 'Unknown')
            logger.info(f"[{idx}/{len(clips)}] Downloading: {title}")

            # Download audio
            audio_path = self.download_audio(clip, directory, append_uuid)

            if audio_path:
                stats['successful'] += 1
                stats['downloaded_files'].append({
                    'title': title,
                    'audio_path': audio_path,
                    'thumbnail_path': None
                })

                # Download thumbnail if requested
                if with_thumbnails:
                    thumbnail_path = self.download_thumbnail(clip, directory)
                    if thumbnail_path:
                        stats['downloaded_files'][-1]['thumbnail_path'] = thumbnail_path

            else:
                stats['failed'] += 1

            # Delay between downloads
            if idx < len(clips):
                time.sleep(delay_between_downloads)

        logger.info(f"Batch download completed: {stats['successful']} successful, {stats['failed']} failed")
        return stats

    def validate_download(self, file_path: str, expected_size: Optional[int] = None) -> bool:
        """
        Validate downloaded file

        Args:
            file_path: Path to downloaded file
            expected_size: Expected file size in bytes (optional)

        Returns:
            True if file is valid, False otherwise
        """
        if not os.path.exists(file_path):
            return False

        file_size = os.path.getsize(file_path)

        # Check minimum size (empty files are invalid)
        if file_size == 0:
            return False

        # Check expected size if provided
        if expected_size and abs(file_size - expected_size) > 1024:  # Allow 1KB tolerance
            logger.warning(f"File size mismatch: expected {expected_size}, got {file_size}")
            return False

        return True
</file>

<file path="src/utils/helpers.py">
"""
Utility helper functions for common operations
"""
import json
import os
import re
import tempfile
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional

from .logger import logger


def load_json(filepath: Path, default: Optional[Any] = None) -> Any:
    """
    Load JSON file from disk.
    
    Args:
        filepath: Path to JSON file
        default: Default value if file doesn't exist or error occurs
        
    Returns:
        Parsed JSON data or default value
    """
    if not filepath.exists():
        return default if default is not None else {}
    
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            return json.load(f)
    except Exception as e:
        print(f"Error loading {filepath}: {e}")
        return default if default is not None else {}


def save_json(filepath: Path, data: Any) -> bool:
    """
    Save data to JSON file.
    
    Args:
        filepath: Path to JSON file
        data: Data to save
        
    Returns:
        True if successful, False otherwise
    """
    try:
        filepath.parent.mkdir(parents=True, exist_ok=True)
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=4, ensure_ascii=False)
        return True
    except Exception as e:
        logger.error(f"Error saving {filepath}: {e}")
        return False


def atomic_write_json(filepath: Path, data: Any) -> bool:
    """
    Atomically write JSON to disk to avoid partial state files.
    """
    temp_file = None
    try:
        filepath.parent.mkdir(parents=True, exist_ok=True)
        temp_dir = filepath.parent
        with tempfile.NamedTemporaryFile(
            'w', encoding='utf-8', delete=False, dir=temp_dir
        ) as tmp:
            json.dump(data, tmp, indent=4, ensure_ascii=False)
            temp_file = Path(tmp.name)
        os.replace(temp_file, filepath)
        return True
    except Exception as exc:
        logger.error(f"Atomic write failed for {filepath}: {exc}")
        if temp_file and temp_file.exists():
            temp_file.unlink(missing_ok=True)
        return False


def sanitize_filename(filename: str) -> str:
    """
    Remove invalid characters from filename.
    
    Args:
        filename: Original filename
        
    Returns:
        Sanitized filename safe for Windows/Unix filesystems
    """
    # Remove invalid characters for Windows
    filename = re.sub(r'[<>:"/\\|?*]', '', filename)
    # Remove leading/trailing spaces and dots
    filename = filename.strip('. ')
    # Limit length
    if len(filename) > 200:
        filename = filename[:200]
    return filename or "untitled"


def format_filesize(size_bytes: int) -> str:
    """
    Format file size in human readable format.
    
    Args:
        size_bytes: Size in bytes
        
    Returns:
        Formatted size string (e.g., "1.23 MB")
    """
    for unit in ['B', 'KB', 'MB', 'GB']:
        if size_bytes < 1024.0:
            return f"{size_bytes:.2f} {unit}"
        size_bytes /= 1024.0
    return f"{size_bytes:.2f} TB"


def format_duration(seconds: float) -> str:
    """
    Format duration in MM:SS format.
    
    Args:
        seconds: Duration in seconds
        
    Returns:
        Formatted duration string
    """
    if not seconds:
        return "00:00"
    
    minutes = int(seconds // 60)
    secs = int(seconds % 60)
    return f"{minutes:02d}:{secs:02d}"


def format_datetime(dt_str: str) -> str:
    """
    Format datetime string to readable format.
    
    Args:
        dt_str: Datetime string in format "YYYY-MM-DD HH:MM:SS"
        
    Returns:
        Formatted datetime string or "N/A" if invalid
    """
    if not dt_str:
        return "N/A"
    
    try:
        dt = datetime.strptime(dt_str, "%Y-%m-%d %H:%M:%S")
        return dt.strftime("%d/%m/%Y %H:%M")
    except Exception:
        return dt_str


def validate_profile_name(name: str) -> bool:
    """
    Validate Suno profile name format.
    
    Args:
        name: Profile name to validate
        
    Returns:
        True if valid, False otherwise
    """
    if not name:
        return False
    
    # Must start with @
    if not name.startswith('@'):
        return False
    
    # Only alphanumeric and underscore after @
    username = name[1:]
    return bool(re.match(r'^[a-zA-Z0-9_]+$', username))


def get_file_extension(url: str, default: str = '.mp3') -> str:
    """
    Get file extension from URL.
    
    Args:
        url: URL string
        default: Default extension if unable to parse
        
    Returns:
        File extension with dot (e.g., ".mp3")
    """
    try:
        from urllib.parse import urlparse
        path = urlparse(url).path
        ext = os.path.splitext(path)[1]
        return ext if ext else default
    except Exception:
        return default


def ensure_dir(path: Path) -> Path:
    """
    Ensure directory exists, creating it if necessary.
    
    Args:
        path: Directory path
        
    Returns:
        The path object
    """
    path.mkdir(parents=True, exist_ok=True)
    return path


def get_unique_filename(filepath: Path) -> Path:
    """
    Get unique filename by appending number if file exists.
    
    Args:
        filepath: Original filepath
        
    Returns:
        Unique filepath
    """
    if not filepath.exists():
        return filepath
    
    counter = 1
    stem = filepath.stem
    suffix = filepath.suffix
    parent = filepath.parent
    
    while True:
        new_path = parent / f"{stem} ({counter}){suffix}"
        if not new_path.exists():
            return new_path
        counter += 1
</file>

<file path="src/utils/logger.py">
"""
Logger utility for application-wide logging
"""
import logging
from pathlib import Path
from datetime import datetime


class Logger:
    """Application logger singleton with file and console handlers"""
    
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance._initialize()
        return cls._instance
    
    def _initialize(self) -> None:
        """Initialize logger with file and console handlers"""
        self._initialized = True
        self.logger = logging.getLogger("SunoApp")
        self.logger.setLevel(logging.INFO)
        
        # Remove existing handlers to avoid duplicates
        self.logger.handlers.clear()
        
        # Create logs directory
        log_dir = Path(__file__).parent.parent.parent / "logs"
        log_dir.mkdir(exist_ok=True)
        
        # File handler
        log_file = log_dir / f"app_{datetime.now().strftime('%Y%m%d')}.log"
        file_handler = logging.FileHandler(log_file, encoding='utf-8')
        file_handler.setLevel(logging.INFO)
        
        # Console handler
        console_handler = logging.StreamHandler()
        console_handler.setLevel(logging.INFO)
        
        # Formatter
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        file_handler.setFormatter(formatter)
        console_handler.setFormatter(formatter)
        
        # Add handlers
        self.logger.addHandler(file_handler)
        self.logger.addHandler(console_handler)
    
    def info(self, message: str) -> None:
        """Log info message"""
        self.logger.info(message)
    
    def warning(self, message: str) -> None:
        """Log warning message"""
        self.logger.warning(message)
    
    def error(self, message: str) -> None:
        """Log error message"""
        self.logger.error(message)
    
    def debug(self, message: str) -> None:
        """Log debug message"""
        self.logger.debug(message)


# Singleton instance
logger = Logger()
</file>

<file path="src/utils/metadata_handler.py">
"""
Metadata Handler for Suno Audio Files
Extracted from legacy_modules/suno_batch_download.py

Handles embedding metadata and cover art into MP3 files using Mutagen
"""
import os
from typing import Optional, Dict, Any
from pathlib import Path

from src.utils.logger import logger


class SunoMetadataHandler:
    """
    Handles metadata embedding for Suno audio files

    Responsibilities:
    - Embed ID3 tags (title, artist, album, genre)
    - Embed cover art/thumbnail
    - Handle metadata extraction from clip info
    """

    def __init__(self):
        """Initialize metadata handler"""
        self._mutagen_available = self._check_mutagen_availability()

    def _check_mutagen_availability(self) -> bool:
        """Check if mutagen library is available"""
        try:
            import mutagen
            import mutagen.id3
            import mutagen.mp3
            return True
        except ImportError:
            logger.warning("Mutagen library not available - metadata embedding disabled")
            return False

    def embed_metadata(self, audio_path: str, clip_info: Dict[str, Any],
                      thumbnail_path: Optional[str] = None) -> bool:
        """
        Embed metadata into MP3 file

        Args:
            audio_path: Path to the MP3 file
            clip_info: Clip information dictionary
            thumbnail_path: Optional path to thumbnail image

        Returns:
            True if successful, False otherwise
        """
        if not self._mutagen_available:
            logger.info("Skipping metadata embedding (mutagen not available)")
            return False

        if not os.path.exists(audio_path):
            logger.error(f"Audio file not found: {audio_path}")
            return False

        try:
            from mutagen.id3 import ID3, TIT2, TPE1, TALB, TCON, TPUB, WOAR, APIC
            from mutagen.mp3 import MP3

            # Load audio file
            audio = MP3(audio_path, ID3=ID3)

            # Delete existing ID3 tags if present
            try:
                audio.delete()
                audio.save()
            except Exception:
                # No existing tags, continue
                pass

            # Reload file and add new tags
            audio = MP3(audio_path, ID3=ID3)
            
            # Add tags (will create new tag structure)
            try:
                audio.add_tags()
            except Exception:
                # Tags already exist after reload, clear them
                audio.tags.clear()

            # Basic metadata
            title = clip_info.get('title', '')
            if title:
                audio.tags.add(TIT2(encoding=3, text=title))

            # Artist (display_name)
            display_name = clip_info.get('display_name', '')
            if display_name:
                audio.tags.add(TPE1(encoding=3, text=display_name))

            # Album (can be same as artist or custom)
            if display_name:
                audio.tags.add(TALB(encoding=3, text=f"{display_name} - Suno AI"))

            # Genre from tags
            tags = clip_info.get('metadata', {}).get('tags', [])
            if tags:
                genre_text = ', '.join(tags)
                audio.tags.add(TCON(encoding=3, text=genre_text))

            # Publisher (same as artist)
            if display_name:
                audio.tags.add(TPUB(encoding=3, text=display_name))

            # Song URL
            clip_id = clip_info.get('id', '')
            if clip_id:
                song_url = f"https://suno.com/song/{clip_id}"
                audio.tags.add(WOAR(url=song_url))

            # Cover art
            if thumbnail_path and os.path.exists(thumbnail_path):
                self._embed_cover_art(audio, thumbnail_path)

            audio.save()
            logger.info(f"âœ“ Embedded metadata for: {Path(audio_path).name}")
            return True

        except Exception as e:
            logger.error(f"âŒ Failed to embed metadata: {e}")
            return False

    def _embed_cover_art(self, audio: 'MP3', thumbnail_path: str) -> bool:
        """
        Embed cover art into audio file

        Args:
            audio: Mutagen MP3 object
            thumbnail_path: Path to thumbnail image

        Returns:
            True if successful, False otherwise
        """
        try:
            from mutagen.id3 import APIC

            with open(thumbnail_path, 'rb') as img_file:
                image_data = img_file.read()

            # Determine MIME type
            mime_type = self._get_image_mime_type(thumbnail_path)

            audio.tags.add(
                APIC(
                    encoding=3,  # UTF-8
                    mime=mime_type,
                    type=3,  # Cover (front)
                    desc='Cover',
                    data=image_data
                )
            )

            logger.info("âœ“ Embedded cover art")
            return True

        except Exception as e:
            logger.error(f"âŒ Failed to embed cover art: {e}")
            return False

    def _get_image_mime_type(self, image_path: str) -> str:
        """
        Determine MIME type from file extension

        Args:
            image_path: Path to image file

        Returns:
            MIME type string
        """
        ext = Path(image_path).suffix.lower()
        mime_types = {
            '.jpg': 'image/jpeg',
            '.jpeg': 'image/jpeg',
            '.png': 'image/png',
            '.gif': 'image/gif',
            '.webp': 'image/webp'
        }
        return mime_types.get(ext, 'image/jpeg')

    def extract_metadata(self, clip_info: Dict[str, Any]) -> Dict[str, Any]:
        """
        Extract metadata fields from clip info

        Args:
            clip_info: Raw clip information

        Returns:
            Cleaned metadata dictionary
        """
        metadata = {
            'title': clip_info.get('title', ''),
            'artist': clip_info.get('display_name', ''),
            'album': '',
            'genre': '',
            'year': '',
            'url': '',
            'tags': []
        }

        # Set album
        if metadata['artist']:
            metadata['album'] = f"{metadata['artist']} - Suno AI"

        # Extract tags as genre
        tags = clip_info.get('metadata', {}).get('tags', [])
        if tags:
            metadata['genre'] = ', '.join(tags)
            metadata['tags'] = tags

        # Song URL
        clip_id = clip_info.get('id', '')
        if clip_id:
            metadata['url'] = f"https://suno.com/song/{clip_id}"

        return metadata

    def validate_audio_file(self, audio_path: str) -> bool:
        """
        Validate that file is a valid audio file

        Args:
            audio_path: Path to audio file

        Returns:
            True if valid, False otherwise
        """
        if not os.path.exists(audio_path):
            return False

        if not self._mutagen_available:
            # Basic check without mutagen
            return audio_path.lower().endswith(('.mp3', '.wav', '.flac', '.m4a'))

        try:
            from mutagen import File
            audio = File(audio_path)
            return audio is not None and hasattr(audio, 'info')
        except Exception:
            return False
</file>

<file path="src/utils/prompt_parser.py">
"""
Suno Prompt Parser - Parse XML prompt files
"""
import xml.etree.ElementTree as ET
from pathlib import Path
from typing import Dict, Optional
from dataclasses import dataclass


@dataclass
class SunoPrompt:
    """Parsed Suno prompt data"""
    title: str
    lyrics: str
    style: str
    
    def __str__(self):
        return f"Title: {self.title}\nStyle: {self.style}\nLyrics:\n{self.lyrics[:100]}..."


class SunoPromptParser:
    """Parser for Suno XML prompt files"""
    
    @staticmethod
    def parse_file(file_path: str) -> Optional[SunoPrompt]:
        """
        Parse XML file and extract first prompt
        
        Args:
            file_path: Path to XML file
            
        Returns:
            SunoPrompt object or None if parsing fails
        """
        try:
            path = Path(file_path)
            if not path.exists():
                print(f"âŒ File not found: {file_path}")
                return None
            
            content = path.read_text(encoding='utf-8')
            
            # Parse XML
            root = ET.fromstring(f"<root>{content}</root>")
            
            # Extract first occurrence of each tag
            title_elem = root.find('TITLE')
            lyrics_elem = root.find('LYRICS')
            style_elem = root.find('STYLE')
            
            if title_elem is None or lyrics_elem is None or style_elem is None:
                print(f"âŒ Missing required tags (TITLE, LYRICS, STYLE)")
                return None
            
            title = (title_elem.text or "").strip()
            lyrics = (lyrics_elem.text or "").strip()
            style = (style_elem.text or "").strip()
            
            if not title or not lyrics or not style:
                print(f"âŒ Empty required fields")
                return None
            
            return SunoPrompt(
                title=title,
                lyrics=lyrics,
                style=style
            )
            
        except ET.ParseError as e:
            print(f"âŒ XML parsing error: {e}")
            return None
        except Exception as e:
            print(f"âŒ Error parsing file: {e}")
            return None
    
    @staticmethod
    def parse_all_from_file(file_path: str) -> list[SunoPrompt]:
        """
        Parse XML file and extract ALL prompts
        
        Args:
            file_path: Path to XML file
            
        Returns:
            List of SunoPrompt objects
        """
        try:
            path = Path(file_path)
            if not path.exists():
                print(f"âŒ File not found: {file_path}")
                return []
            
            content = path.read_text(encoding='utf-8')
            
            # Parse XML
            root = ET.fromstring(f"<root>{content}</root>")
            
            # Find all sets of TITLE+LYRICS+STYLE
            titles = [t.text.strip() for t in root.findall('TITLE') if t.text]
            lyrics_list = [l.text.strip() for l in root.findall('LYRICS') if l.text]
            styles = [s.text.strip() for s in root.findall('STYLE') if s.text]
            
            # Group them (assuming they appear in order)
            prompts = []
            count = min(len(titles), len(lyrics_list), len(styles))
            
            for i in range(count):
                prompts.append(SunoPrompt(
                    title=titles[i],
                    lyrics=lyrics_list[i],
                    style=styles[i]
                ))
            
            print(f"âœ“ Parsed {len(prompts)} prompts from file")
            return prompts
            
        except ET.ParseError as e:
            print(f"âŒ XML parsing error: {e}")
            return []
        except Exception as e:
            print(f"âŒ Error parsing file: {e}")
            return []


# Demo usage
if __name__ == "__main__":
    # Test with your XML file
    xml_file = "src/prompt/suno-prompt.xml"
    
    print("=" * 60)
    print("Parse first prompt:")
    print("=" * 60)
    prompt = SunoPromptParser.parse_file(xml_file)
    if prompt:
        print(f"\n{prompt}")
        print(f"\nFull lyrics:\n{prompt.lyrics}")
    
    print("\n" + "=" * 60)
    print("Parse all prompts:")
    print("=" * 60)
    prompts = SunoPromptParser.parse_all_from_file(xml_file)
    for i, p in enumerate(prompts, 1):
        print(f"\n--- Prompt {i} ---")
        print(f"Title: {p.title}")
        print(f"Style: {p.style}")
        print(f"Lyrics preview: {p.lyrics[:50]}...")
</file>

<file path="src/utils/stealth_driver.py">
"""
Stealth WebDriver Setup - Anti-detection cho Selenium
TrÃ¡nh CAPTCHA vÃ  bot detection trÃªn Suno.com
"""
import random
from pathlib import Path
from selenium import webdriver
from selenium.webdriver.chrome.options import Options


# User-Agent pool (Chrome trÃªn Windows 11)
USER_AGENTS = [
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36",
]


def create_stealth_driver(profile_path: Path, headless: bool = False) -> webdriver.Chrome:
    """
    Táº¡o ChromeDriver vá»›i anti-detection tá»‘i Ä‘a.
    
    Args:
        profile_path: ÄÆ°á»ng dáº«n profile Chrome (giá»¯ session/cookies)
        headless: Cháº¡y cháº¿ Ä‘á»™ áº©n (tÄƒng risk CAPTCHA, khÃ´ng khuyáº¿n khÃ­ch)
    
    Returns:
        webdriver.Chrome vá»›i stealth options
    """
    options = Options()
    
    # 1. User profile (quan trá»ng nháº¥t - giá»¯ session)
    options.add_argument(f'--user-data-dir={profile_path}')
    
    # 2. User-Agent rotation
    ua = random.choice(USER_AGENTS)
    options.add_argument(f'--user-agent={ua}')
    
    # 3. Anti-detection flags
    options.add_argument('--disable-blink-features=AutomationControlled')
    options.add_experimental_option('excludeSwitches', ['enable-automation', 'enable-logging'])
    options.add_experimental_option('useAutomationExtension', False)
    
    # 4. ThÃªm cÃ¡c flag giá»‘ng browser tháº­t
    options.add_argument('--disable-dev-shm-usage')
    options.add_argument('--no-sandbox')
    options.add_argument('--disable-gpu')  # TrÃ¡nh má»™t sá»‘ fingerprint
    options.add_argument('--disable-infobars')
    options.add_argument('--start-maximized')
    
    # 5. Preferences (táº¯t cÃ¡c thÃ´ng bÃ¡o automation)
    prefs = {
        'profile.default_content_setting_values.notifications': 2,
        'credentials_enable_service': False,
        'profile.password_manager_enabled': False,
    }
    options.add_experimental_option('prefs', prefs)
    
    # 6. Headless mode (náº¿u cáº§n, nhÆ°ng dá»… bá»‹ phÃ¡t hiá»‡n hÆ¡n)
    if headless:
        options.add_argument('--headless=new')  # Chrome headless mode má»›i
        options.add_argument('--window-size=1920,1080')
    
    driver = webdriver.Chrome(options=options)
    
    # 7. Inject stealth JS scripts
    _inject_stealth_scripts(driver)
    
    return driver


def _inject_stealth_scripts(driver: webdriver.Chrome):
    """
    Inject cÃ¡c script JS Ä‘á»ƒ áº©n dáº¥u hiá»‡u automation.
    Cháº¡y ngay sau khi táº¡o driver, trÆ°á»›c khi navigate.
    """
    # Script 1: áº¨n navigator.webdriver
    driver.execute_cdp_cmd('Page.addScriptToEvaluateOnNewDocument', {
        'source': '''
            Object.defineProperty(navigator, 'webdriver', {
                get: () => undefined
            });
        '''
    })
    
    # Script 2: Override plugins/languages Ä‘á»ƒ giá»‘ng browser tháº­t
    driver.execute_cdp_cmd('Page.addScriptToEvaluateOnNewDocument', {
        'source': '''
            Object.defineProperty(navigator, 'plugins', {
                get: () => [1, 2, 3, 4, 5]
            });
            Object.defineProperty(navigator, 'languages', {
                get: () => ['en-US', 'en', 'vi-VN', 'vi']
            });
        '''
    })
    
    # Script 3: Chrome runtime mock
    driver.execute_cdp_cmd('Page.addScriptToEvaluateOnNewDocument', {
        'source': '''
            window.chrome = {
                runtime: {}
            };
        '''
    })
    
    # Script 4: Permission API mock
    driver.execute_cdp_cmd('Page.addScriptToEvaluateOnNewDocument', {
        'source': '''
            const originalQuery = window.navigator.permissions.query;
            window.navigator.permissions.query = (parameters) => (
                parameters.name === 'notifications' ?
                    Promise.resolve({ state: Notification.permission }) :
                    originalQuery(parameters)
            );
        '''
    })


def add_human_delays():
    """
    Tráº£ vá» random delay giá»‘ng hÃ nh vi ngÆ°á»i dÃ¹ng tháº­t.
    DÃ¹ng giá»¯a cÃ¡c thao tÃ¡c: click, fill form, scroll.
    Range: 3-5 giÃ¢y Ä‘á»ƒ trÃ¡nh CAPTCHA khi submit.
    """
    import time
    delay = random.uniform(3.0, 5.0)
    time.sleep(delay)
    return delay
</file>

<file path="tools/clicknium_to_xpath.py">
"""
Clicknium Locator to XPath Converter
Äá»c file .cnstore vÃ  generate XPath selectors
"""
import json
from pathlib import Path
from typing import Dict, List, Optional


class ClickniumToXPath:
    """Convert Clicknium locators sang Selenium XPath"""
    
    def __init__(self, cnstore_path: str):
        """
        Args:
            cnstore_path: Path to .cnstore file
        """
        self.cnstore_path = Path(cnstore_path)
        self.locators = self._load_locators()
    
    def _load_locators(self) -> Dict:
        """Load JSON tá»« .cnstore file"""
        with open(self.cnstore_path, 'r', encoding='utf-8-sig') as f:
            data = json.load(f)
        return data
    
    def _get_identifier(self, locator: Dict) -> Optional[Dict]:
        """Extract identifier tá»« nested structure"""
        try:
            return locator['content']['childControls'][0]['childControls'][0]['identifier']
        except (KeyError, IndexError):
            return None
    
    def to_xpath(self, locator_name: str) -> Optional[str]:
        """
        Convert má»™t locator thÃ nh XPath
        
        Args:
            locator_name: TÃªn locator trong .cnstore (vd: "button_male")
            
        Returns:
            XPath string hoáº·c None
        """
        # TÃ¬m locator theo name
        locator = None
        for loc in self.locators.get('locators', []):
            if loc['name'] == locator_name:
                locator = loc
                break
        
        if not locator:
            print(f"âŒ KhÃ´ng tÃ¬m tháº¥y locator: {locator_name}")
            return None
        
        identifier = self._get_identifier(locator)
        if not identifier:
            print(f"âŒ KhÃ´ng parse Ä‘Æ°á»£c identifier: {locator_name}")
            return None
        
        # Build XPath tá»« identifier
        return self._build_xpath(identifier)
    
    def _build_xpath(self, identifier: Dict) -> str:
        """Build XPath tá»« identifier object"""
        parts = []
        
        # Tag
        tag = identifier.get('tag', {}).get('value', '*').lower()
        parts.append(f"//{tag}")
        
        conditions = []
        
        # Placeholder
        if 'placeholder' in identifier:
            placeholder_obj = identifier['placeholder']
            if isinstance(placeholder_obj, dict):
                placeholder = placeholder_obj.get('value')
                if placeholder:
                    conditions.append(f"contains(@placeholder, '{placeholder}')")
        
        # ARIA label
        if 'aria-label' in identifier:
            aria_obj = identifier['aria-label']
            if isinstance(aria_obj, dict):
                aria = aria_obj.get('value')
                if aria:
                    conditions.append(f"@aria-label='{aria}'")
        
        # Role
        if 'role' in identifier:
            role_obj = identifier['role']
            if isinstance(role_obj, dict):
                role = role_obj.get('value')
                if role:
                    conditions.append(f"@role='{role}'")
        
        # Text content (sInfo)
        if 'sInfo' in identifier:
            text = identifier['sInfo'].get('value')
            if text:
                conditions.append(f"normalize-space(.)='{text}'")
        
        # Type
        if 'type' in identifier:
            type_val = identifier['type'].get('value')
            if type_val:
                conditions.append(f"@type='{type_val}'")
        
        # data-selected (custom attribute)
        if 'data-selected' in identifier:
            selected_obj = identifier['data-selected']
            if isinstance(selected_obj, dict):
                selected = selected_obj.get('value')
                if selected:
                    conditions.append(f"@data-selected='{selected}'")
        
        # Ancestor class (náº¿u cÃ³)
        ancestor_class = identifier.get('ancestorClass', {}).get('value')
        if ancestor_class:
            # Láº¥y class Ä‘áº§u tiÃªn (stable nháº¥t)
            first_class = ancestor_class.split()[0]
            conditions.append(f"ancestor::div[contains(@class, '{first_class}')]")
        
        # Combine conditions
        if conditions:
            xpath = parts[0] + '[' + ' and '.join(conditions) + ']'
        else:
            xpath = parts[0]
        
        return xpath
    
    def generate_all(self) -> Dict[str, str]:
        """Generate XPath cho táº¥t cáº£ locators"""
        result = {}
        for locator in self.locators.get('locators', []):
            name = locator['name']
            xpath = self.to_xpath(name)
            if xpath:
                result[name] = xpath
        return result
    
    def print_summary(self):
        """In ra summary cá»§a táº¥t cáº£ locators"""
        print("=" * 80)
        print(f"CLICKNIUM LOCATOR SUMMARY: {self.cnstore_path.name}")
        print("=" * 80)
        
        locators = self.locators.get('locators', [])
        print(f"\nTá»•ng sá»‘ locators: {len(locators)}\n")
        
        for i, loc in enumerate(locators, 1):
            name = loc['name']
            xpath = self.to_xpath(name)
            
            print(f"{i}. {name}")
            print(f"   XPath: {xpath}")
            print()
    
    def export_to_python(self, output_path: str):
        """Export thÃ nh Python constants file"""
        all_xpaths = self.generate_all()
        
        content = '''"""
Auto-generated XPath selectors from Clicknium locators
Source: .locator/suno.cnstore
Generated: 2025-11-09
"""

class SunoSelectors:
    """XPath selectors cho Suno.com táº¡o nháº¡c"""
    
'''
        
        for name, xpath in all_xpaths.items():
            # Convert name to CONSTANT_CASE
            const_name = name.upper().replace('-', '_')
            content += f'    {const_name} = "{xpath}"\n'
        
        content += '''

# Dictionary for dynamic access
SELECTORS = {
'''
        
        for name, xpath in all_xpaths.items():
            const_name = name.upper().replace('-', '_')
            content += f'    "{name}": SunoSelectors.{const_name},\n'
        
        content += '}\n'
        
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(content)
        
        print(f"âœ“ Exported to: {output_path}")


# Demo usage
if __name__ == "__main__":
    converter = ClickniumToXPath(".locator/suno.cnstore")
    
    # Print summary
    converter.print_summary()
    
    print("\n" + "=" * 80)
    print("SPECIFIC EXAMPLES")
    print("=" * 80 + "\n")
    
    # Test specific locators
    test_locators = [
        "button_male",
        "button_female",
        "textarea_write_some_lyrics_or_a_prompt",
        "input_song_title_optional",
        "slider_weirdness",
        "button_create_song"
    ]
    
    for name in test_locators:
        xpath = converter.to_xpath(name)
        print(f"{name}:")
        print(f"  {xpath}\n")
    
    # Export to Python file
    print("=" * 80)
    converter.export_to_python("config/suno_selectors_from_clicknium.py")
</file>

<file path="tools/patch_download_panel.py">
#!/usr/bin/env python3
"""Patch download_panel.py to use paginated streaming"""

f = open('src/ui/download_panel.py', 'r', encoding='utf-8')
lines = f.readlines()
f.close()

# Replace lines 344-378 (the download logic block)
new_block = '''            # Use paginated streaming download to save memory
            self.update_progress("Äang chuáº©n bá»‹ táº£i...", 10)

            # Determine start page from history if resume enabled
            start_page = 0
            if self.resume_var.get():
                history = self.download_manager.get_history(self.selected_account)
                # Start from page 0 and let history skip downloaded clips
                start_page = 0
            
            # Use batch_download_paginated for memory-efficient page-by-page processing
            stats = self.download_manager.batch_download_paginated(
                account_name=self.selected_account,
                session_token=session_token,
                output_dir=output_path,
                profile_name=profile_name,
                use_create_page=use_my_songs,
                start_page=start_page,
                max_pages=None,  # Download all pages
                with_thumbnail=self.thumbnail_var.get(),
                append_uuid=self.uuid_var.get(),
                progress_callback=self.update_progress,
                delay=2
            )

            # Show result
            message = (
                f"âœ… ThÃ nh cÃ´ng: {stats.get('success', 0)}\\n"
                f"âŒ Tháº¥t báº¡i: {stats.get('failed', 0)}\\n"
                f"â­ï¸  ÄÃ£ bá» qua: {stats.get('skipped', 0)}\\n"
                f"ðŸ“„ Tá»•ng sá»‘ trang: {stats.get('total_pages', 0)}\\n"
                f"ðŸ“Š Tá»•ng Ä‘Ã£ táº£i: {stats.get('success', 0) + stats.get('skipped', 0)} bÃ i\\n\\n"
                f"ðŸ“ ThÆ° má»¥c: {output_path}"
            )
            messagebox.showinfo("HoÃ n thÃ nh!", message)
'''

result = lines[:343] + [new_block + '\n'] + lines[378:]
f = open('src/ui/download_panel.py', 'w', encoding='utf-8', newline='')
f.writelines(result)
f.close()
print('Updated download_panel.py with paginated streaming')
</file>

<file path="tools/sync_todos.py">
#!/usr/bin/env python3
"""
Sync a todo-list JSON to memory-bank task markdown files and update tasks/_index.md.

Usage:
  python tools/sync_todos.py path/to/todos.json

todos.json format: an array of objects with fields:
  id: integer
  title: string
  description: string
  status: string (Pending | In Progress | Completed | Abandoned)
  added: optional ISO date string
  updated: optional ISO date string

This script will create or update files under memory-bank/tasks/TASK{ID:03d}-{slug}.md
and regenerate memory-bank/tasks/_index.md grouping tasks by status.
"""
from __future__ import annotations
import json
import re
import sys
from pathlib import Path
from datetime import datetime


BASE = Path(__file__).resolve().parents[1]
TASKS_DIR = BASE / 'memory-bank' / 'tasks'
INDEX_FILE = TASKS_DIR / '_index.md'


def slugify(s: str) -> str:
    s = s.lower()
    s = re.sub(r"[^a-z0-9\s-]", "", s)
    s = re.sub(r"[\s_]+", "-", s)
    s = re.sub(r"-+", "-", s)
    return s.strip('-')[:50]


TEMPLATE = """# TASK{tid:03d} - {title}

**Status:** {status}  
**Added:** {added}  
**Updated:** {updated}

## Original Request
{description}

## Thought Process

## Implementation Plan

## Progress Tracking

**Overall Status:** {status}

### Subtasks
| ID | Description | Status | Updated | Notes |
|----|-------------|--------|---------|-------|

## Progress Log
### {date}
- Created/Updated by sync_todos.py: status set to {status}

"""


def load_todos(path: Path):
    with path.open('r', encoding='utf-8') as f:
        return json.load(f)


def write_task_file(task: dict):
    tid = int(task['id'])
    title = task['title']
    status = task.get('status', 'Pending')
    desc = task.get('description', '')
    added = task.get('added') or datetime.utcnow().strftime('%Y-%m-%d')
    updated = datetime.utcnow().strftime('%Y-%m-%d')

    slug = slugify(title)
    fname = TASKS_DIR / f"TASK{tid:03d}-{slug}.md"

    content = TEMPLATE.format(tid=tid, title=title, status=status, added=added, updated=updated, description=desc, date=updated)

    if fname.exists():
        # append progress log entry
        txt = fname.read_text(encoding='utf-8')
        # replace Status / Updated fields
        txt = re.sub(r"\*\*Status:\*\*.*\n", f"**Status:** {status}  \n", txt, count=1)
        txt = re.sub(r"\*\*Updated:\*\*.*\n", f"**Updated:** {updated}\n", txt, count=1)
        # append new progress log entry
        txt += f"\n### {updated}\n- Synchronized: status set to {status}\n"
        fname.write_text(txt, encoding='utf-8')
        return fname

    fname.write_text(content, encoding='utf-8')
    return fname


def regenerate_index():
    # Collect task files
    tasks = []
    for p in sorted(TASKS_DIR.glob('TASK*.md')):
        if p.name == '_index.md':
            continue
        text = p.read_text(encoding='utf-8')
        # parse header
        first_line = text.splitlines()[0].strip()
        m = re.match(r"# TASK(\d{3}) - (.*)", first_line)
        if not m:
            continue
        tid = m.group(1)
        title = m.group(2).strip()
        status_match = re.search(r"\*\*Status:\*\*\s*(.*)", text)
        status = status_match.group(1).strip() if status_match else 'Pending'
        tasks.append({'id': int(tid), 'title': title, 'status': status})

    sections = {'In Progress': [], 'Pending': [], 'Completed': [], 'Abandoned': []}
    for t in tasks:
        s = t['status']
        if 'in progress' in s.lower():
            sections['In Progress'].append(t)
        elif 'pending' in s.lower():
            sections['Pending'].append(t)
        elif 'completed' in s.lower():
            sections['Completed'].append(t)
        elif 'abandoned' in s.lower():
            sections['Abandoned'].append(t)
        else:
            sections['Pending'].append(t)

    lines = ['````markdown', '# Tasks Index', '', '## In Progress', '']
    if sections['In Progress']:
        for t in sections['In Progress']:
            lines.append(f"- [TASK{t['id']:03d}] {t['title']}")
    else:
        lines.append('*No tasks currently in progress*')

    lines += ['', '## Pending', '']
    if sections['Pending']:
        for t in sections['Pending']:
            lines.append(f"- [TASK{t['id']:03d}] {t['title']}")
    else:
        lines.append('*No pending tasks*')

    lines += ['', '## Completed', '']
    if sections['Completed']:
        for t in sections['Completed']:
            lines.append(f"- [TASK{t['id']:03d}] {t['title']}")
    else:
        lines.append('*No completed tasks*')

    lines += ['', '## Abandoned', '']
    if sections['Abandoned']:
        for t in sections['Abandoned']:
            lines.append(f"- [TASK{t['id']:03d}] {t['title']}")
    else:
        lines.append('*No abandoned tasks*')

    lines.append('\n---\n')
    lines.append('\n*This index is automatically updated as tasks are created, updated, and completed.*')
    lines.append('\n````')

    INDEX_FILE.write_text('\n'.join(lines), encoding='utf-8')
    return INDEX_FILE


def main(argv):
    if len(argv) < 2:
        print('Usage: sync_todos.py path/to/todos.json')
        return 2

    path = Path(argv[1])
    if not path.exists():
        print('File not found:', path)
        return 2

    todos = load_todos(path)
    TASKS_DIR.mkdir(parents=True, exist_ok=True)

    for t in todos:
        write_task_file(t)

    idx = regenerate_index()
    print('Regenerated index at', idx)
    return 0


if __name__ == '__main__':
    raise SystemExit(main(sys.argv))
</file>

</files>
